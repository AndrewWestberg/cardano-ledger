\section{Update mechanism}
\label{sec:update}

\newcommand{\UpdProp}{\type{UpdProp}}
\newcommand{\UpdPropBody}{\type{UpdPropBody}}

\lstset{ frame=tb,
       , language=Haskell
       , basicstyle=\footnotesize\ttfamily,
       , keywordstyle=\color{blue!80},
       , commentstyle=\itshape\color{purple!40!black},
       , identifierstyle=\bfseries\color{green!40!black},
       , stringstyle=\color{orange},
       }

\lstMakeShortInline[columns=fixed]`

\subsection{Aspects that we need to model}
\label{sec:aspects-to-model}

\begin{description}
\item[Authentication] Update proposals and votes are authenticated (properly
  signed).
\item[Authorization] Only genesis keys (via deleg certs) can post update
  proposals.
  \begin{itemize}
  \item Only then they can vote on them.
  \end{itemize}
\item[Voting deadlines] voting end when a majority of the voters (4/7 if we
assume no stake) agree on the proposal.
\item[Block versions] (= protocol versions)
\item[Soft-forks] a protocol version changes according to the fork-resolution
  rule (75\% of stake create blocks with new-version).
\item[Hard-forks] ??? Do we need to model anything here?.
\end{description}

In particular the rules need to capture:

\begin{enumerate}
\item Each genesis key can post (either directly or via its delegate), one update proposal per-epoch.
\item When does an update proposal becomes \textbf{active}.
\item We cannot add a proposal if there exists one with the same id\footnote{id
    = hash of the update proposal} that is already active.
\item If there are two proposals submitted for the same block version, then
  these proposals need to agree on the values of the updated parameters.
\end{enumerate}

Remarks:
\begin{itemize}
\item We do not distinguish between protocol or software updates. The ledger
  only cares about the mechanisms by which the protocol parameters are changed.
\end{itemize}

\subsection{Update proposals}
\label{sec:update-proposals}

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{up} & \UpdProp & \text{update proposal}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{align*}
    & \fun{pIssuer} \in \UpdProp \to \VKey & \text{issuer of the update proposal}\\
    & \fun{pSig} \in \UpdProp \to \UpdPropBody & \text{body of the update proposal}
  \end{align*}
  \caption{Update proposals definitions}
  \label{fig:defs:update-proposals}
\end{figure}

\subsection{Information in the ledger state}
\label{sec:information-in-ledger-state}

The ledger state has to expose some parameters of the protocol version to its
clients. In the current implementation these parameters are kept in the
`BlockVersionData` structure.

\begin{lstlisting}
  data BlockVersionData = BlockVersionData { ... }
\end{lstlisting}

The following parameters are likely to be needed by the consumers of the ledger
layer:

\begin{itemize}
\item Slot duration (`bvdSlotDuration`)
\item Maximum block size (`bvdMaxBlockSize`)
\item Maximum header size (`bvdMaxHeaderSize`)
\item Maximum transaction size (`bvdMaxTxSize`)
\item Maximum proposal size (`bvdMaxProposalSize`)
\item Transaction fee policy (`bvdTxFeePolicy`)
\end{itemize}

The following parameters will be assumed to be constant:
\begin{itemize}
\item MPC threshold (`bvdMpcThd`)
\item Heavy delegation threshold (`bvdHeavyDelThd`)
\item Update vote threshold (`bvdUpdateVoteThd`)
\item Update proposal threshold (`bvdUpdateProposalThd`)
\item Soft fork rule parameters (`bvdSoftforkRule`)
\end{itemize}

At the moment we don't know whether we need these:

\begin{itemize}
\item Script Version (`bvdScriptVersion`)
\item Update implicit (`bvdUpdateImplicit`)
\end{itemize}

Finally, the `bvdUnlockStakeEpoch` field of `BlockVersionData` does not need to
be modeled.

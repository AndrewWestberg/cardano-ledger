\section{Update mechanism}
\label{sec:update}

\newcommand{\UProp}{\ensuremath{\type{UProp}}}
\newcommand{\UPropId}{\ensuremath{\type{UPropId}}}
\newcommand{\UPropBody}{\ensuremath{\type{UPropBody}}}
\newcommand{\ProtVer}{\ensuremath{\type{ProtVer}}}
\newcommand{\ProtAtt}{\ensuremath{\type{ProtAtt}}}
\newcommand{\ProtParams}{\ensuremath{\type{ProtParams}}}
\newcommand{\UPVEnv}{\ensuremath{\type{UPVEnv}}}
\newcommand{\UPVState}{\ensuremath{\type{UPVState}}}
\newcommand{\UPLEnv}{\ensuremath{\type{UPLEnv}}}
\newcommand{\UPLState}{\ensuremath{\type{UPLState}}}
\newcommand{\Vote}{\ensuremath{\type{Vote}}}
\newcommand{\VEnv}{\ensuremath{\type{VEnv}}}
\newcommand{\VState}{\ensuremath{\type{VState}}}

\newcommand{\upSize}[1]{\ensuremath{\fun{upSize}~\var{#1}}}
\newcommand{\upPV}[1]{\ensuremath{\fun{upPV}~\var{#1}}}
\newcommand{\upId}[1]{\ensuremath{\fun{upId}~\var{#1}}}
\newcommand{\upIssuer}[1]{\ensuremath{\fun{upIssuer}~\var{#1}}}
\newcommand{\upParams}[1]{\ensuremath{\fun{upParams}~\var{#1}}}
\newcommand{\vCaster}[1]{\ensuremath{\fun{vCaster}~\var{#1}}}
\newcommand{\vPropId}[1]{\ensuremath{\fun{vPropId}~\var{#1}}}
\newcommand{\vSig}[1]{\ensuremath{\fun{vSig}~\var{#1}}}

\lstset{ frame=tb,
       , language=Haskell
       , basicstyle=\footnotesize\ttfamily,
       , keywordstyle=\color{blue!80},
       , commentstyle=\itshape\color{purple!40!black},
       , identifierstyle=\bfseries\color{green!40!black},
       , stringstyle=\color{orange},
       }

\lstMakeShortInline[columns=fixed]`

\subsection{Aspects that we need to model}
\label{sec:aspects-to-model}

\begin{description}
\item[Authentication] Update proposals and votes are authenticated (properly
  signed).
\item[Authorization] Only genesis keys (via deleg certs) can post update
  proposals.
  \begin{itemize}
  \item Only then they can vote on them.
  \end{itemize}
\item[Voting deadlines] voting ends when a majority of the voters (4/7 if we
assume no stake) agree on the proposal.
\item[Block versions] (= protocol versions)
\item[Soft-forks] a protocol version changes according to the fork-resolution
  rule (75\% of stake create blocks with new-version).
\item[Hard-forks] ??? Do we need to model anything here?.
\end{description}

In particular the rules need to capture:

\begin{enumerate}
\item Each genesis key can post (either directly or via its delegate), one update proposal per-epoch.
\item When does an update proposal becomes \textbf{active}.
\item We cannot add a proposal if there exists one with the same id\footnote{id
    = hash of the update proposal} that is already active.
\item If there are two proposals submitted for the same block version, then
  these proposals need to agree on the values of the updated parameters.
\end{enumerate}

Remarks:
\begin{itemize}
\item We do not distinguish between protocol or software updates. The ledger
  only cares about the mechanisms by which the protocol parameters are changed.
\end{itemize}

\subsection{Update proposals}
\label{sec:update-proposals}

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{up} & \UProp & \text{(protocol) update proposal}\\
      \var{pa} & \ProtAtt & \text{protocol attribute}\\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \var{pv} & \ProtVer & (\var{maj}, \var{min}, \var{alt})
      & (\mathbb{N}, \mathbb{N}, \mathbb{N}) & \text{protocol version}\\
      \var{pps} & \ProtParams & \var{pps} & \ProtAtt \mapsto \Value & \text{protocol parameters}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{align*}
    & \fun{upIssuer} \in \UProp \to \VKeyGen & \text{issuer of the update proposal}\\
    & \fun{upSize} \in \UProp \to \mathbb{N} & \text{update proposal size}\\
    & \fun{upPV} \in \UProp \to \mathbb{\ProtVer} & \text{update proposal protocol version}\\
    & \fun{upID} \in \UProp \to \mathbb{\UPropId} & \text{update proposal id}
  \end{align*}
  \caption{Update proposals definitions}
  \label{fig:defs:update-proposals}
\end{figure}

\subsection{Update proposals activation}
\label{sec:update-proposals-activation}

First we model the validity of a proposal.

\begin{figure}[htb]
  \emph{Update proposals validity environments}
  \begin{equation*}
    \UPVEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pv} & \ProtVer & \text{adopted (current) protocol version}\\
        \var{pps} & \ProtParams & \text{adopted protocol parameters}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals validity states}
  \begin{equation*}
    \UPVState
    = \left(
      \begin{array}{r@{~\in~}lr}
        \var{aps} & \powerset{\UProp} & \text{active proposals}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals validity transitions}
    \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{upv}{\_} \var{\_}
    \subseteq \powerset (\UPVEnv \times \UPVState \times \UProp \times \UPVState)
  \end{equation*}
  \caption{Update proposals validity transition-system types}
  \label{fig:ts-types:up-validity}
\end{figure}

Terse explanation of Rule~\ref{eq:rule:up-validity}: a new proposal:
\begin{itemize}
\item must not exceed the maximum side, as specified by the current
  protocol parameters.
\item must not exist in the set of active proposals.
\item must have a unique version among the current active proposals. This
  implies that a proposal is uniquely determined by its block version.
\item must increase one of the components (major, minor, or alternative) of the
  current version.
\end{itemize}

\setpremisesspace{7pt}
\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-validity}
    \inference
    {
      \var{maxUpSize} \mapsto \var{mus} \in \var{pps}
      & \upSize{up} \leq \var{mus}
      & \upId{up} = \var{pid}
      & \var{pid} \notin \var{aps} \\
      \upPV{up} = \var{nv}
      & \var{nv} \notin \dom \var{vis}
      & \var{nv} = (\var{mj_n}, \var{mi_n}, \var{a_n})
      & \var{pv} = (\var{mj_p}, \var{mi_p}, \var{a_p})\\
      (\var{mj_p} + 1 = \var{mj_n} \Rightarrow \var{mi_n} = 0)
      & (\var{mj_p} = \var{mj_n} \Rightarrow \var{mi_p} + 1 = \var{mi_n})
      & (|\var{mj_n} - \var{mj_p}| \leq 1)
      & \var{pv} < \var{nv}\\
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{vis}\\
            \var{ips}
          \end{array}
        \right)
      }
      \trans{upv}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{aps \cup \{\var{pid}\}}\\
            \var{vis} \unionoverride \{ \var{nv} \mapsto \var{pid} \}\\
            \var{ips} \unionoverride \{ \var{pid} \mapsto \var{up} \}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update proposals validity rules}
  \label{fig:rules:up-validity}
\end{figure}

\clearpage

\begin{figure}[htb]
  \emph{Update proposals limits  environments}
    \begin{equation*}
    \UPLEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e} & \Epoch & \text{current epoch}\\
        \mathcal{K} & \powerset{\VKeyGen} & \text{genesis keys}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals limits states}
  \begin{equation*}
    \UPLState
    = \left(
      \begin{array}{r@{~\in~}lr}
        \var{eps} & \powerset{(\Epoch \times \VKeyGen)} & \text{proposals per-key per-epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals limits transitions}
  \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{upl}{\_} \var{\_}
    \subseteq \powerset (\UPLEnv \times \UPLState \times \UProp \times \UPLState)
  \end{equation*}
  \caption{Update proposals limits transition-system types}
  \label{fig:ts-types:up-limits}
\end{figure}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-limits}
    \inference
    {\upIssuer{up} = \var{vk}
      & \var{vk} \in \mathcal{K}
      & (e_c, \var{vk}) \notin \var{eps}
    }
    {
      {\begin{array}{l}
         \var{e_c}\\
         \mathcal{K}
       \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upl}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{eps \cup \{(e_c, \var{vk})\}}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update proposals limits rules}
  \label{fig:rules:up-limits}
\end{figure}

\begin{todo}
TODO: add witnesses as well.
\end{todo}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-activation}
    \inference
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{vis}\\
            \var{ips}
          \end{array}
        \right)
      }
      \trans{upv}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{aps'}\\
            \var{vis'}\\
            \var{ips'}
          \end{array}
        \right)
      }
      &
      {\begin{array}{l}
          \var{e_c}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upl}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{eps'}
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}\\
          \var{e_c}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{vis}\\
            \var{ips}\\
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upa}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{aps'}\\
            \var{vis'}\\
            \var{ips'}\\
            \var{eps'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update activation rules}
  \label{fig:rules:up-activation}
\end{figure}

\clearpage

\subsection{Voting on update proposals}
\label{sec:voting-on-update-proposals}

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{v} & \Vote & \text{vote on an update proposal}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  \begin{align*}
    & \fun{vCaster} \in \Vote \to \VKey & \text{caster of a vote}\\
    & \fun{vPropId} \in \Vote \to \UPropId & \text{proposal id that is being voted}\\
    & \fun{vSig} \in \Vote \to \Sig & \text{vote signature}
  \end{align*}
  \caption{Voting definitions}
  \label{fig:defs:voting}
\end{figure}

\begin{figure}[htb]
  \emph{Voting environments}
  \begin{align*}
    & \VEnv
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{aps} & \powerset{\UProp} & \text{active proposals}\\
        \var{dms} & \VKeyGen \mapsto \VKey & \text{delegation map}
      \end{array}\right)
  \end{align*}
  %
  \emph{Voting states}
  \begin{align*}
    & \VState
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{vts} & \powerset{(\VKeyGen \times \UPropId)} & \text{votes}\\
        \var{vcount} & \UPropId \mapsto \mathbb{N} & \text{vote count}
      \end{array}\right)
  \end{align*}
  %
  \emph{Voting transitions}
    \begin{equation*}
    \_ \vdash \_ \trans{vote}{\_} \_ \in
    \powerset (\VEnv \times \VState \times \Vote \times \VState)
    \end{equation*}
  \caption{Voting transition-system types}
  \label{fig:ts-types:voting}
\end{figure}

Terse explanation of Rule~\ref{eq:rule:voting}:
\begin{itemize}
\item Only genesis keys can vote on an update proposal, although votes can be
  cast by delegates of these genesis keys.
\item We count one vote per genesis key that delegated to the key that is
  casting the vote.
\item The vote must refer to an active update proposal.
  \item The proposal id must be signed by the key that is casting the vote.
\end{itemize}


\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:voting}
    \inference
    {
      \vPropId{v} = \var{pid} & \vCaster{v} = \var{vk}
      & \var{pid} \mapsto n \in \{pid \mapsto 0\} \unionoverride \var{vcount} \\
      \var{vts}_{\var{pid}} =
      \{ (\var{vk_s}, \var{pid}) \mid \var{vk_s} \mapsto \var{vk} \in \var{dms} \}
      & m = \size{\var{vts}_{\var{pid}}}\\
      \var{vts}_{\var{pid}} \cap \var{vts} = \emptyset\\
      \langle \exists \var{up} \in \var{aps} \cdot \upId{up} = \var{pid} \rangle\\
      \mathcal{V}_{\var{vk}}\serialised{\var{pid}}_{(\vSig{v})}
    }
    {
      {
        \begin{array}{l}
          \var{aps}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}\\
            \var{vcount}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts} \cup \var{vts}_{\var{pid}}\\
            \var{vcount} \unionoverride \{ \var{pid} \mapsto n + m\}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update voting rules}
  \label{fig:rules:voting}
\end{figure}

\clearpage

\subsection{Update proposals confirmation}
\label{sec:update-proposals-confirmation}

This section models when update proposals get confirmed.

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-no-confirmation}
    \inference
    {
      \vPropId{v} = \var{pid}
      & \var{pcThr} \mapsto \var{n} \in \var{pps}
      & \size{\var{vts'} \restrictrange \{\var{pid}\}} < n\\
      {
        \begin{array}{l}
          \var{aps}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts'}
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}\\
          e_c\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{cps}\\
            \var{eps}\\
            \var{vts}
          \end{array}
        \right)
      }
      \trans{upc}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{cps}\\
            \var{eps}\\
            \var{vts'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \nextdef
  \begin{equation}
    \label{eq:rule:up-confirmation}
    \inference
    {
      \vPropId{v} = \var{pid}
      & \var{pcThr} \mapsto \var{n} \in \var{pps}
      & n \leq \size{\var{vts'} \restrictrange \{\var{pid}\}} \\
      {
        \begin{array}{l}
          \var{aps}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts'}
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}\\
          e_c\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{aps}\\
            \var{cps}\\
            \var{eps}\\
            \var{vts}
          \end{array}
        \right)
      }
      \trans{upc}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{aps} \setminus \{\var{pid}\} \\
            \var{cps} \union  \{\var{pid}\} \\
            \var{eps}\\
            \var{vts'} \subtractrange \{\var{pid}\}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update-proposals confirmation rules}
  \label{fig:rules:up-confirmation}
\end{figure}

\clearpage

\subsection{Update proposals adoption}
\label{sec:update-proposals-adoption}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-adopted}
    \inference
    {
      \var{bv} = \var{pv}
      & \var{bvs'} = \var{bvs};\var{bv}
      & m = \size{bvs'} \\
    }
    {
      {
        \begin{array}{l}
          ?
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{vis}\\
            \var{ips}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{vis}\\
            \var{ips}\\
            {[m - w, ..]} \restrictdom \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  %
  \nextdef
  %
\begin{equation}
    \label{eq:rule:up-no-adoption}
    \inference
    {
      \var{bv} \neq \var{pv}
      & \var{bvs'} = \var{bvs};\var{bv} & m = \size{bvs'} \\
      \var{upAdptThr} \mapsto n \in pps  &
      \dfrac{\size{\var{bvs'} \restrictrange \{\var{bv}\}}}{\size{\var{bvs'}}} < n\\
      & \var{bvsWindowSize} \mapsto w \in pps
    }
    {
      {
        \begin{array}{l}
          ?
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{vis}\\
            \var{ips}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{vis}\\
            \var{ips}\\
            {[m - w, ..]} \restrictdom \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  %
  \nextdef
  %
  \begin{equation}
    \label{eq:rule:up-adoption}
    \inference
    {
      \var{bv} \neq \var{pv}
      & \var{bvs'} = \var{bvs};\var{bv} & m = \size{bvs'} \\
      \var{upAdptThr} \mapsto n \in pps  &
      n \leq \dfrac{\size{\var{bvs'} \restrictrange \{\var{bv}\}}}{\size{\var{bvs'}}}\\
      \var{bvsWindowSize} \mapsto w \in pps\\
      \var{bv} \mapsto \var{pid} \in \var{vis} & \var{pid} \mapsto {up} \in \var{ips}
      & \var{pid} \in \var{cps}
    }
    {
      {
        \begin{array}{l}
          ?
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{vis}\\
            \var{ips}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{bv}\\
            \upParams{up}\\
            \var{cps} \setminus \{ \var{pid} \}\\
            \{ \var{bv} \} \subtractdom \var{vis}\\
            \{ \var{pid} \} \subtractdom \var{ips}\\
            {[m - w, ..]} \restrictdom \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update-proposals adoption rules}
  \label{fig:rules:up-adoption}
\end{figure}

\subsection{Information in the ledger state}
\label{sec:information-in-ledger-state}

The ledger state has to expose some parameters of the protocol version to its
clients. In the current implementation these parameters are kept in the
`BlockVersionData` structure.

\begin{lstlisting}
  data BlockVersionData = BlockVersionData { ... }
\end{lstlisting}

The following parameters are likely to be needed by the consumers of the ledger
layer:

\begin{itemize}
\item Slot duration (`bvdSlotDuration`)
\item Maximum block size (`bvdMaxBlockSize`)
\item Maximum header size (`bvdMaxHeaderSize`)
\item Maximum transaction size (`bvdMaxTxSize`)
\item Maximum proposal size (`bvdMaxProposalSize`)
\item Transaction fee policy (`bvdTxFeePolicy`)
\end{itemize}

The following parameters will be assumed to be constant:
\begin{itemize}
\item MPC threshold (`bvdMpcThd`)
\item Heavy delegation threshold (`bvdHeavyDelThd`)
\item Update vote threshold (`bvdUpdateVoteThd`)
\item Update proposal threshold (`bvdUpdateProposalThd`)
\item Soft fork rule parameters (`bvdSoftforkRule`)
\end{itemize}

At the moment we don't know whether we need these:

\begin{itemize}
\item Script Version (`bvdScriptVersion`)
\item Update implicit (`bvdUpdateImplicit`)
\end{itemize}

Finally, the `bvdUnlockStakeEpoch` field of `BlockVersionData` does not need to
be modeled.

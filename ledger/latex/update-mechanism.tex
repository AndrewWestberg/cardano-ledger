\section{Update mechanism}
\label{sec:update}

\newcommand{\UProp}{\ensuremath{\type{UProp}}}
\newcommand{\UPropId}{\ensuremath{\type{UPropId}}}
\newcommand{\UPropBody}{\ensuremath{\type{UPropBody}}}
\newcommand{\ProtVer}{\ensuremath{\type{ProtVer}}}
\newcommand{\ProtAtt}{\ensuremath{\type{ProtAtt}}}
\newcommand{\ProtParams}{\ensuremath{\type{ProtParams}}}
\newcommand{\UPVEnv}{\ensuremath{\type{UPVEnv}}}
\newcommand{\UPVState}{\ensuremath{\type{UPVState}}}
\newcommand{\UPLEnv}{\ensuremath{\type{UPLEnv}}}
\newcommand{\UPLState}{\ensuremath{\type{UPLState}}}
\newcommand{\Vote}{\ensuremath{\type{Vote}}}
\newcommand{\VEnv}{\ensuremath{\type{VEnv}}}
\newcommand{\VState}{\ensuremath{\type{VState}}}

\newcommand{\upSize}[1]{\ensuremath{\fun{upSize}~\var{#1}}}
\newcommand{\upPV}[1]{\ensuremath{\fun{upPV}~\var{#1}}}
\newcommand{\upId}[1]{\ensuremath{\fun{upId}~\var{#1}}}
\newcommand{\upIssuer}[1]{\ensuremath{\fun{upIssuer}~\var{#1}}}
\newcommand{\upParams}[1]{\ensuremath{\fun{upParams}~\var{#1}}}
\newcommand{\vCaster}[1]{\ensuremath{\fun{vCaster}~\var{#1}}}
\newcommand{\vPropId}[1]{\ensuremath{\fun{vPropId}~\var{#1}}}
\newcommand{\vSig}[1]{\ensuremath{\fun{vSig}~\var{#1}}}

\lstset{ frame=tb,
       , language=Haskell
       , basicstyle=\footnotesize\ttfamily,
       , keywordstyle=\color{blue!80},
       , commentstyle=\itshape\color{purple!40!black},
       , identifierstyle=\bfseries\color{green!40!black},
       , stringstyle=\color{orange},
       }

\lstMakeShortInline[columns=fixed]`

\subsection{Aspects that we need to model}
\label{sec:aspects-to-model}

\begin{description}
\item[Authentication] Update proposals and votes are authenticated (properly
  signed).
\item[Authorization] Only genesis keys (via deleg certs) can post update
  proposals.
  \begin{itemize}
  \item Only then they can vote on them.
  \end{itemize}
\item[Voting deadlines] voting ends when a majority of the voters (4/7 if we
assume no stake) agree on the proposal.
\item[Block versions] (= protocol versions)
\item[Soft-forks] a protocol version changes according to the fork-resolution
  rule (75\% of stake create blocks with new-version).
\item[Hard-forks] ??? Do we need to model anything here?.
\end{description}

In particular the rules need to capture:

\begin{enumerate}
\item Each genesis key can post (either directly or via its delegate), one update proposal per-epoch.
\item When does an update proposal becomes \textbf{active}.
\item We cannot add a proposal if there exists one with the same id\footnote{id
    = hash of the update proposal} that is already active.
\item If there are two proposals submitted for the same block version, then
  these proposals need to agree on the values of the updated parameters.
\end{enumerate}

Remarks:
\begin{itemize}
\item We do not distinguish between protocol or software updates. The ledger
  only cares about the mechanisms by which the protocol parameters are changed.
\end{itemize}

\subsection{Update proposals}
\label{sec:update-proposals}

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{up} & \UProp & \text{(protocol) update proposal}\\
      \var{pa} & \ProtAtt & \text{protocol attribute}\\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \var{pv} & \ProtVer & (\var{maj}, \var{min}, \var{alt})
      & (\mathbb{N}, \mathbb{N}, \mathbb{N}) & \text{protocol version}\\
      \var{pps} & \ProtParams & \var{pps} & \ProtAtt \mapsto \Value & \text{protocol parameters}
    \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{align*}
    & \fun{upIssuer} \in \UProp \to \VKeyGen & \text{issuer of the update proposal}\\
    & \fun{upSize} \in \UProp \to \mathbb{N} & \text{update proposal size}\\
    & \fun{upPV} \in \UProp \to \mathbb{\ProtVer} & \text{update proposal protocol version}\\
    & \fun{upID} \in \UProp \to \mathbb{\UPropId} & \text{update proposal id}
  \end{align*}
  \caption{Update proposals definitions}
  \label{fig:defs:update-proposals}
\end{figure}

\subsection{Update proposals activation}
\label{sec:update-proposals-activation}

First we model the validity of a proposal.

\begin{figure}[htb]
  \emph{Update proposals validity environments}
  \begin{equation*}
    \UPVEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pv} & \ProtVer & \text{adopted (current) protocol version}\\
        \var{pps} & \ProtParams & \text{adopted protocol parameters}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals validity states}
  \begin{equation*}
    \UPVState
    = \left(
      \begin{array}{r@{~\in~}lr}
        \var{rups} & \powerset{\UPropId \mapsto (\ProtVer \times \ProtParams)}
        & \text{registered update proposals}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals validity transitions}
    \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{upv}{\_} \var{\_}
    \subseteq \powerset (\UPVEnv \times \UPVState \times \UProp \times \UPVState)
  \end{equation*}
  \caption{Update proposals validity transition-system types}
  \label{fig:ts-types:up-validity}
\end{figure}

Terse explanation of Rule~\ref{eq:rule:up-validity}: a new proposal:
\begin{itemize}
\item must not exceed the maximum side, as specified by the current
  protocol parameters.
\item must not exist in the set of active proposals.
\item must have a unique version among the current active proposals. This
  implies that a proposal is uniquely determined by the protocol version it
  proposes.
\item must increase one of the (major, minor, or alternative) of the
  current version in a consistent manner:
  \begin{itemize}
  \item The proposed version must be lexicographically bigger than the current
    version.
  \item The major versions of the proposed and current version must differ in
    at most one.
  \item If the proposed major version is equal to the current major
    version, then the proposed minor version must be incremented by one.
  \item If the proposed major version is larger than the current major, then
    the proposed minor version must be zero.
  \end{itemize}
\end{itemize}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:func:can-follow}
    \begin{array}{r c l}
      \fun{canFollow}~(\var{mj_n}, \var{mi_n}, \var{a_n})~(\var{mj_p}, \var{mi_p}, \var{a_p})
      & = & (\var{mj_p}, \var{mi_p}, \var{a_p}) < (\var{mj_n}, \var{mi_n}, \var{a_n})\\
      & \wedge & (|\var{mj_n} - \var{mj_p}| \leq 1\\
      & \wedge & (\var{mj_p} = \var{mj_n} \Rightarrow \var{mi_p} + 1 = \var{mi_n}))\\
      & \wedge & (\var{mj_p} + 1 = \var{mj_n} \Rightarrow \var{mi_n} = 0)
    \end{array}
  \end{equation}
  \caption{Update validity functions}
\end{figure}

\setpremisesspace{15pt}
\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-validity}
    \inference
    {
      {\begin{array}{l l}
        \var{maxUpSize} \mapsto \var{mus} \in \var{pps}
        & \upSize{up} \leq \var{mus}\\
        \upId{up} = \var{pid}
        & \var{pid} \notin \dom \var{rups} \\
        \upPV{up} = \var{nv}
        & \var{nv} \notin \dom (\range \var{rups})\\
       \end{array}}\\
     \fun{canFollow}~\var{nv}~\var{pv}
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}
          \end{array}
        \right)
      }
      \trans{upv}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{rups} \unionoverride \{ \var{pid} \mapsto (\var{nv}, \upPV{up}) \}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update proposals validity rules}
  \label{fig:rules:up-validity}
\end{figure}

\clearpage

\begin{figure}[htb]
  \emph{Update proposals limits  environments}
    \begin{equation*}
    \UPLEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e} & \Epoch & \text{current epoch}\\
        \mathcal{K} & \powerset{\VKeyGen} & \text{genesis keys}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals limits states}
  \begin{equation*}
    \UPLState
    = \left(
      \begin{array}{r@{~\in~}lr}
        \var{eps} & \powerset{(\Epoch \times \VKeyGen)} & \text{proposals per-key per-epoch}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Update proposals limits transitions}
  \begin{equation*}
    \var{\_} \vdash
    \var{\_} \trans{upl}{\_} \var{\_}
    \subseteq \powerset (\UPLEnv \times \UPLState \times \UProp \times \UPLState)
  \end{equation*}
  \caption{Update proposals limits transition-system types}
  \label{fig:ts-types:up-limits}
\end{figure}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-limits}
    \inference
    {\upIssuer{up} = \var{vk}
      & \var{vk} \in \mathcal{K}
      & (e_c, \var{vk}) \notin \var{eps}
    }
    {
      {\begin{array}{l}
         \var{e_c}\\
         \mathcal{K}
       \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upl}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{eps \cup \{(e_c, \var{vk})\}}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update proposals limits rules}
  \label{fig:rules:up-limits}
\end{figure}

\begin{todo}
TODO: add witnesses as well.
\end{todo}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-activation}
    \inference
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
          \end{array}
        \right)
      }
      \trans{upv}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{rups'}\\
          \end{array}
        \right)
      }
      &
      {\begin{array}{l}
          \var{e_c}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upl}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{eps'}
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          \var{pv}\\
          \var{pps}\\
          \var{e_c}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
            \var{eps}
          \end{array}
        \right)
      }
      \trans{upa}{\var{up}}
      {
        \left(
          \begin{array}{l}
            \var{rups'}\\
            \var{eps'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update activation rules}
  \label{fig:rules:up-activation}
\end{figure}

\clearpage

\subsection{Voting on update proposals}
\label{sec:voting-on-update-proposals}

\begin{figure}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{v} & \Vote & \text{vote on an update proposal}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  \begin{align*}
    & \fun{vCaster} \in \Vote \to \VKey & \text{caster of a vote}\\
    & \fun{vPropId} \in \Vote \to \UPropId & \text{proposal id that is being voted}\\
    & \fun{vSig} \in \Vote \to \Sig & \text{vote signature}
  \end{align*}
  \caption{Voting definitions}
  \label{fig:defs:voting}
\end{figure}

\begin{figure}[htb]
  \emph{Voting environments}
  \begin{align*}
    & \VEnv
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{rups} & \powerset{\UPropId \mapsto (\ProtVer \times \ProtParams)}
        & \text{registered update proposals}\\
        \var{dms} & \VKeyGen \mapsto \VKey & \text{delegation map}
      \end{array}\right)
  \end{align*}
  %
  \emph{Voting states}
  \begin{align*}
    & \VState
      = \left(
      \begin{array}{r@{~\in~}lr}
        \var{vts} & \powerset{(\UPropId \times \VKeyGen)} & \text{votes}
      \end{array}\right)
  \end{align*}
  %
  \emph{Voting transitions}
    \begin{equation*}
    \_ \vdash \_ \trans{vote}{\_} \_ \in
    \powerset (\VEnv \times \VState \times \Vote \times \VState)
    \end{equation*}
  \caption{Voting transition-system types}
  \label{fig:ts-types:voting}
\end{figure}

Terse explanation of Rule~\ref{eq:rule:voting}:
\begin{itemize}
\item Only genesis keys can vote on an update proposal, although votes can be
  cast by delegates of these genesis keys.
\item We count one vote per genesis key that delegated to the key that is
  casting the vote.
\item The vote must refer to an active update proposal.
\item The proposal id must be signed by the key that is casting the vote.
\item It might be possible for the same genesis key to vote multiple times for
  the same proposal, however this vote will be counted once (note that we're
  taking the union of the key-proposal-id pairs).
\end{itemize}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:voting}
    \inference
    {
      \vPropId{v} = \var{pid} &  \vCaster{v} = \var{vk} &
      \var{vts}_{\var{pid}} =
      \{ (\var{pid}, \var{vk_s}) \mid \var{vk_s} \mapsto \var{vk} \in \var{dms} \}\\
      & \var{pid} \in \dom \var{rups} &
      \mathcal{V}_{\var{vk}}\serialised{\var{pid}}_{(\vSig{v})}\\
    }
    {
      {
        \begin{array}{l}
          \var{rups}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts} \cup \var{vts}_{\var{pid}}\\
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update voting rules}
  \label{fig:rules:voting}
\end{figure}

\clearpage

\subsection{Update proposals confirmation}
\label{sec:update-proposals-confirmation}

This section models when update proposals get confirmed.

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:up-no-confirmation}
    \inference
    {
      {
        \begin{array}{l}
          \var{rups}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts'}
          \end{array}
        \right)
      }\\
      \vPropId{v} = \var{pid}
      & \var{pcThr} \mapsto t \in \var{pps}
      & \size{\{\var{pid}\} \restrictdom \var{vts'}} < t
    }
    {
      {
        \begin{array}{l}
          b_n\\
          \var{pps}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
            \var{cps}\\
            \var{vts}
          \end{array}
        \right)
      }
      \trans{upc}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
            \var{cps}\\
            \var{vts'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \nextdef
  \begin{equation}
    \label{eq:rule:up-confirmation}
    \inference
    {
      {
        \begin{array}{l}
          \var{rups}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{vts}
          \end{array}
        \right)
      }
      \trans{vote}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \var{vts'}
          \end{array}
        \right)
      }\\
      \vPropId{v} = \var{pid}
      & \var{pcThr} \mapsto t \in \var{pps}
      & t \leq \size{\{\var{pid}\} \restrictdom \var{vts'}}
    }
    {
      {
        \begin{array}{l}
          \var{b_n}\\
          \var{pps}\\
          \var{dms}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{rups}\\
            \var{cps}\\
            \var{vts}
          \end{array}
        \right)
      }
      \trans{upc}{\var{v}}
      {
        \left(
          \begin{array}{l}
            \{\var{pid}\} \subtractdom \var{rups} \\
            \var{cps} \unionoverride  \{\var{pid} \mapsto b_n\} \\
            \{\var{pid}\} \subtractdom \var{vts'} 
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update-proposals confirmation rules}
  \label{fig:rules:up-confirmation}
\end{figure}

\clearpage

\subsection{Update proposals adoption}
\label{sec:update-proposals-adoption}

\begin{equation}
  \label{eq:predicate:adopt}
  \begin{array}{r c l}
    \fun{canAdopt}~\var{pps}~\var{bvs}~\var{bv}
    & =
    & \var{upAdptThr} \mapsto t \in pps\\
    & \wedge
    & t \leq \dfrac{\size{\var{bvs} \restrictrange \{\var{bv}\}}}{\size{\var{bvs}}}\\
  \end{array}
\end{equation}

\begin{figure}[htb]
  \begin{equation}
    \label{eq:rule:snocbv}
    \inference
    {
      \var{bvs'} = \var{bvs};\var{bv} & m = \size{bvs'}
      & \var{bvsWinSize} \mapsto w \in \var{pps}
    }
    {
      {
        \begin{array}{l}
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            bvs
          \end{array}
        \right)
      }
      \trans{snocbv}{bv}
      {
        \left(
          \begin{array}{l}
            {[m - w, ..]} \restrictdom \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  %
  \nextdef
  %
  \begin{equation}
    \label{eq:rule:up-adopted}
    \inference
    {
      \var{bv} = \var{pv}
      &
      {
        \begin{array}{l}
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            bvs
          \end{array}
        \right)
      }
      \trans{snocbv}{bv}
      {
        \left(
          \begin{array}{l}
            bvs'
          \end{array}
        \right)
      }
    }
    {
      {
        \begin{array}{l}
          k\\
          b_n
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{rups}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{rups}\\
            \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  %
  \nextdef
  %
  \begin{equation}
    \label{eq:rule:up-no-adoption}
    \inference
    {
      \var{bv} \neq \var{pv}
      &
      {
        \begin{array}{l}
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            bvs
          \end{array}
        \right)
      }
      \trans{snocbv}{bv}
      {
        \left(
          \begin{array}{l}
            bvs'
          \end{array}
        \right)
      }
      & \neg (\fun{canAdopt}~\var{pps}~\var{bvs'}~\var{bv})\\
      \var{pid} \mapsto (\var{bv}, \wcard) \in \var{rups}
      & \var{pid} \in \dom~(\var{cps} \restrictrange [.., b_n - k])
    }
    {
      {
        \begin{array}{l}
          k\\
          b_n
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{rups}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{rups}\\
            \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  %
  \nextdef
  %
  \begin{equation}
    \label{eq:rule:up-adoption}
    \inference
    {
      \var{bv} \neq \var{pv}
      &
            {
        \begin{array}{l}
          \var{pps}
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            bvs
          \end{array}
        \right)
      }
      \trans{snocbv}{bv}
      {
        \left(
          \begin{array}{l}
            bvs'
          \end{array}
        \right)
      }
      &
      \fun{canAdopt}~\var{pps}~\var{bvs'}~\var{bv}\\
      \var{pid} \mapsto (\var{bv}, \var{pps'}) \in \var{rups}
      & \var{pid} \in \dom~(\var{cps} \restrictrange [.., b_n - k])\\
    }
    {
      {
        \begin{array}{l}
          k\\
          b_n
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{l}
            \var{pv}\\
            \var{pps}\\
            \var{cps}\\
            \var{rups}\\
            \var{bvs}
          \end{array}
        \right)
      }
      \trans{upadopt}{\var{bv}}
      {
        \left(
          \begin{array}{l}
            \var{bv}\\
            \var{pps'}\\
            \{ \var{pid} \} \subtractdom \var{cps} \\
            \{ \var{pid} \} \subtractdom \var{rups}\\
            \var{bvs'}
          \end{array}
        \right)
      }
    }
  \end{equation}
  \caption{Update-proposals adoption rules}
  \label{fig:rules:up-adoption}
\end{figure}

\subsection{Deviations from the actual implementation}
\label{sec:deviation-actual-impl}

The current specification of the voting mechanism deviates from the actual
implementation, although it should be backwards compatible the latter. These
deviations are required to simplify the voting and update mechanism removing
unnecessary features and reducing accidental complexity. The following
subsections highlight the differences between the this specification and the
current implementation.

\subsubsection{Positive votes}
\label{sec:only-positive-votes}

Votes are only positive. Genesis keys can only vote positively for an update
proposal. In the current implementation stakeholders can vote for or against a
proposal, which makes the voting logic more complex:
\begin{itemize}
\item there are more cases to consider
\item the current voting validation rules allow voters to change their minds
  (by flipping their vote) at most once, which requires to keep track how a
  stake holder voted and how many times. Contrast this with
  Rule~\ref{eq:rule:voting} where we only need to keep track of the set of
  key-proposal-id's pairs.
\end{itemize}

\subsubsection{Alternative version numbers}
\label{sec:alt-version-numbers-constraints}

Alternative version numbers are only lexicographically constrained. The current
implementation seems to be dependent on the order in which the update proposals
arrive: given a new update proposal $\var{up}$, if a set $X$ of update
proposals with the same minor and major versions than $\var{up}$ exist, then
the alternative version of $\var{up}$ has to be one more than the maximum
alternative number of $X$. Not only this logic seems to be brittle since it
depends on the order of arrival of the update proposals, but it requires a more
complex check (which depends on state) to determine if a proposed version is
consistent. By being more lenient on the alternative versions of update
proposals we can simplify the version checking logic considerably.

\subsubsection{Update proposal adoption}
\label{sec:up-adoption}


\subsection{Information in the ledger state}
\label{sec:information-in-ledger-state}

The ledger state has to expose some parameters of the protocol version to its
clients. In the current implementation these parameters are kept in the
`BlockVersionData` structure.

\begin{lstlisting}
  data BlockVersionData = BlockVersionData { ... }
\end{lstlisting}

The following parameters are likely to be needed by the consumers of the ledger
layer:

\begin{itemize}
\item Slot duration (`bvdSlotDuration`)
\item Maximum block size (`bvdMaxBlockSize`)
\item Maximum header size (`bvdMaxHeaderSize`)
\item Maximum transaction size (`bvdMaxTxSize`)
\item Maximum proposal size (`bvdMaxProposalSize`)
\item Transaction fee policy (`bvdTxFeePolicy`)
\end{itemize}

The following parameters will be assumed to be constant:
\begin{itemize}
\item MPC threshold (`bvdMpcThd`)
\item Heavy delegation threshold (`bvdHeavyDelThd`)
\item Update vote threshold (`bvdUpdateVoteThd`)
\item Update proposal threshold (`bvdUpdateProposalThd`)
\item Soft fork rule parameters (`bvdSoftforkRule`)
\end{itemize}

At the moment we don't know whether we need these:

\begin{itemize}
\item Script Version (`bvdScriptVersion`)
\item Update implicit (`bvdUpdateImplicit`)
\end{itemize}

Finally, the `bvdUnlockStakeEpoch` field of `BlockVersionData` does not need to
be modeled.

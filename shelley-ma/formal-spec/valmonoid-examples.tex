\section{Other Token algebra Examples}
\label{sec:other-valmonoids}

We give examples here of Token algebras
that are similar to $\Value$ asset bundles in spirit, and are used elsewhere
in the system (eg. the wallet) or are otherwise relevant.

\subsection{No Special Case for Ada}

In an original paper about native multi-asset representation in a UTxO ledger
(see \cite{utxo_ma}), the asset bundle definition avoids all special cases, treating
all assets in a uniform way.
While it does not define any special cases of definitions of its multi-assets at the type-level,
it does not prohibit the possibility of customizing the ledger rules to introduce
some special treatment of any specific asset if needed.

In Figure \ref{fig:no-special-ada}, we give the Token algebra structure for
the $\Value'$ type, which has no special case for Ada. That is, the policy ID and
asset name for it are chosen to be of the corresponding types,
$\PolicyID$ and $\AssetName$. This means
that Ada indeed has a checkable minting policy with ID $\mathsf{AdaPolicyID}$.
Such a policy must be specified in
order to implement this version of asset bundles, but we leave it abstract here.
Ada could potentially have several asset names scoped under this policy, although
practically this would not line up with the current ledger conception of Ada.
We call Ada's asset name $\mathsf{AdaName}$, and leave it unspecified here.

\begin{figure*}[t!]
  \emph{Constants}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{~}lr}
      \mathsf{AdaPolicyID} & \PolicyID & \text{Policy ID of Ada} \\
      \mathsf{AdaName} & \AssetName & \text{Asset name of Ada}
    \end{array}
  \end{equation*}
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{v}, \var{w} & \Value'
      & \PolicyID \mapsto_0 ( \AssetName \mapsto_0 \Quantity )
    \end{array}
  \end{equation*}
  %
  \emph{The Token algebra structure of $\Value'$}
  %
  \begin{align*}
    & \fun{coin}~v = v~\mathsf{AdaPolicyID}~\mathsf{AdaName}
    \nextdef
    %
    & \fun{inject}~c  = \mathsf{AdaPolicyID} \mapsto_0 (\mathsf{AdaName} \mapsto_0 c)
    \nextdef
    %
    & \fun{policies}~v = \supp v
    \nextdef
    %
    & \fun{size} ~~~ \text{see Section \ref{sec:value-size}}
  \end{align*}
  \caption{$\Value'$ and its Token algebra structure}
  \label{fig:no-special-ada}
\end{figure*}


\subsection{Special Case Ada Representation}
\label{sec:coin-value}

The $\Value_C$ type and the associated functions, shown in Figure \ref{fig:special-ada},
give a Token algebra which is isomorphic to the $\Value$ we defined in
Section \ref{sec:coin-ma}. Both constructs
specify all non-Ada assets via the unique identifier $(\PolicyID \times \AssetName)$, and
have a special case for Ada. Neither asset bundle definition
admits a minting policy or an asset name for Ada.

The isomorphism between the two types is given in Figure \ref{fig:iso-v}.
All Token algebra operations on the $\Value$ and $\Value_C$ types commute with this
isomorphism.

\begin{figure*}[t!]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{v}, \var{w} & \Value_C
      & \Coin \times \PolicyID \mapsto_0 ( \AssetName \mapsto_0 \Quantity )
    \end{array}
  \end{equation*}
  %
  \emph{The Token algebra structure of $\Value_C$}
  %
  \begin{align*}
    & \fun{coin}~(\var{c}, \wcard) = \var{c}
    \nextdef
    %
    & \fun{inject}~c  = (c, \Nothing)
    \nextdef
    %
    & \fun{policies}~(c,~v) = \supp{~v}
    \nextdef
    %
    & \fun{size} ~~~ \text{see Section \ref{sec:value-size}}
  \end{align*}
  \caption{$\Value_C$ and its Token algebra structure}
  \label{fig:special-ada}
\end{figure*}

\begin{figure*}[t!]
  \begin{align*}
    & \fun{iso_v} \in \Value \to \Value_C \\
    & \fun{iso_v}~v =(\var{v}~\mathsf{AdaID},~\{~\var{pid}\mapsto_0(\var{aname}\mapsto_0\var{q})~
    \vert~(\var{pid},~\var{aname})\in\fun{dom}~{v}~\})
    \nextdef
    %
    & \fun{iso}_{vc} \in \Value_C \to \Value \\
    & \fun{iso}_{vc}~(c, ~v) = \{~\mathsf{AdaID}\mapsto_0c~\}\cup
     \{~(\var{pid},~\var{aname})\mapsto_0q~\vert~\var{pid}\mapsto_0(\var{aname}\mapsto_0q)~ \in \var{v}~\}
  \end{align*}
  \caption{Isomorphism maps between the $\Value$ and $\Value_C$ types}
  \label{fig:iso-v}
\end{figure*}

\subsection{$\mathsf{CompactValue}$ representation}
The type $\mathsf{CompactValue}$ is a compressed representation of $\Value_C$,
which we do not give the implementation details of this compression here.
This representation of multi-assets is isomorphic to $\Value$ and $\Value_C$
and is used in the implementation to save memory. Its Token algebra structure
is defined via a bijection between it and $\Value_C$,
so that they first require de-compression to be performed, as well as compression
as the final step in the cases the output type contains $\mathsf{CompactValue}$.

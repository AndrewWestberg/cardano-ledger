\documentclass[11pt,a4paper,dvipsnames,twosided]{article}

\usepackage{amsmath}
\usepackage[unicode=true,pdftex,pdfa,colorlinks=true]{hyperref}
\usepackage{xcolor}
\usepackage{todonotes}

\newcommand\pbar{\overline{p}}

\begin{document}

\title{Stake Pool Ranking in Cardano}

\author{Alexander Byaly  \\ {\small \texttt{alexander.byaly@iohk.io}} \\
   \and Jared Corduan  \\ {\small \texttt{jared.corduan@iohk.io}}}

%\date{}

\hypersetup{
  pdftitle={Stake Pool Ranking in Cardano},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}

\setlength{\parindent}{0pt}
\setlength{\parskip}{12pt plus 3pt minus 2pt}

\maketitle

\section{Introduction}

The purpose of the stake pool ranking algorithm is to provide a systematic and unique ordering for stake pools,
based on the expected long-term rewards that each stake pool will produce.
The pool ranking is provided to users (wallets, people who own ADA, etc.), and can be used as a single
metric to guide delegation decisions.  The ranking is partly based on the past performance of each pool, but
also takes into account current levels of delegation etc.  It should thus be a useful predictor of future performance.


An obvious, but na\"{i}ve, approach to the ranking problem would order pools based on the rewards that are
currently being paid out to their delegators.  There are, however, a number of problems with this approach.

\begin{enumerate}
  \item
  The na\"{i}ve approach is \emph{short-sighted}, in the sense that it does not take into
  account the rewards that a newly formed stake pool would yield when it reaches saturation (\cite{bkks2018} describes this in detail).
  The specific relationship to the Cardano design is explained in the IOHK delegation design document \cite[Section 5.6]{delegation_design}.
  \item
    A stake pool will sometimes have the opportunity to produce blocks,
    but fails to do so due to issues such as a poor network connection or untimely downtime. The rate at
    which a pool uses their opportunities to make blocks, which we will call its \emph{hit rate}, affects rewards.
    It needs to be taken into account.
  \item
    The na\"{i}ve approach only considers a single set of rewards.  Delegating on this basis would create significant
    instability in the system, with delegators pursuing short-term rewards over the long-term health of the network.
    In order to avoid this issue and so create more stability, it is necessary to consider a pool's historic performance, rather than considering only a single set of rewards.
    This introduces some \emph{hysteris} into the system.
\end{enumerate}

Our aim with the pool ranking algorithm is to address all these concerns.

\begin{comment}
  Is this a new proposal, or just a description of the current status quo?
\end{comment}

\section{Hit Rate}

As described above, the \emph{hit rate} for some time period $T$ is the ratio of expected to actual blocks
that the pool produces during that time period.

$$
\begin{array}{l}
  \begin{array}{lclp{3in}}
    Hit~Rate_T &=& B_{Actual,T} / B_{Expected,T} \\
  ~~ \textit{where} \\
  \end{array}
\\
~~~~
  \begin{array}{lcp{3in}}
      B_{Actual,T} &=& \text{The actual number of blocks that a pool}\\
      && \text{has produced in time T}\\
      B_{Expected,T} &=& \text{The actual number of blocks that a pool}\\
      && \text{was expected to produce in time T}
  \end{array}
\end{array}
$$

Note that the pool operator is the only one who knows the \emph{actual} pool
\emph{hit rate}, since only they have access to their internal VRF calculation.
Other actors can only estimate it using public knowledge of the
pool's relative stake and the number of blocks that it has produced.

\subsection{Hit Rate Estimation}

Each slot, a stake pool with relative (active) stake $\sigma_a$ has probability
\[ 1 - (1-f)^{\sigma_a} \]
of producing a block, where $f$ is the active slot coefficient.
We can use this to estimate the hit rate.
%
We represent such an estimate as a probability distribution on the interval $[0,1]$.\todo{Are you assuming a Gaussian distribution?}

After each epoch, we refine our estimate into a more accurate one as follows.
%
Assume that we can
observe all the blocks that a stake pool produces during an epoch, that we have a previous estimate of the blocks that
we expected to produce during this epoch, $w$; we know that the
epoch has a total of $E$ slots; the pool produces $n$ blocks; and we calculate that on a given slot
the chance that the pool is allowed to produce a block is $t$.
%
The \emph{likelihood function}, $L$, is then shown below, where $L(x)$ is the probability of producing exactly $n$ blocks,
and $S(x)$ is the probability that the pool produces a block at a given slot, under the assumption that the
\emph{hit rate}, $p$, is equal to $x$.

\[ L(x) = \left( E \atop n \right) S(x)^{n} (1-S(x))^{E - n}, \]

\[
\begin{array}{r@{=}l}
S(x) & P( \text{made block} | p = x) \\
     & t \cdot P( \text{made block} | p = x,~b) + (1-t) \cdot P( \text{made block} | p = x,~\not~b) \\
%     & t \cdot P( \text{made block} | p = x,~\text{can}) + (1-t) \cdot P( \text{made block} | p = x,~\text{can't}) \\
     & tx                              + (1-t) \cdot 0 \\
     & tx \\
\\
b    & \text{can make a block}
\end{array}
\]

Our refined hit rate estimate is then $q(x) = \frac{w(x)L(x)}{\int w(x)L(x)}$.

\todo{Needs a better explanation. The equation implies that $L = \mathcal{L}$}
In order to obtain an actual ranking, we maintain a running product, $\mathcal{L}$, of the likelihood function, $L$.
We apply this to some initial \emph{prior distribution}
of block production, where % , we can defer the full computation  until we need to use it.
% When a user wishes to produce a ranking, they will
% supply a \emph{prior distribution} of block production that can be plugged in to this function.
the prior distribution is a default hit rate estimate that is applied to pools for which we don't have any historical data.
%
To construct the rankings, we then use the \emph{posterior distribution}, $q(x)$,

\begin{equation}
\label{post}
q(x) = \frac{w_(x)\mathcal{L}(x)}{\int w(x)\mathcal{L}(x)}.
\end{equation}

\subsection{Implementation}

We approximate a \emph{probability density function}, $g$, using a sequence of sample points,

\[ A(g) = \big(\ln(g(0.005)),~ \ln(g(0.015)),~ \ldots,~ \ln(g(0.995))\big). \]

This allows us to use multiplication rather than exponentiation for most of our calculations.

Because of the normalization step in Equation \eqref{post}, any scalar multiple of $g$
will ultimately yield the same result. It follows that any constant shift of $A(g)$ will also yield the same result.
In order to reduce the magnitude of the numbers that we are dealing with, we therefore use the logarithmic normal form\todo{Are there any tradeoffs?  Eg computational cost of logs?}

\[ A'(g) = \big(\ln(g(0.005)) - m,~ \ln(g(0.015)) - m,~ \ldots,~ \ln(g(0.995)) - m\big), \]
where $\ln$ is the \emph{natural logarithm} and $m$ is the minimal sample point. We use $g_i$ to denote the $i$'th term of $A'(g)$.
\todo{This needs clarification.  What previous sum?  What is converted?}
For each stake pool, we compute this approximation every epoch, add it to the previous sum, and convert it to this normal form

To calculate the final probability distribution function that we need for pool ranking, we approximate Equation \eqref{post}.
If $\mathcal{L}$ is our cumulative likelihood\todo{Inconsistent use of $\mathcal{L}$, $S$ and $q$} and $w$ is our prior distribution, we use

\[ q_i = e^{w_i + \mathcal{L}_i} / S, \]
where
\[ S = \sum (0.01) e^{w_i + \mathcal{L}_i}. \]

\todo{Let's not use $k$ :)}
In the ranking calculation, we use the $j$'th percentile of this distribution for some $j$.
We do so by computing the minimal $i$ such that the sum of $[q_0,~\ldots,q_i]$ is at least $j$.
Then $i/100$ is the $j$'th percentile.

Putting it all together, given some prior distribution, $w$, a percentile, $j$, and a cumulative likelihood, $\mathcal{L}$,
we estimate the hit rate to be $i/100$.


\subsection{Example}

Assume that Alice's pool has been active for two epochs,
there are 432,000 slots per epoch, and the active slot coefficient is 0.05
(these are the mainnet values at the time of writing).
\begin{itemize}
\item
  During the first epoch (epoch 1), the relative stake was $0.001$ and 10 blocks were produced.
\item
  During the second epoch (epoch 2), the relative stake was $0.01$ and 200 blocks were produced.
\end{itemize}
We calculate $\ln(L_1(x))$ for the first epoch as follows.
%
With relative stake $0.001$, the probability of being allowed to produce a block on
each slot is $t_1 = 1-(1-0.05)^{0.001},$ and $S_1(x)= t_1x$.
Since 10 blocks were produced, the real likelihood function is

\[ L_1(x) =  \left( 432,000 \atop 10 \right) (t_1x)^{10} (1-t_1x)^{431,990} \]

and we will use
\[
\begin{array}{rl}
  \ell_1(x) &= \ln\left( (t_1x)^{10} (t_1x)^{431,990} \right) \\
            &= 10 \ln(t_1 x) + 431,990 \ln(1 - t_1 x) \\
\end{array}
\]
to record information about Alice's pool's performance this epoch.
In particular, we record

\[ A'(L_1) = [\ell_1(0.005)-m_1,~\ell_1(0.015)-m_1,~\ldots,~\ell_1(.995)-m_1] \]
where $m_1=\min\{\ell_1(0.005),\ldots,\ell_1(0.995)\}$

For the second epoch,
\[
\begin{array}{rl}
  t_2 &= 1-(1-0.05)^{0.01} \\
  \ell_2(x) &= 200 \ln(t_2 x) + 431,800 \ln(1 - t_2 x).\\
\end{array}
\]
Then for the second epoch we store:
\[ A'(L_2) = [\ell_2(0.005)+\ell_1(0.005)-m_2,~\ldots,~\ell_2(.995)+\ell_1(.995)-m_2] \]
where $m_2=\min\{\ell_2(0.005)+\ell_1(0.005),\ldots,\ell_2(0.995)+\ell_1(0.995)\}$.

\section{Ranking and Saturation}

\todo{Explain the assumptions.  Not saturated, for example.}
We now describe how the hit rate estimation can be used to calculate the stake pool ranking,
as described in \cite{bkks2018} and \cite[Section 5.6]{delegation_design}.
First we must turn the sampling of the likelihood functions into a concrete value.
Given a percentage, $z$, we will calculate the $z$'th percentile\footnote{At present we use the 10th percentile (i.e. $z=10\%$), but we ultimately aim for this to be user configurable.}.
For a given stake pool $P$, let $h_z$ denote the $z$'th percentile.
%
Following \cite[Section 5.6.1]{delegation_design},
we can then compute the stake pool's rewards when it reaches \emph{saturation} (it has the optimal level of stake) using:
\[
    \tilde{f}(s, \pbar) :=
    \hat{f}(s,z_0,\pbar)=
    \frac{\pbar R}{1 + a_0}
    \cdot
    \left(z_0 + \min(s,z_0)\cdot a_0\right).
\]

where $\bar{p}$ is the \textit{apparent performance} of the stake pool, as defined in
\cite[Section 5.5.2]{delegation_design}.
We will substitute our estimate of the hit rate, $h_z$, for the apparent performance, $\bar{p}$,
Given a pool, $P$ with pledged owner stake \(s\), costs \(c\) and margin \(m\),
the \emph{desirability} function of \cite[Section 5.6.1]{delegation_design} becomes:
\[
    d(c, m, s, h_z) :=
    \left\{
    \begin{array}{ll}
        \displaystyle 0 &
        \text{if $\tilde{f}(s,h_z)\leq c$,} \\
        \displaystyle\left(\tilde{f}(s,h_z) - c\right)\cdot(1-m) &
        \text{otherwise.}
    \end{array}
    \right.
\]
From here, we proceed exactly as in
\cite[Section 5.6.2]{delegation_design} and
\cite[Section 5.6.4]{delegation_design}.

The \emph{desirability function}~\cite{...} can be used to provide an overall ranking over stake pools, ordering the
pools in terms of their \emph{non-myopic rewards} for some stake.
For a stake pool with pledged owner stake $s$, total stake $\sigma$, rank
$r$ and apparent performance $\pbar$, we define its \emph{non-myopic stake} $\sigma_\mathrm{nm}$ as:
\[
    \sigma_\mathrm{nm}(s,\sigma,r) :=
    \left\{
    \begin{array}{ll}
        \max(\sigma,z_0) &
        \text{if $r\leq k$,} \\
        s &
        \text{otherwise,}
    \end{array}
    \right.
\]
where $k$ is the parameter that is defined in \cite[Section 5.2]{delegation_design},
and which represents the desired number of stake pools in an equilibrium state.
%
The \emph{non-myopic pool member rewards}
% of a pool with costs $c$, margin $m$,
% pledged owner stake $s$, stake $\sigma$, rank $r$,
for a member that contributes member stake $t$, are then:
\[
    r_\mathrm{member, nm}(c, m, s, \sigma, t, r, \pbar) :=
    r_\mathrm{member}\Bigl(\hat{f}\bigl(s,\sigma_\mathrm{nm}(s,\sigma, r),
    \pbar\bigr),
    c, m, t, \sigma_\mathrm{nm}(s,\sigma,r)\Bigr),
\label{eq:non-myopic-member-rewards}
\]
where
\[
    r_\mathrm{member}(\hat{f}, c, m, t, \sigma) :=
    \left\{
    \begin{array}{ll}
        \displaystyle 0 &
        \text{if $\hat{f}\leq c$,} \\
        \displaystyle (\hat{f} - c)\cdot(1-m)\cdot\frac{t}{\sigma} &
        \text{otherwise.}
    \end{array}
    \right.
\]
Delegators can use $r_\mathrm{member, nm}$ to select a pool
that maximizes their rewards.

\section{Haskell Source Code}

\begin{comment}
  Include the Haskell source code here.
\end{comment}

\begin{comment}
  Check for missing references.
\end{comment}

\addcontentsline{toc}{section}{References}
\bibliographystyle{habbrv}
\bibliography{references}

\end{document}

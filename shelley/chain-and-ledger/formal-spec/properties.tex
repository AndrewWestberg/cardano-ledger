
\newcommand{\Val}{\fun{Val}}
\newcommand{\POV}[1]{\ensuremath{\mathsf{PresOfVal}(\mathsf{#1})}}
\newcommand{\DBE}[2]{\ensuremath{\mathsf{DBE}({#1},~{#2})}}
\newcommand{\DGO}[2]{\ensuremath{\mathsf{DGO}({#1},~{#2})}}
\renewcommand{\ledgerState}{\LState}

\section{Properties}
\label{sec:properties}
\label{sec:ledger-properties}

This section describes the most important properties that the ledger should have. The goal is to
to assure these properties for the executable specification through e.g.
property-based testing or formal verification.  This list is non-exhaustive, and may be updated
in line with need.

\subsection{Validity of a Ledger State}
\label{sec:valid-ledg-state}

Many properties only make sense when applied to a valid ledger state. We require\khcomment{assume?} all genesis ledger states to be valid.
Given this, we can determine the validity of any other ledger state.
% In
% informal terms, a valid ledger state $l$ can only be reached when starting from
% an initial state $l_{0}$ (ledger in the genesis state) and only executing LEDGER
% state transition rules as specified in Section~\ref{sec:ledger-trans} which
% changes either the  UTxO or the delegation state.

\begin{figure}[ht]
  \centering
  \begin{align*}
%    \genesisId & \in & \TxId \\
%    \genesisTxOut & \in & \TxOut \\
%    \genesisUTxO & \coloneqq & (\genesisId, 0) \mapsto \genesisTxOut
%    \\
%    \ledgerState & \in & \left(
    \LState & \in & \left(
                         \begin{array}{c}
                           \UTxOState \\
                           \DPState
                         \end{array}
    \right)\\
               && \\
    \fun{getUTxO} & \in & ( \UTxOState + \LState ) \to \UTxO \\
%    \fun{getUTxO} & \coloneqq & (\var{utxo}, \wcard, \wcard, \wcard) \to \var{utxo}
  \end{align*}
  \caption{Ledger State Domains}
  \label{fig:valid-ledger}
\end{figure}

\begin{definition}[\textbf{Genesis Ledger State}]
$$
%  \begin{array}{l}
    \applyFun{genesisState}~\left(
      \begin{array}{c}
        \left\{
        \genesisUTxO
        \right\} \\
        \left(
        \begin{array}{c}
          \emptyset\\
          \emptyset
        \end{array}
        \right)
      \end{array}
    \right) = \var{true}.
%  \end{array}
$$
\end{definition}

%% In Figure~\ref{fig:valid-ledger} \genesisId{} marks the transaction identifier
%% of the initial coin distribution, where \genesisTxOut{} represents the initial
%% UTxO. It should be noted that no corresponding inputs exists, i.e., the
%% transaction inputs are the empty set for the initial transaction. The function
%% \fun{getUTxO} extracts the UTxO from a UTxO state.

\begin{definition}[\textbf{Valid Ledger States}]
    $$
  \begin{array}{l}
    \forall l \in \LState,~~\applyFun{genesisState}(l)~~\implies~~ \applyFun{validLedgerState}(l). \\[2ex]
    \forall l, l' \in \LState, ~\var{lenv} \in \LEnv, \overline{\var{tx}} \in \Tx, ~\applyFun{unique}  ~(\applyFun{txins}~(\overline{\var{tx}})), \\
    \begin{array}{ll}
               & \applyFun{validLedgerState} l ~\wedge~ \var{lenv} \vdash l \transstar{ledger}{\overline{\var{tx}}} l' \\
      \implies & \applyFun{validLedgerState} l'.
    \end{array}
%    \forall 0 \le i \leq n, ~ \forall l_{i} \in \LState, \var{lenv} \in \LEnv, \var{tx}_{i} \in \Tx, \\
%    ~~~~s.t.~ \applyFun{validLedgerState} l_{i}, \var{lenv} \vdash l_{i} \transstar{ledger}{\var{tx}_{i}} l_{i+1}, \\
%    ~~~~\applyFun{validLedgerState} l_{i+1}.
  \end{array}
    $$
  \label{def:valid-ledger-state}
\end{definition}
%% \begin{definition}[\textbf{Valid Ledger State}]
%%   \begin{multline*}
%%     \forall l_{0},\ldots,l_{n} \in \LState, lenv_{0},\ldots,lenv_{n} \in \LEnv,
%%     l_{0} = \left(
%%       \begin{array}{c}
%%         \genesisUTxOState \\
%%         \left(
%%         \begin{array}{c}
%%           \emptyset\\
%%           \emptyset
%%         \end{array}
%%         \right)
%%       \end{array}
%%     \right)  \\
%%     \implies \forall 0 < i \leq n, (\exists tx_{i} \in \Tx,
%%     lenv_{i-1}\vdash l_{i-1} \trans{ledger}{tx_{i}} l_{i}) \implies
%%     \applyFun{validLedgerState} l_{n}
%%   \end{multline*}
%%   \label{def:valid-ledger-state}
%% \end{definition}

\noindent
Definition~\ref{def:valid-ledger-state} states a transitive property over ledger states: all sequences of valid transactions that start from a valid ledger state will yield a valid ledger state.
\khcomment{Changed this definition.  It was much weaker.  I have universally quantified it, meaning that all transactions yield a valid ledger state.} %  The s.t. could be replaced by $\implies$.}
We impose the additional condition that the inputs of each transaction must be
unique.  This ensures ``no double spend''.  Although this condition could, in principle, be
inferred by careful inspection of both successful and failing transactions, it is both simpler
and safer to state it explicitly here.\khcomment{Added the condition to make the no double spend property trivial...}


\begin{proof}[Proof Sketch]
  The proof is by inspection of each transition rule that processes a transaction, and by induction over sequences of such rules.
\end{proof}


\subsubsection{Overall Ledger State Validity}

It follows from the definitions above that any state that is reachable from a
genesis ledger state through any valid transaction is itself a valid ledger state.
Conversely, any state that is not reachable from a genesis ledger  is not a valid ledger state.

%% \begin{definition}[\textbf{Validity of a Genesis Ledger State}]
%%   $$
%%   \begin{array}{l}
%%     \forall l \in \LState,\\
%%     ~\applyFun{genesisState}(l) ~~\implies~~ \applyFun{validLedgerState} (l)
%%   \end{array}
%%   $$
%% \end{definition}

\begin{definition}[\textbf{Overall Ledger State Validity}]
  $$
  \begin{array}{l}
    \forall l,l' \in \LState, ~\var{lenv} \in \LEnv, ~\overline{\var{tx}} \in \Tx, \\
    ~~~~s.t.~\applyFun{genesisState} l ~\wedge~
    \var{lenv} \vdash l \transstar{ledger}{\overline{\var{tx}}} l',\\
    ~~~~~~~~\applyFun{validLedgerState} l'
  \end{array}
  $$
\end{definition}

\noindent
\begin{proof}[Proof Sketch]
  The proof follows directly from \emph{Genesis Ledger state} and \emph{Valid Ledger States}.
\end{proof}

\subsubsection{No Double Spend}

Property~\ref{prop:ledger-properties-no-double-spend} states a basic linearity property: each transaction input is \emph{used}
precisely once, in the sense that it appears only in the input set for a single transaction in a sequence of valid transactions. % \khcomment{Assumes transaction inputs are consumed by both successful and failing transactions.}

% defines a valid ledger state reachable
% from the genesis state via valid LEDGER STS transitions. This gives a
% constructive rule how to reach a valid ledger state.
\begin{property}[\textbf{No Double-Spend}]
  All transaction inputs are unique.
%  \khcomment{I believe that the property doesn't do what's wanted, since if a transaction fails, then its inputs can be used in
%    another transaction - i.e. this property can only be checked dynamically.  TODO: check this.  A better solution might
%    be to put a side-condition on e.g. system validity above?}
  %% $$
  %% \begin{array}{l}
  %%   \forall l, l' \in \ledgerState, ~\var{lenv}\in\LEnv, \overline{\var{tx}} \in \Tx, ~s.t. ~\applyFun{validLedgerState} l',  \\
  %%   \begin{array}{ll}
  %%              & \var{lenv} \vdash l \transstar{ledger}{\overline{\var{tx}}} l' \\
  %%     \implies & \applyFun{unique}{(\applyFun{txins}(\overline{\var{tx}}))}
  %%   \end{array}
  %% \end{array}
  %% $$
  \label{prop:ledger-properties-no-double-spend}
\end{property}

\noindent
\begin{proof}[Proof Sketch]
  The proof follows directly from the definitions of \textbf{Ledger State Validity} and \textbf{Overall Ledger State Validity} above.
  % , through inspection of each rule that uses transactions, and by induction
  %  over a sequence of transaction rules.
\end{proof}

%% states that for each valid
%% ledger state $l_{n}$ reachable from the genesis state, each transaction $t_{i}$
%% does not share any input with any previous transaction $t_{j}$. This means that
%% each output of a transition is spent at most once.


\subsection{Preservation of Value}
\label{sec:preservation-of-value}

As visualized in Figure~\ref{fig:fund-preservation},
the total amount of Lovelace in any given chain state
$\var{s}\in\ChainState$ is completely contained within the values of the six
variables:\\[1em]

\begin{tabular}{||l|l|l|l||}\hline\hline

  \textbf{Variable} & \textbf{Name in Figure~\ref{fig:fund-preservation}}
                    & \textbf{Nesting Inside Chain State} & \textbf{Kind} \\ \hline
  utxo & circulation & s.nes.es.ls.utxoSt & Map over Lovelace Values  \\ \hline
  deposits & deposits &  s.nes.es.ls.utxoSt & Lovelace Value ($\Coin$) \\ \hline
  fees & fees &  s.nes.es.ls.utxoSt & Lovelace Value ($\Coin$) \\ \hline
  rewards & reward accounts & s.nes.es.ls.dpstate.dstate  & Lovelace Value ($\Coin$)  \\ \hline
  treasury & treasury &  s.nes.es.acnt  & Lovelace Value ($\Coin$) \\ \hline
  reserves & reserves & s.nes.es.acnt & Map over Lovelace Values \\ \hline
  \hline
\end{tabular}
\\[1em]

\noindent
Notice that $\var{deposits}$, $\var{fees}$, $\var{treasury}$, and $\var{reserves}$
are all single Lovelace values, while $\var{utxo}$, and $\var{rewards}$ are
maps whose values\khcomment{ranges?} are Lovelace.
%
The \emph{Lovelace Value} of a given chain state is:
\begin{definition}[Lovelace Value]
  \label{def:val}
  \begin{equation*}
    \Val(s~\in~\var{State}) =
        \Val(\var{utxo}) +
            \Val(\var{deposits}) +
            \Val(\var{fees}) +
            \Val(\var{reserves}) +
            \Val(\var{treasury}) +
            \Val(\var{rewards})
  \end{equation*}
  where
  \begin{equation*}
      \Val(x \in \Coin) = x
  \end{equation*}
  \begin{equation*}
      \Val((\wcard\mapsto (y \in \Coin))^{*}) = \sum y
  \end{equation*}
\end{definition}

\noindent
For any state that is used in a given subtransition of $\mathsf{CHAIN}$,
we define $\Val{}$ in an analogous way, setting the value of any variable that is not explicitly
represented in the state to zero.
For example, given $\var{utxoSt}\in\UTxOState$,
\begin{equation*}
  \Val(\var{utxoSt}) =
  \left(\sum_{\wcard\mapsto v\in\var{utxo}}v\right) + \var{deposits} + \var{fees}
\end{equation*}

\noindent
The key property that we want to prove is that no semantic transition changes the value that
is captured in the state ($\Val{(s)}$).
This property is easy to state intuitively:
the \emph{Lovelace Value} before the transition is the same as the
\emph{Lovelace Value} after that transition.

\begin{theorem}[Preservation of Value]
  \label{thm:chain-pres-of-value}
  For all environments $e$, blocks $b$, and states $s$, $s'$, if
  \begin{equation*}
    e\vdash s\trans{\hyperref[fig:rules:chain]{chain}}{b}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) = \Val(s')
  \end{equation*}
\end{theorem}

\noindent
We will prove the soundness of Theorem~\ref{thm:chain-pres-of-value} via a few lemmas.

\begin{lemma}
  \label{lemma:value-sum-pres-1}
  For any mapping $m:A\mapsto\Coin$ and set $s\in\powerset{A}$,
  \begin{equation*}
    \Val(\var{m}) = \Val(s\subtractdom m) + \Val(s\restrictdom m)
  \end{equation*}
\end{lemma}
\begin{proof}
  Directly from the way in which $\Val{}$ is constructed.
\end{proof}

\begin{lemma}
  \label{lemma:value-sum-pres-2}
  For any mappings $m_1, m_2:A\mapsto\Coin$,
  if $\dom{m_1}\cap\dom{m_2}=\emptyset$,
  then
  \begin{equation*}
    \Val(m_1\cup m_2) = \Val(m_1) + \Val(m_2)
  \end{equation*}
\end{lemma}
\begin{proof}
  Directly from the way in which $\Val{}$ is constructed.
\end{proof}

\begin{lemma}
  \label{lemma:utxo-pres-of-value}
  For all environments $e$, transactions $t$, and states $s$, $s'$, if
  \begin{equation*}
    e\vdash s\trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{t}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) + w = \Val(s')
  \end{equation*}
  where $w = \fun{wbalance}~(\fun{txwdrls}~{t})$.
\end{lemma}

\begin{proof}
  The proof essentially involves unfolding the definition of the predicate
  \begin{equation}
    \label{cons-is-prod}
    \consumed{pp}{utxo}{stkCreds}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
  \end{equation}
  and applying some algebra.
%
If we let:
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      k & \keyRefunds{pp}{stkCreds}{tx} \\
      f & \txfee{tx} \\
      d & \deposits{pp}{stpools}~{(\txcerts{tx})} \\
      c & \decayedTx{pp}{stkCreds}~{tx} \\
    \end{array}
  \end{equation*}
  then equation~\ref{cons-is-prod} can be rewritten as:
  \begin{equation*}
    \Val(\txins{t} \restrictdom{\var{utxo}}) + w + k = \Val(\outs{t}) + f + d
  \end{equation*}
  where $\outs{}$ is defined in Figure~\ref{fig:functions:utxo} and returns a value of type $\UTxO$.
  Therefore, moving $k$ to the right and adding $\txins{t} \subtractdom{\var{utxo}}$ to each side,
  \begin{equation*}
    \Val(\txins{t} \restrictdom{\var{utxo}}) + \Val(\txins{t} \subtractdom{\var{utxo}}) + w
    = \Val(\outs{t}) + f + d - k + \Val(\txins{t} \subtractdom{\var{utxo}})
  \end{equation*}
  Note that $d-k-c$ is non-negative since the deposits will always be large enough to cover
  the current obligation (\textbf{Non-negative Deposit Pot:} Section~\ref{sec:non-negative-deposit-pot}).
%
  It then follows that:
  \begin{equation*}
    \begin{array}{r@{~=~}lr}
      \Val(\var{utxo}) + w
    & \Val(\outs{t}) + f + d - k + \Val(\txins{t} \subtractdom{\var{utxo}})
    & \text{(by Lemma~\ref{lemma:value-sum-pres-1})}
    \\
    & \Val((\txins{t} \subtractdom{\var{utxo}})\cup\outs{t}) + f + d - k
    & \text{(by Lemma~\ref{lemma:value-sum-pres-2})}
    \\
    & \Val((\txins{t} \subtractdom{\var{utxo}})\cup\outs{t}) + (d-k-c) + (f+c)
    & \text{(by adding $c-c$)}
    \end{array}
  \end{equation*}
  Therefore $\Val(s) + w = \Val(s')$.
\end{proof}

\begin{lemma}
  \label{lemma:deleg-pres-of-value}
  For all environments $e$, transactions $c$, and states $s$, $s'$, if
  \begin{equation*}
    e\vdash s\trans{\hyperref[fig:delegation-rules]{deleg}}{c}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) = \Val(s')
  \end{equation*}
\end{lemma}

\begin{proof}
  The only variable that has any Lovelace value in this transition is \var{rewards}.
  Only two of the rules in $\mathsf{DELEG}$ can change \var{rewards},
  namely $\mathsf{Deleg{-}Reg}$ and $\mathsf{Deleg{-}Dereg}$.
  However, $\mathsf{Deleg{-}Reg}$ only adds a zero value,
  and $\mathsf{Deleg{-}Dereg}$ only removes a zero value.
\end{proof}

\begin{lemma}
  \label{lemma:delegs-pres-of-value}
  For all environments $e$, certificates $\Gamma$, and states $s$, $s'$, if
  \begin{equation*}
    e\vdash s\trans{\hyperref[fig:rules:delegation-sequence]{delegs}}{\Gamma}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) = \Val(s') + w
  \end{equation*}
  where $w = \fun{wbalance}~(\fun{txwdrls}~{t})$,
  and $t$ is the transaction in the environment $e$.
\end{lemma}

\begin{proof}
  The proof is by induction on the length of $\Gamma$.
  Note that the only variable with value in this transition is \var{rewards}.

  \vspace{2ex}
  \noindent
  \emph{In the base case}, we look at the rule $\mathsf{Seq{-}delg{-}base}$.
  Since $\var{wdrls}\subseteq\var{rewards}$, then
  $\var{rewards} = \var{wdrls}\cup\var{(\var{rewards}\setminus\var{wdrls})}$.
%
  Therefore
  \begin{equation*}
    \begin{array}{r@{~=~}lr}
      \Val{(\var{rewards})}
      & \Val{(\var{rewards}\setminus\var{wdrls})} + \Val{(\var{wdrls})}
      & \text{by Lemma~\ref{lemma:value-sum-pres-2}}
      \\
      & \Val{(\var{rewards}\setminus\var{wdrls})} + w
      & \text{by definition}
      \\
      & \Val\left(\var{rewards}\unionoverrideRight\{(w, 0) \mid w \in \dom \var{wdrls}\}\right) + w
    \end{array}
  \end{equation*}
  Therefore $\Val(s) = \Val(s')$.

  \vspace{2ex}
  \noindent
  \emph{In the inductive case}, we look at the rule $\mathsf{Seq{-}delg{-}ind}$.
  In this case, the lemma then follows directly from Lemma~\ref{lemma:deleg-pres-of-value}.
\end{proof}

\begin{lemma}
  \label{lemma:poolreap-pres-of-value}
  For all environments $e$, epoch $\epsilon$, and states $s$, $s'$, if
  \begin{equation*}
    e\vdash s\trans{\hyperref[fig:rules:pool-reap]{poolreap}}{\epsilon}s'
  \end{equation*}
  then
  \begin{equation*}
    \Val(s) = \Val(s')
  \end{equation*}
\end{lemma}

\begin{proof}
  The $\mathsf{POOLREAP}$ value is contained in
  $\var{deposits}$, $\var{treasury}$, and $\var{rewards}$.
  Notice that $\var{unclaimed}$ is added to $\var{treasury}$
  and subtracted from the $\var{deposits}$.
  Moreover, $\var{refunded}$ is subtracted from $\var{deposits}$.
  (We will prove that $\var{deposits}-\var{unclaimed}+\var{refunded}$
  is non-negative in \textbf{Non-negative Deposit Pot:} Section~\ref{sec:non-negative-deposit-pot}).
  It therefore suffices to show that
  \begin{equation*}
    \begin{array}{r@{~=~}l}
    \Val(\var{rewards}\unionoverridePlus\var{refunds})
    & \Val(\var{rewards}) + \Val(\var{refunds})
    \\
    & \Val(\var{rewards}) + \var{refunded}
    \end{array}
  \end{equation*}
  But this is clear from the definition of $\unionoverridePlus$.
\end{proof}

\begin{lemma}
  \label{lemma:ru-pres-of-value}
  For all mappings $b$ of blocks made, epochs $\epsilon$, and epoch states $s$,
  \begin{equation*}
    \Val(s) = \Val(\fun{applyRUpd}~(\fun{createRUpd}~b~s)~\epsilon~s)
  \end{equation*}
\end{lemma}

\begin{proof}
  In the definition of $\fun{applyRUpd}$ in Figure~\ref{fig:functions:reward-update-application},
  we see that:
  \begin{equation*}
      \Delta t + \Delta r + \Val(rs) + \Val(\var{update_{rwd}}) + \Delta d + \Delta f = 0
  \end{equation*}
  In the definition of $\fun{createRUpd}$ in Figure~\ref{fig:functions:reward-update-creation},
  we see that:
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      \var{rewardPot} & \var{feeSS} + \Delta r_1 \\
      \var{R} & \var{rewardPot} - \Delta t_1 \\
      \Delta t_2 & R \\
    \end{array}
  \end{equation*}
  Therefore
  \begin{equation*}
    \begin{array}{c}
      (\var{feeSS} + \Delta r_1) - \Delta t_1 - \Val(rs) = \Delta t_2 \\
      0 = (\Delta t_1 + \Delta t_2 ) - \Delta r_1 + \Val(rs)- \var{feeSS} \\
    \end{array}
  \end{equation*}
  So it suffices to show that $\Delta d + \Val(\var{update_{rwd}}) = \var{rewards}_{\var{mir}}$.
  Notice that
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      \Val(\var{update}_{rwd}) & \Val(registered) + \Val(newlyRegister')
      \\
      \var{rewards}_{mir} & \Val(registered) + \Val(newlyRegister)
      \\
      \Delta d + \Val(newlyRegister') & \Val(newlyRegister)
    \end{array}
  \end{equation*}
  $\Delta d + \Val(\var{update_{rwd}}) = \var{rewards}_{\var{mir}}$
  follows by adding $\Val(registered)$ to both sides of the third
  equality above, and then substituting using the other two equalities.
\end{proof}

\noindent
We are now ready to prove Theorem~\ref{thm:chain-pres-of-value}.

\begin{proof}
  For a given transition $\mathsf{TR}$, let \POV{TR}
  be the statement:

  \begin{tabular}{l}
    for all environments $e$, signals $\sigma$, and states $s$, $s'$,
    $$
    $e\vdash s\trans{tr}{\sigma}s'~\implies~\Val(s) = \Val(s')$.
    $$
  \end{tabular}

  \noindent
  Our goal is to prove \POV{CHAIN}.
  Lemmas~\ref{lemma:utxo-pres-of-value} and \ref{lemma:delegs-pres-of-value} imply \POV{LEDGER},
  since $\mathsf{UTXOW}$ transforms state exactly as $\mathsf{UTXO}$ does.
  \POV{LEDGERS} then follows by straightforward induction on the length of $\Gamma$:
  the base case is trivial;
  and the inductive case follows directly from \POV{LEDGER}.
%
  \POV{SNAP} holds since $\var{decayed}$ is added to $\var{fees}$
  and subtracted from $\var{deposits}$.
  Similarly, \POV{NEWPP} holds since $\var{diff}$ is added to $\var{reserves}$
  and subtracted from $\var{deposits}$.
  Therefore \POV{EPOCH} holds by Lemma~\ref{lemma:poolreap-pres-of-value}
  and \POV{NEWEPOCH} holds by Lemma~\ref{lemma:ru-pres-of-value}.
  \POV{CHAIN} easily follows from this.
\end{proof}

\subsection{Non-negative Deposit Pot}
\label{sec:non-negative-deposit-pot}

The \emph{deposit pot} (the variable $\var{deposits}$ in the UTxO State)
represents the amount of \emph{Lovelace} that is set aside by the system as a whole for refunding deposits.
Deposits are added to this pot, which then decays exponentially over time,
and is also depleted by any refunded deposits.
At an epoch boundary, the decayed parts of any deposits (including, possibly, deposits for any transactions that will complete in future epochs)
will be distributed as additional \emph{rewards}, as described in~\cite{delegation_design}.
Since $\var{deposits}$ is only used to record the value of future refunds or rewards whose costs have
already been incurred, both it and any reward value will always be non-negative.
Note that there are two types of deposits which are recorded in the same pot: those for stake keys; and those for stake pools.
Stake keys are deregistered in the slot in which the deregistration certificates
is processed. Stake pools, however, are staged for retirement on epoch boundaries.
%
The following theorem ensures that the deposit pot is properly maintained
and will always be large enough to meet all of its obligations.


\begin{figure}[h!]
  \begin{tabular}{||l|l|l|l||}\hline\hline

    \textbf{Variable} & \textbf{Value}
                      & \textbf{Nesting Inside Chain State} & \textbf{Kind} \\ \hline
    deposits & 0 &  s.nes.es.ls.utxoSt & $\Coin$ \\ \hline
    stkCreds & $\emptyset$ & s.nes.es.ls.dpstate.dstate.stkCreds
             & $\StakeCreds$ ($\Credential\mapsto\Slot$)  \\ \hline
    stpools & $\emptyset$ & s.nes.es.ls.dpstate.pstate.stpools
            & $\StakePools$ ($\KeyHash\mapsto\Slot$)  \\ \hline
  \end{tabular}
  \caption{Initial Chain State}
  \end{figure}

\begin{theorem}[Non-negative Deposit Pot]
  \label{thm:non-neg-deposits}
  Let $n\in\N$ and $c_0\in\ChainState$ be a chain state in which $\var{deposits} ~=~0$, $\var{stkCreds}~=~\emptyset$ and $\var{stPools}~=~\emptyset$, as shown above:
%  \\~\\
  If
  \begin{equation*}
    s_0\vdash c_0\trans{\hyperref[fig:rules:chain]{chain}}{b_0}c_1,~~
    s_1\vdash c_1\trans{\hyperref[fig:rules:chain]{chain}}{b_1}c_2,~~
    \ldots,~~
    s_n\vdash c_n\trans{\hyperref[fig:rules:chain]{chain}}{b_n}c_{n+1},~~n \ge 0
  \end{equation*}
  is a sequence of valid $\mathsf{CHAIN}$ transitions,
  then $\forall i, 0 \le i \le n, \var{deposits} ~(c_{n+1}) \ge 0$.
\end{theorem}

\begin{proof}

  We will prove a slightly stronger condition, namely that some stronger invariants hold
  most of the time, and that when they do fail to hold, then $\var{deposits}$ is still non-negative.
  These stronger invariants will require a few additional definitions.
%
  Given a slot $s$, let $\ell(s)$ be the first slot of the epoch that $s$ occurs in,
  that is $\ell = \firstSlot{}\circ\epoch{}$.
  Given a mapping $m\in\mathsf{T}\to\Slot$ and a slot $s\in\Slot$,
  let $\fun{sep}$ be the function that separates $m$ into two maps,
  those whose value is strictly less than $s$ and those whose value is at least $s$.
  So,
  \begin{equation*}
    \fun{sep}~m~s = \forall x\mapsto t~\in~m,~~
    \left(\{x\mapsto t~\mid~t<s\},~\{x\mapsto t~\mid~t\geq s\}\right)
  \end{equation*}


  \noindent
  If we assume that the \emph{protocol parameters}, $pp$, are fixed\footnote{Note that the
    protocol parameters can only change in the $\mathsf{NEWPP}$ transition.}, then we can provide convenience functions
  $R_c$ and $R_p$ for the \emph{stake credential} and \emph{stake pool} refunds, respectively:
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      R_c~s_0~s_1 & \refund{d_{val}}{d_{min}}{\lambda_d}{s_1-s_0} \\
      R_p~s_0~s_1 & \refund{p_{val}}{p_{min}}{\lambda_p}{s_1-s_0} \\
    \end{array}
  \end{equation*}
  where $d_{val}$, $d_{min}$, $\lambda_d$, $p_{val}$, $p_{min}$, $\lambda_p$
  are the protocol parameter values from $pp$, and $\fun{refund}$ is defined in
  Figure~\ref{fig:functions:deposits-refunds}.
  We let \DBE{c}{s} (``Deposits (precisely) Big Enough"), be the following property:
  \begin{equation}\tag{DBE}\label{DBE}
    \var{deposits}
    = \left(\sum_{\wcard\mapsto t\in C_{old}}R_c~t~\ell(s)\right)
    + |C_{new}|\cdot d_{val}
    + \left(\sum_{\wcard\mapsto t\in P_{old}}R_p~t~\ell(s)\right)
    + |P_{new}|\cdot p_{val}
  \end{equation}
  where
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      C_{old},~C_{new} & \fun{sep}~\var{stkCreds}~{\ell(s)} \\
      P_{old},~P_{new} & \fun{sep}~\var{stpools}~{\ell(s)},
    \end{array}
  \end{equation*}
  for some slot, $s$, where $\var{pp}$, $\var{stkCreds}$, $\var{stpools}$ are in the corresponding chain state, $c$.
%
  In other words, \DBE{c}{s} asserts that the deposit pot is equal to the
  sum of the deposit refunds that were available at the previous epoch boundary,
  plus the sum of the initial deposit values for all the deposits from the current epoch.

  Notice that for a chain state $c$ and slot $s$, if the range of
  $\var{stkCreds}$ and $\var{stpools}$ contains only slots from the previous epoch,
  then \DBE{c}{s} is equivalent to
  \begin{equation}\tag{DEO}\label{DEO}
    \var{deposits} = \obligation{pp}{stkCreds}{stpools}{\ell(s)}
  \end{equation}
  where $\fun{obligation}$ is defined in Figure~\ref{fig:funcs:epoch-helper-rewards}.
%
  It is generally true that \DBE{c'}{s_i} holds after each subtransition of
  $s_i\vdash c_i\trans{\hyperref[fig:rules:chain]{chain}}{b_i}c_{i+1}$.
  However, this invariant can fail to hold after the
  $\hyperref[fig:delegation-transitions]{\mathsf{DELEG}}$ transition,
  since this transition can add and remove stake credentials, and can also add stake pools,
  but the deposit pot is not adjusted accordingly
  until the next subtransiton of $\hyperref[fig:rules:ledger]{\mathsf{LEDGER}}$,
  namely $\hyperref[fig:rules:utxo-shelley]{\mathsf{UTXO}}$.
%
  The invariant can also fail to hold if the slot increases while the chain state remains the same.
  That is, if \DBE{c_{i+1}}{s_i} holds, then \DBE{c_{i+1}}{s_{i+1}} can fail to hold if
  $\epoch{s_i} < \epoch{s_{i+1}}$, since the value of the deposit
  in the left hand side of equation~\ref{DBE} remains the same, but the
  refunded values become smaller\footnote{Note that if $\epoch{s_i} = \epoch{s_{i+1}}$, then \DBE{c_{i+1}}{s_{i+1}} is trivially true.}.
  Therefore, in this situation we can consider the slightly weaker constraint:
  \begin{equation}\tag{DGO}\label{DGTO}
    \var{deposits} \geq \obligation{pp}{stkCreds}{stpools}{\ell(s)}
  \end{equation}
  The difference between the left and right hand sides of the inequality
  corresponds to the Lovelace value in $c_{i+1}$ that decays between $s_i$ and $s_{i+1}$.

  There are five sub-transitions where $\var{deposits}$ is changed:
  $\mathsf{SNAP}$ (Figure~\ref{fig:rules:snapshot}),
  $\mathsf{POOLREAP}$ (Figure~\ref{fig:rules:pool-reap}),
  $\mathsf{NEWPP}$ (Figure~\ref{fig:rules:new-proto-param}),
  $\mathsf{NEWEPOCH}$ (via $\fun{applyRUpd}$ in Figure~\ref{fig:functions:reward-update-application}).
  $\mathsf{UTXO}$ (Figure~\ref{fig:rules:utxo-shelley}).
  This ordering is also the order in which $\var{deposits}$ is changed.
  Of these sub-transitions, only $\mathsf{UTXO}$ actually changes the value of $\var{deposits}$
  when $s_i$ is in the same epoch as $s_i$.
  (We say that $s_i$ \emph{crosses the epoch boundary} if the precondition of
  Rule~\ref{eq:new-epoch} in Figure~\ref{fig:rules:new-epoch} is met,
  namely if $\epoch{s_i} \ge e_\ell+1$.)
%
  The proof then proceeds by induction on $n$, showing the following:
  \begin{itemize}
    \item
      Let $c$ be the chain state after the $\mathsf{SNAP}$ transition
      in $s_i\vdash c_i\trans{\hyperref[fig:rules:chain]{chain}}{b_i}c_{i+1}$.
      If \DGO{c_i}{s_i}, then \DBE{c}{s_i} holds.
    \item $\mathsf{POOLREAP}$ preserves \ref{DBE}.
    \item $\mathsf{NEWPP}$ preserves \ref{DBE}.
    \item $\mathsf{NEWEPOCH}$ preserves \ref{DBE}.
    \item The property for $\mathsf{UTXO}$ requires a bit of explanation.
      Let $\var{nes}\in\NewEpochState$ be the new epoch state in $c_i$.
      Note that the property \ref{DBE} makes sense for values of $\NewEpochState$
      since it contains all the relevant variables.
      Similarly, \ref{DBE} also makes sense for values of $\UTxOState\times\PParams$.
      Let
      $$
        {\begin{array}{c}
           \eta_c \\
           \var{gkeys} \\
         \end{array}}
        \vdash\var{nes}\trans{\hyperref[fig:rules:bhead]{bhead}}{\var{bh}}\var{nes'}
      $$
      be the first sub-transition of
      $s_i\vdash c_i\trans{\hyperref[fig:rules:chain]{chain}}{b_i}c_{i+1}$.
      If \DBE{\var{nes'}}{s_i} holds, then \DBE{(us', pp)}{s_i} holds for every transaction
      $tx$ in $b_i$, where:
      $$
      \var{env}\vdash \var{us} \trans{\hyperref[fig:rules:utxow-shelley]{utxo}}{tx} \var{us'},
      $$
      is a sub-transition of
      $s_i\vdash c_i\trans{\hyperref[fig:rules:chain]{chain}}{b_i}c_{i+1}$,
      and $\var{pp}$ is the protocol parameters in $\var{nes'}$.
  \end{itemize}

  \noindent
  Case $\hyperref[fig:rules:snapshot]{\mathsf{SNAP}}$.
  We must show that
  if $c$ is the chain state after the $\mathsf{SNAP}$ transition
  in $s_i\vdash c_i\trans{\hyperref[fig:rules:chain]{chain}}{b_i}c_{i+1}$,
  and \DGO{c_i}{s_i} holds, then so does \DBE{c}{s_i}.
%
  We can assume that $s_i$ crosses the epoch boundary,
  since otherwise the $\mathsf{SNAP}$ transition will not occur.
  Since the $\mathsf{SNAP}$ transition only happens within the $\mathsf{BHEAD}$ transition
  on the epoch boundary, it follows that
  $c_i$ does not contain any stake credentials or pools from the current epoch,
  and so \ref{DBE} will be equivalent to \ref{DEO} (the current epoch is $\epoch{s_i}$).
  However, \DBE{c}{s_i} holds trivially, since it is determined from the $\fun{obligation}$ value.
  \\~\\
  Case $\hyperref[fig:rules:pool-reap]{\mathsf{POOLREAP}}$.
  We must show that \ref{DBE} is preserved.
%
  We again assume that $s_i$ crosses the epoch boundary.
  The $\mathsf{POOLREAP}$ transition does the following:
  \begin{enumerate}
    \item leaves $\var{stkCreds}$ unchanged,
    \item removes $\var{retired}$ from $\var{stpools}$,
    \item subtracts $\var{unclaimed}+\var{refunded}$ from $\var{deposits}$.
  \end{enumerate}
%
  Notice that the domain of the $\var{pr}$ is $\var{retired}$,
  and similarly the domain of the $\var{rewardAcnts}$ is also $\var{retired}$
  since the domains of $\var{stpools}$ and $\var{poolParams}$ are the same.
  Therefore $\var{retired}$ is the disjoint union of
  $\dom({\var{refunds}})$ and $\dom({\var{mRefunds}})$, so that
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      \var{unclaimed}+\var{refunded}
      &
      \left(
        \sum\limits_{\wcard\mapsto t\in\var{refunds}}R_p~t~\ell(s)
      \right)+
      \left(
        \sum\limits_{\wcard\mapsto t\in\var{mRefunds}}R_p~t~\ell(s)
      \right)
      \\
      &
      \sum\limits_{\wcard\mapsto t\in\var{rewardAcnts'}}R_p~t~\ell(s)
      \\
      &
      \left(
        \sum\limits_{\wcard\mapsto t\in\var{stpools}}R_p~t~\ell(s)
      \right)-
      \left(
        \sum\limits_{\wcard\mapsto t\in\var{retired}\subtractdom\var{stpools}}R_p~t~\ell(s)
      \right)
    \end{array}
  \end{equation*}
  Therefore, it follows that if \ref{DEO} holds before $\mathsf{POOLREAP}$, then it also holds afterwards.
  \\~\\
  Case $\hyperref[fig:rules:new-proto-param]{\mathsf{NEWPP}}$.
  We must show that \ref{DBE} is preserved.
%
  We again assume that $s_i$ crosses the epoch boundary.
  In this transition $\var{pp}$ can change, but $\var{stkCreds}$, $\var{stpools}$,
  and $\var{deposits}$ do not change.
  As in the $\mathsf{SNAP}$ case, \DBE{c}{s_i} holds trivially,
  since it is set to the value that is determined by $\fun{obligation}$.
  \\~\\
  Case $\hyperref[fig:rules:new-epoch]{\mathsf{NEWEPOCH}}$.
  We must show that \ref{DBE} is preserved.
%
  We again assume that $s_i$ crosses the epoch boundary.
  We must show that $\fun{applyRUpd}$, from Figure~\ref{fig:functions:reward-update-application},
  preserves \ref{DBE}.
  It suffices to show that $\Delta d$ is equal to $|C_{new}|\cdot d_{val}$
  where $C_{new} = \dom{(\var{update}_{delegs})}\setminus\dom{(\var{stkCreds})}$.
  Rewards updates are only ever created with $\fun{createRUpd}$
  from Figure~\ref{fig:functions:reward-update-creation},
  in which $\Delta d$ is defined as $|newlyRegister|\cdot d_{val}$,
  so it suffices to show that $\dom{(\var{newlyRegister})} = C_{new}$.
  But $\dom{(\var{update}_{delegs})} = \dom{(\var{rew}_{mir})}$
  and $\var{newlyRegister} = \dom{(stkCreds)}\subtractdom \var{rew}_{mir}$.
  Therefore
  \begin{equation}
    \begin{array}{r@{~=~}l}
      \dom{(\var{newlyRegister})} & \dom{(\var{rew}_{mir})}\setminus  \dom{(\var{stkCreds})} \\
                                  & \dom{(\var{update}_{delegs})}\setminus  \dom{(\var{stkCreds})} \\
                                & C_{new}, \\
    \end{array}
  \end{equation}
  and so \ref{DBE} is preserved.
  \\~\\
  Case $\hyperref[fig:rules:utxo-shelley]{\mathsf{UTXO}}$.
  We assume that \DBE{\var{nes'}}{s_i} holds, where $\var{nes'}$
  is the new epoch state after the $\mathsf{BHEAD}$ transition.
  We must show that \ref{DBE} is preserved after each $\mathsf{UTXO}$ transition.
%
  The $\mathsf{DELEGS}$ transition can result in values being
  added to or deleted from $\var{stkCreds}$, and added to $\var{stpools}$.
  Let $A_s$ be the added stake credentials, $D_s$ be the deleted credentials, and
  $A_p$ be the added stake pools, where $\var{stkCreds}'$ is the stake credential mapping
   $\var{stpools}'$ is the stake pools, and $\var{deposits}'$ is the deposit pot  after $\mathsf{DELEGS}$.
  We have that
  \begin{equation*}
    \begin{array}{rcl}
      \var{D_s} & \subseteq & \var{\var{stkCreds}\cup\var{A_s}} \\
      \var{stkCreds}' & = & (\var{stkCreds}\cup\var{A_s})\setminus\var{D_s} \\
      \var{stpools}' & = & \var{stpools}\cup\var{A_p} \\
    \end{array}
  \end{equation*}
  The slots in the range of $A_s$ will all be equal to $s_i$,
  but the slots in the range of $D_s$
may either be from the current epoch or an earlier one, so we split them using $\fun{sep}$:
  \begin{equation*}
    (\var{D_{s\_old}},~\var{D_{s\_new}}) = \fun{sep}~\var{D_s}~\ell(s_i)
  \end{equation*}
  We must then show that
  \begin{equation*}
    \var{deposits}' = \var{deposits}
    + |A_s|\cdot d_{val}
    + |P_c|\cdot p_{val}
    - |D_{s\_new}|\cdot d_{val}
    - \left(\sum_{\wcard\mapsto t\in D_{s\_old}}R_c~t~\ell(s_i)\right)
  \end{equation*}
  Looking at the $\mathsf{UTXO}$ transition in Figure~\ref{fig:rules:utxo-shelley},
  \begin{equation*}
    \var{deposits}' = \var{deposits} + (\deposits{pp}~{stpools}~{\txcerts{tx}})
    - (\var{refunded} + \var{decayed})
  \end{equation*}
  The function $\fun{deposits}$ is defined in Figure~\ref{fig:functions:deposits-refunds}
  and it is clear that here it is equal to
  $$|A_s|\cdot d_{val} + |P_c|\cdot p_{val.}$$
  Recall that
  \begin{equation*}
    \begin{array}{r@{~=~}l}
      \var{refunded} & \keyRefunds{pp}{stkCreds}~{tx} \\
      \var{decayed} & \decayedTx{pp}{stkCreds}~{tx}
    \end{array}
  \end{equation*}
  where $\fun{keyRefunds}$ is defined in Figure~\ref{fig:functions:deposits-refunds}.
  This iterates $\fun{keyRefund}$ from the same figure,
  which in turn just looks up the creation slot for a transaction and returns $R_c$.
  The function to calculate the value of decayed deposits, $\fun{decayedTx}$, is defined in Figure~\ref{fig:functions:deposits-decay}.
  This iterates $\fun{decayedKey}$ from the same figure.
  Therefore, to show that
  \begin{equation}\label{deleted-is-refunds-plus-decayed}
    |D_{s\_new}|\cdot d_{val} + \sum_{\wcard\mapsto t\in D_{s\_old}}R_c~t~\ell(s_i)
    = \var{refunded} + \var{decayed},
  \end{equation}
  and thus complete the proof for the $\mathsf{UTXO}$ case,
  it suffices to show that for a given $\var{c}\mapsto s\in D_s$,
  the $R_c$ value plus the $\fun{decayedKey}$ value that is associated with the stake
  credential $c$ is equal to $d_{val}$ if $\epoch(s)=\epoch(s_i)$, and is otherwise equal to $R_c~s~\ell(s_i)$.
  Looking at the definition of $\fun{decayedKey}$, observe that if $\epoch(s)=\epoch(s_i)$
  then $\var{start}=\var{created}$ and so the decayed value is $(R_c~s~s)-(R_c~s~s_i)$.
  However, $R_c~s~s = d_{val}$, so the refund plus the decayed value is
  $d_{val}-(R_c~s~s_i)+(R_c~s~s_i)=d_{val}$.
  Otherwise, if $s$ is from a previous epoch, then $\var{start}=\ell(s_i)$, and so
  the decayed value is $(R_c~s~\ell(s_i))-(R_c~s~s_i)$.
  The refund plus the decayed value is thus
  $(R_c~s~\ell(s_i))-(R_c~s~s_i)+(R_c~s~s_i)=(R_c~s~\ell(s_i))$.
  Therefore, equation~\ref{deleted-is-refunds-plus-decayed} holds, and
  consequently so also does \DBE{c'}{s_i}.

\end{proof}

\subsection{Other Deposit Properties}

% Property
\subsubsection{Deposits always Cover Obligations}
 The \textit{deposits} pot is always sufficient to cover the current \emph{obligation}
(the total Lovelace value that is needed to refund every current stake registration and
pool registration certificate). \khcomment{I'm not sure whether we need the valid ledger state condition?}
%
%% \begin{property}[\textbf{Deposit Coverage}]
%% $$
%% \forall s \in \LState,~ d_i \in \Val(\applyFun{registrations}(s)),~~~\applyFun{validLedgerState}(s) ~~\implies~~ \var{deposits} \ge \sum d_i
%% $$
%% \end{property}
%
This is just a corollary of \textbf{Non-Negative Deposits}.

%% \begin{proof}[Proof Sketch]
%%   The proof is by inspection of the UTXO and POOLREAP rules, which are the only rules that affect \var{deposits}.  Each initial deposit
%%   is a positive value that completely covers the maximum value that could be returned to the registration owner. This is reduced using an exponential formula,
%%   with a minimal value of zero.
%% \end{proof}

%% \paragraph*{Corollary:} The UTXO and POOLREAP rules never produce a negative value for \textit{deposits}.

\subsubsection{Return of Deposits}

All deposits are returned either to the transaction owner or in the form of rewards. Note that the rewards could be held in a reward account indefinitely if the recipient
chooses not to release them, but that they would still be available for staking if desired.

%% \begin{property}[\textbf{Deposit Return}]
%%   $$
%%   \begin{array}{l}
%%     \forall s \in \LState,~ (o,d) \in \applyFun{registrations}(s),~~s.t. \applyFun{validLedgerState}(s)\\
%%   = d
%%   \end{array}
%%   $$
%% \end{property}

\begin{proof}[Proof Sketch]

\noindent
The proof is by inspection of the UTXO and POOLREAP rules, which are the only rules that affect \var{deposits}.
The value of a deposit decays over time according to a fixed formula. The resulting decayed deposit is returned
to the owner by the POOLREAP rule when the transaction either completes or times out.
Any remaining deposit (the \emph{retained deposit}) is allocated to \var{rewards} by the POOLREAP rule.
\end{proof}

\subsection{Correct Allocation of Incentives/Rewards}

All rewards are allocated either from the \emph{reserves} through \emph{monetary expansion},
from any partially \emph{retained deposits} or from \emph{transaction fees}.  Moreover, all
\emph{transaction fees} are returned in the form of rewards.

$$
\sum{\textit{rewards}_i}(E)~~=~~\textit{ME}(E) + \var{deposits}_\textit{retained}(E) + \textit{fees}_\textit{incurred}(E)
$$

\begin{proof}[Proof Sketch]
%\paragraph*{Proof Sketch}

\noindent
The proof is by inspection of the REWARDS, DEPOSITS, FEES and EXPANSION rules\khcomment{Have just picked arbitrary names - check the actual ones :)}.
FEES, DEPOSITS and EXPANSION are the only rules that transfer value to the \textit{rewards} pot.
REWARDS is the only rule that transfers value from the \textit{rewards} pot.
Transaction fees are added to \emph{rewards} by the REWARDS rule.
\end{proof}

\subsection{Total Ada and Ada in Circulation}

The total Ada \emph{in existence} remains constant.  This is simply a corollary of \textbf{Preservation of Value} from Section~\ref{sec:preservation-of-value},
following from the definition below.  This total has been fixed by the community to be exactly 45~Billion Ada.
The Ada in circulation is simply all the Ada that is not held in reserves. \khcomment{Should the treasury be excluded from the Circulation?
  If so these properties will not be correct, since money can flow to the treasury from other pots.}


\begin{definition}[Total Ada]
  $\textit{TotalAda} = \textit{utxo} + \textit{deposits} + \textit{fees} + \textit{rewards} + \textit{reserves} + \textit{treasury}$
\end{definition}

% \subsection{Circulation}

\begin{definition}[Ada in Circulation]
$\textit{Circulation} = \textit{TotalAda} - \textit{reserves}$
% $\textit{circulation} = \textit{totalAda} - \textit{reserves} - \textit{treasury}$ - alternative
\end{definition}


% \begin{property}
% \end{property}
\noindent
We can define three useful properties relating to the \emph{Circulation}.

% \begin{enumerate}
% \item
\begin{property}
  The total Ada \emph{in circulation} is only changed through monetary expansion:\khcomment{Can be stated as a property of all transition rules apart from ME.}
  $$
  \forall i \in \var{Slot}, i > 0, ~\var{Circulation}_{i+1} ~= ~\var{Circulation}_{i} + \applyFun{ME}(E).
  $$
\end{property}
% \item
\begin{property}
  The total Ada \emph{in circulation} never decreases:
  $$
  \forall i \in \var{Slot}, i > 0, ~\var{Circulation}_{i+1} \ge ~\var{Circulation}_{i}.
  $$
\end{property}
%\item
\begin{property}
  The total Ada \emph{in circulation} never exceeds the total Ada \emph{in existence}:
  $$
  \forall i \in \var{Slot}, i \ge 0, ~\var{Circulation}_i \le \var{TotalAda}.
  $$
\end{property}
%\end{enumerate}

\begin{proof}[Proof Sketch]

\noindent
The proof of these properties is from the \textbf{Preservation of Ada}, from the definitions above, and by inspection of the EXPANSION rule.
The latter is the only rule that impacts \textit{reserves}.  Therefore property 1) holds.
The same rule transfers a positive value of Lovelace from \textit{reserves} to \textit{rewards}, meaning
that property 2) also holds.
Finally, the value that is transferred from \textit{reserves} to \textit{rewards} declines exponentially with each epoch,
and is always less than reserves.  Therefore property 3) holds.

\end{proof}


% \subsection{}

% \subproperty{The value (Circulation + Deposits + Fees + Rewards) is the same before and after the epoch boundary.}
\khcomment{``The value (Circulation + Deposits + Fees + Rewards) is the same before and after the epoch boundary.'' Generalised above, I think.}

% NEWEPOCH

% Pots in scope: All

% Besides using the EPOCH transition, NEWEPOCH applies a reward update.
% The reward update decreases the reserves and the fee pot, but increases the treasury and the reward pot.

% Property The value (Reserves + Fees + Treasury + Rewards) is the same before and after the transition.

% Property The Circulation and Deposits do not change.

\subsection{Time-Travelling Header Properties}

\emph{Replicate Properties 1-3 from Section 8 the Byron chain specification.}
\khcomment{TODO: Do this.}


\subsection{Stake and Delegation}

\begin{figure}[ht]
  \centering
  \begin{align*}
    \fun{getStDelegs} & \in & \DState \to \powerset \Credential \\
    \fun{getStDelegs} & \coloneqq &
                                    ((\var{stkCreds}, \wcard,
                                    \wcard,\wcard,\wcard,\wcard) \to \var{stkCreds} \\
                      &&\\
    \fun{getRewards} & \in & \DState \to (\AddrRWD \mapsto \Coin) \\
    \fun{getRewards} & \coloneqq & (\wcard, \var{rewards},
                                   \wcard,\wcard,\wcard,\wcard)
                                   \to \var{rewards} \\
                      &&\\
    \fun{getDelegations} & \in & \DState \to (\Credential \mapsto \KeyHash) \\
    \fun{getDelegations} & \coloneqq & (\wcard, \wcard,
                                       \var{delegations},\wcard,\wcard,\wcard) \to
                                       \var{delegations} \\
                      &&\\
    \fun{getStPools} & \in & \LState \to (\KeyHash \mapsto \DCertRegPool) \\
    \fun{getStPools} & \coloneqq & (\wcard, (\wcard,
                                   (\var{stpools},\wcard,\wcard,\wcard))) \to \var{stpools} \\
                      &&\\
    \fun{getRetiring} & \in & \LState \to (\KeyHash \mapsto \Epoch) \\
    \fun{getRetiring} & \coloneqq & (\wcard, (\wcard,
                                    (\wcard, \wcard, \var{retiring},\wcard))) \to \var{retiring} \\
  \end{align*}

  \caption{Definitions for Stake Delegation}
  \label{fig:stake-delegation-functions}
\end{figure}

\subsubsection{Valid Stake}

\begin{property}[\textbf{Valid Stake}]
All \emph{stake} is either held in the \emph{account holdings} or else held in a \emph{reward account}. \khcomment{Simple validity check.  Might be trivially true.}
\end{property}

\begin{proof}{Proof Sketch}
  The proof is by inspection and induction over the ledger transition rules, specifically those that are used for staking purposes.
  \khcomment{TODO: check the delegation rules below.}
\end{proof}


\subsubsection{Stake Pool Registration, Retirement and Reaping}
\label{sec:ledg-state-prop}

Property~\ref{prop:ledger-properties-9} states the certificate requirements for registering a new stake pool.
\khcomment{It's not obvious that l' must follow from l, and p/p' could be confused with l/l'.}

\begin{property}[\textbf{Stake Pool Registration}]
  $$
  \begin{array}{l}
    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},~\var{c} \in \DCertRegPool,~
    \var{penv} \in\PEnv \\[0.5ex]
    \quad s.t. ~~ \var{penv} \vdash p \trans{pool}{c} p'
   ~\wedge~  \applyFun{cwitness}{c} = \var{hk}, \\[1ex]
    \quad\quad\var{hk}\in \applyFun{getStPools}(p') ~\wedge~ \var{hk} \not\in \applyFun{getRetiring}{p'}\\[1ex]
    \mathrm{where}~~\\
    \quad\quad p = \applyFun{pools}(\var{l}); ~~p' = \applyFun{pools}(\var{l'})
  \end{array}
  $$
%    \implies \applyFun{cwitness}{c} = \var{hk}\\ \implies
    %  \begin{multline*}
%    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
%    l = (\wcard, (\wcard, p)), l' = (\wcard, (\wcard, p')), pEnv\in\PEnv \\
%    \implies  \var{p} \trans{pool}{c} \var{p'}
%    \implies \applyFun{cwitness}{c} = \var{hk}\\ \implies
%    \var{hk}\in\applyFun{getStPools}{p'} \wedge \var{hk} \not\in
%    \applyFun{getRetiring}{p'}
%  \end{multline*}
  \label{prop:ledger-properties-9}
\end{property}

%% that for $l, l'$ as above but
%% with a delegation transition of type $\DCertRegPool$, the key $hk$ is associated
%% with the author of the pool registration certificate in $\var{stpools}$ of $l'$
%% and that $hk$ is not in the set of retiring stake pools in $l'$.

\noindent
Property~\ref{prop:ledger-properties-10} states that before retiring a pool, the key $hk$ must be
associated with the author of the pool registration certificate and represents a stake pool
that is due to retire no more than $\emax$ epochs in the future.\khcomment{The property was a bit messed up.}

\begin{property}[\textbf{Stake Pool Retirement}]
  $$
  \begin{array}{l}
    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},~\var{cepoch}, e \in \Epoch, ~
    \var{c} \in \DCertRetirePool,~
    \var{penv} \in\PEnv \\[0.5ex]
    \quad s.t. ~~ \var{penv} \vdash p \trans{pool}{c} p' ~\wedge~
    e = \applyFun{retire}{c} ~\wedge~
    \var{cepoch} < e < (\var{cepoch} + \emax)
    ~\wedge~  \applyFun{cwitness}{c} = \var{hk}, \\[1ex]
    \quad\quad\var{hk}\in \applyFun{getStPools}(p')  ~\wedge~    \var{hk} \in  \fun{dom}(\applyFun{getStPools}{p})
    \\[1ex]
    \mathrm{where}~~\\
    \quad\quad p = \applyFun{pools}(\var{l}); ~~p' = \applyFun{pools}(\var{l'}); ~~e = \applyFun{getRetiring}{p'}
  \end{array}
  $$
  \label{prop:ledger-properties-10}
\end{property}

\noindent
Property~\ref{prop:ledger-properties-11} ensures that pools that are to be reaped
are associated with valid stake pool registration certificates and are due
to be retired during the current epoch, $\var{e}$. After reaping, these stake
pools are no longer available.

\begin{property}[\textbf{Stake Pool Reaping}]
  $$
  \begin{array}{l}
    \forall \var{l}, \var{l'} \in \ledgerState, ~\var{e} \in \Epoch, ~\var{pp}\in\PParams, ~\var{acnt}, \var{acnt'}\in\Acnt :  \applyFun{validLedgerstate}{l}\\
    \quad ~s.t.~ pp\vdash\var{(acnt, d, p)} \trans{poolreap}{e} \var{(acnt, d', p')}, \\
    \quad \quad \forall \var{retire}\in{(\fun{getRetiring}~p)}^{-1}[e], \\
    \quad\quad\quad \var{retire} \neq
    \emptyset \\ \quad \quad \quad \wedge~ \var{retire} \subseteq
    \fun{dom}(\applyFun{getStPool}{p}) ~\wedge~
    (\var{retire} \cap\fun{dom}(\applyFun{getStPool}{p'}))~=~\emptyset \\
    \quad\quad\quad \wedge~ (\var{retire} \cap \fun{dom}(\applyFun{getRetiring}{p'})) = \emptyset\\
    \mathrm{where}~~\\
    \quad\quad  l = (\wcard, (d, p)), ~l' = (\wcard, (d', p'))
  \end{array}
  $$
  \label{prop:ledger-properties-11}
\end{property}

% The following properties state the desired features of updating a valid ledger
% state. % Generalised above, I believe. KH

%% \begin{property}[\textbf{Preserve Balance}]
%%   \begin{multline*}
%%     \forall \var{l}, \var{l'} \in \LState: \applyFun{validLedgerstate}{l},
%%     l=(u,\wcard,\wcard,\wcard), l' = (u',\wcard,\wcard,\wcard)\\
%%     \implies \forall \var{tx} \in \Tx, lenv \in\LEnv, lenv \vdash\applyFun{utxo}(\var{l}) \trans{utxow}{tx} \applyFun{utxo}(\var{l'}) \\
%%     \implies \applyFun{destroyed}{pc~utxo~stkCreds~rewards~tx} =
%%     \applyFun{created}{pc~stPools~tx}
%%   \end{multline*}
%%   \label{prop:ledger-properties-1}
%% \end{property}

%% Property~\ref{prop:ledger-properties-1} states that for each valid ledger $l$,
%% if a transaction $tx$ is added to the ledger via the state transition rule UTXOW
%% to the new ledger state $l'$, the balance of the UTxOs in $l$ equals the balance
%% of the UTxOs in $l'$ in the sense that the amount of created value in $l'$
%% equals the amount of destroyed value in $l$. This means that the total amount of1
%% value is left unchanged by a transaction.

% \begin{property}[\textbf{Preserve Balance Restricted to TxIns in Balance of
%     TxOuts}]
%\khcomment{This definition was incorrect since it did not require l' to be valid.  With the new definition above, we can assume this from l.  I think it may not be important, though, so I have commented it out.}
%%   \begin{multline*}
%%     \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
%%     l=(u,\wcard,\wcard,\wcard), l' = (u',\wcard,\wcard,\wcard)\\
%%     \implies \forall \var{tx} \in \Tx, lenv \in\LEnv, lenv \vdash \var{u}
%%     \trans{utxow}{tx} \var{u'} \\
%%     \implies \fun{ubalance}(\applyFun{txins}{tx} \restrictdom
%%     \applyFun{getUTxO}{u}) = \fun{ubalance}(\applyFun{outs}{tx}) +
%%     \applyFun{txfee}{tx} + depositChange
%%   \end{multline*}
%%   \label{prop:ledger-properties-2}
% \end{property}

%% Property~\ref{prop:ledger-properties-2} states a slightly more detailed relation
%% of the balances change. For ledgers $l, l'$ and a transaction $tx$ as above, the
%% balance of the UTxOs of $l$ restricted to those whose domain is in the set of
%% transaction inputs of $tx$ equals the balance of the transaction outputs of $tx$
%% minus the transaction fees and the change in the deposit
%% $depositChange$~(cf.~Fig.~\ref{fig:rules:utxo-shelley}).

\khcomment{TODO: Add side conditions on transaction input/output domains to make the transaction properties triviailly true.}
  %% \subsection{Transaction Inputs/Outputs}

%% \begin{property}[\textbf{Transaction Output Preservation}]
%%   \khcomment{I think this is better done by using a side condition on the rules.}
%% %% $$
%% %%   \begin{array}{l}
%% %%     \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
%% %% %    l=(u,\wcard,\wcard,\wcard), l' = (u',\wcard,\wcard,\wcard)\\
%% %%     \forall \var{tx} \in \Tx, \var{lenv} \in\LEnv,\\
%% %%     \begin{array}{ll}
%% %%       &\var{lenv} \vdash \applyFun{utxo}(\var{l}) \trans{utxow}{tx} \applyFun{utxo}(\var{l'}) \\
%% %%       \implies & \forall \var{out} \in \applyFun{txouts}{tx}, out \in \applyFun{getUTxO}{l'}
%% %%       \end{array}
%% %%   \end{array}
%% %% $$
%%   \label{prop:ledger-properties-3}
%% \end{property}

%% \noindent
%% Property~\ref{prop:ledger-properties-3} states that for all ledger states
%% $l, l'$ and transaction $tx$ as above, all $tx$ output UTxOs are also contained in the UTxO
%% set of $l'$, that is they are available for further allocation. % , i.e., they are now available as unspent transaction output. %% This is an oxymoron isn't it? utxo means unspent.. :)
%% \khcomment{using undefined utxo function above, not sure what getUTxO does...  It might be possible to use the same function name.}

%% \begin{property}[\textbf{Transaction Input Elimination}]
%%   \khcomment{I think this is better done by using a side condition on the rules.}
%% %% $$
%% %%  \begin{array}{l}
%% %%     \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
%% %% %    l=(u,\wcard,\wcard,\wcard), l' = (u',\wcard,\wcard,\wcard)\\
%% %% %    \implies
%% %%     \forall \var{tx} \in \Tx, \var{lenv} \in\LEnv, \var{lenv} \vdash \var{u}, \\
%% %%     \begin{array}{ll}
%% %%       &\var{lenv} \vdash \applyFun{utxo}(\var{l}) \trans{utxow}{tx} \applyFun{utxo}(\var{l'}) \\
%% %%       \implies & \forall \var{in} \in \applyFun{txins}{tx}, out \in \applyFun{getUTxO}{l'}
%% %%       \end{array}
%% %% %      \trans{utxow}{tx} \var{u'} \implies \forall \var{in} \in
%% %% %    \applyFun{txins}{tx}, in \not\in \fun{dom}(\applyFun{getUTxO}{u'})
%% %%  \end{array}
%% %%  $$
%%   \label{prop:ledger-properties-4}
%% \end{property}

%% Property~\ref{prop:ledger-properties-4} states that for all ledger states
%% $l, l'$ and transaction $tx$ as above, no transaction input $in$ of $tx$ is
%% in the UTxO for $l'$, i.e., these inputs are no longer available to
%% spend.
%% \khcomment{I would like to say: ``Collectively, Properties~\ref{prop:ledger-properties-3} and~\ref{prop:ledger-properties-4},
%%   enforce \emph{linearity}: each input is used precisely once.''  However, this is only true if UTXOW is linear.
%% If it is not, then these seem to be very weak consistency checks.  A side-condition on the rules would probably enforce this.}


%% \begin{property}[\textbf{Completeness and Collision-Freeness of new Transaction
%%       Ids}]
%%   \khcomment{I think this is better done by using a side condition on the rules.}
%% %%   \begin{multline*}
%% %%     \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
%% %%     l=(u,\wcard,\wcard,\wcard), l' = (u',\wcard,\wcard,\wcard)\\
%% %%     \implies \forall \var{tx} \in \Tx, \var{lenv} \in\LEnv, \var{lenv} \vdash \var{u}
%% %%     \trans{utxow}{tx} \var{u'} \\ \implies \forall ((txId', \wcard) \mapsto
%% %%     \wcard) \in \applyFun{outs}{tx}, ((txId, \wcard) \mapsto \wcard)
%% %%     \in\applyFun{getUTxO}{u} \implies \var{txId'} \neq \var{txId}
%% %%   \end{multline*}
%% %%   \label{prop:ledger-properties-5}
%% \end{property}

%% %% Property~\ref{prop:ledger-properties-5} states that for ledger states $l, l'$
%% %% and a transaction $tx$ as above, the UTxOs of $l'$ contain all newly created
%% %% UTxOs and the referred transaction id of each new UTxO is not used in the UTxO
%% %% set of $l$.

\subsubsection{Delegation Properties}
\label{sec:ledg-prop-deleg}

\begin{property}[\textbf{Registered Staking Credential with Zero Rewards}]
  \begin{multline*}
    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
    l = (\wcard, ((d, \wcard), \wcard)), l' = (\wcard, ((d',\wcard), \wcard)), dEnv\in\DEnv \\
    \implies \forall \var{c} \in \DCertRegKey, dEnv\vdash \var{d}
    \trans{deleg}{c} \var{d'} \implies \applyFun{cwitness}{c} = \var{hk}\\
    \implies hk\not\in \fun{getStDelegs}~\var{d} \implies \var{hk} \in
    \applyFun{getStDelegs}{d'} \wedge
    (\applyFun{getRewards}\var{d'})[\fun{addr_{rwd}}{hk}] = 0
  \end{multline*}
  \label{prop:ledger-properties-6}
\end{property}

Property~\ref{prop:ledger-properties-6} states that for each valid ledger state
$l$, if a delegation transaction of type $\DCertRegKey$ is executed, then in the
resulting ledger state $l'$, the set of staking credential of $l'$ includes the
credential $hk$ associated with the key registration certificate and the
associated reward is set to 0 in $l'$.

\begin{property}[\textbf{Deregistered Staking Credential}]
  \begin{multline*}
    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
    l = (\wcard, (d, \wcard)), l' = (\wcard, (d', \wcard)), dEnv\in\DEnv \\
    \implies \forall \var{c} \in \DCertDeRegKey, dEnv\vdash\var{d}
    \trans{deleg}{c} \var{d'} \implies \applyFun{cwitness}{c} = \var{hk}\\
    \implies \var{hk} \not\in \applyFun{getStDelegs}{d'} \wedge hk\not\in
    \left\{ \fun{stakeCred_{r}}~sc\vert
      sc\in\fun{dom}(\applyFun{getRewards}{d'})
    \right\}\\
    \wedge hk \not\in \fun{dom}(\applyFun{getDelegations}{d'}))
  \end{multline*}
  \label{prop:ledger-properties-7}
\end{property}

Property~\ref{prop:ledger-properties-7} states that for $l, l'$ as above but
with a delegation transition of type $\DCertDeRegKey$, the staking credential
$hk$ associated with the deregistration certificate is not in the set of staking
credentials of $l'$ and is not in the domain of either the rewards or the
delegation map of $l'$.

\begin{property}[\textbf{Delegated Stake}]
  \begin{multline*}
    \forall \var{l}, \var{l'} \in \ledgerState: \applyFun{validLedgerstate}{l},
    l = (\wcard, (d,\wcard)), l' = (\wcard, (d',\wcard)), dEnv\in\DEnv \\
    \implies \forall \var{c} \in \DCertDeleg, dEnv \vdash\var{d}
    \trans{deleg}{c} \var{d'} \implies \applyFun{cwitness}{c} = \var{hk}\\
    \implies \var{hk} \in \applyFun{getStDelegs}{d'} \wedge
    (\applyFun{getDelegations}{d'})[hk] = \applyFun{dpool}{c}
  \end{multline*}
  \label{prop:ledger-properties-8}
\end{property}

Property~\ref{prop:ledger-properties-8} states that for $l, l'$ as above but
with a delegation transition of type $\DCertDeleg$, the staking credential $hk$
associated with the deregistration certificate is in the set of staking
credentials of $l$ and delegates to the staking pool associated with the
delegation certificate in $l'$.

\begin{property}[\textbf{Genesis Keys are Always All Delegated}]
  \label{prop:genkeys-delegated}
  \begin{multline*}
    \forall \var{l}, \var{l'} \in \LState: \applyFun{validLedgerstate}{l},\\
    \implies \forall \Gamma \in \seqof{\Tx},
    \var{env} \in (\Slot \times \PParams), \\
    \var{env} \vdash\var{l} \trans{ledgers}{\Gamma} \var{l'} \implies |genDelegs| = \var{genesis-nodes}
  \end{multline*}
\end{property}

Property \ref{prop:genkeys-delegated} states that all seven of the genesis keys
are constantly all delegated after applying a list of transactions to a valid ledger
state.

\subsection{Protocol Update Properties}

The following properties govern protocol updates.  We start by giving some basic definitions.  Here \var{UPDState} represents

\begin{definition}[\textbf{Protocol Update Parameters}]
  $$
  \begin{array}{l}
    \var{genesis-nodes}, \var{quorum} \in \cal{N}\\
    \var{quorum} \le \var{genesis-nodes} \\
%    \var{pp} \in \cal{PP} \\
    \var{UPDState} \in \{ \var{AVUpdate}  \in \cal{N}, \var{PPUpdate} \in \cal{N} \} \\
    \var{upd} \in \var{UPDState}
  \end{array}
  $$
\end{definition}

At present, \var{genesis-nodes}~=~7 and \var{quorum}~=~5.

\begin{property}
  There can be at most one change to the protocol parameters per epoch. Moreover, the protocol parameter update state, \var{upd}, is always empty at the beginning of the epoch: $\var{upd} = \emptyset$.
\end{property}

\begin{proof}[Proof Sketch]
  A change to the protocol parameters can only be made if the parameter update state is empty ($\var{upd} = \emptyset$).  When the parameters are changed, the state becomes non-empty ($\var{upd} \ne \emptyset$).
  \var{upd} is set to $\emptyset$ at the start of the epoch.
\end{proof}

%% Not needed?  KH
% \begin{property}
%   If there are no pending future application versions, there will not be a change to the version for at least SlotsPerEpoch.
% \end{property}

%% Not worth checking? KH
\begin{property}
  Updating the software version does not, by itself, change the transition system.
\end{property}
  % Note that changes to the transition system resulting from a new protocol version will be difficult to state formally, since this depends on logic in the software changing the ledger rules.

\begin{proof}[Proof Sketch]
  The proof follows from the fact that all changes to the transition system require a change in the protocol version.
\end{proof}

\begin{property}
  If fewer than \var{quorum} keys are active, there will be no application version or protocol parameter updates.
\end{property}

\begin{proof}[Proof Sketch]
  The proof follows from the fact that all parameter changes must be signed by at least \var{quorum} keys.
\end{proof}

%% Not worth stating?  KH
% Property The keys (of type Slot) of the following two mappings are always past the current slot: the future application versions (favs) and the future genesis delegation mapping (fGenDelegs). The favs slots can appear in any current or future epoch, but the fGenDelegs slots can be at most one epoch into the future.

\begin{property}
  The number of protocol parameter and application version updates are bounded by the number of genesis nodes.\khcomment{Not sure I quite understand this!}
  $$
  \begin{array}{lcl}
    | \var{PPUpdate} | & < & \var{genesis-nodes} \\
    | \var{AVUpdate} | & \le & \var{genesis-nodes}
  \end{array}
  $$
\end{property}


\clearpage
\subsection{Correctness of Refund and Reward Calculations}
\label{sec:prop-numer-calc}

The numerical calculations for refunds and rewards in
(see Section~\ref{sec:epoch}) are also required to have certain properties. In
particular we need to make sure that the functions that use non-integral
arithmetic have properties which guarantee consistency of the system. Here, we
state those properties and formulate them in a way that makes them usable in
properties-based testing for validation in the executable spec.

\begin{property}[\textbf{Minimal Refund}]
  \label{prop:minimal-refund}

  The function $\fun{refund}$ takes a value, a minimal percentage, a decay
  parameter and a duration. It must guarantee that the refunded amount is within
  the minimal refund (off-by-one for rounding / floor) and the original value.

  \begin{multline*}
    \forall d_{val} \in \mathbb{N}, d_{min} \in [0,1], \lambda \in (0, \infty),
    \delta \in \mathbb{N} \\
    \implies \max(0,d_{val}\cdot d_{min} - 1) \leq \floor*{d_{val}\cdot(d_{min} +
      (1-d_{min})\cdot e^{-\lambda\cdot\delta})} \leq d_{val}
  \end{multline*}
\end{property}

\begin{property}[\textbf{Maximal Pool Reward}]
  \label{prop:maximal-pool-reward}

  The maximal pool reward is the expected maximal reward paid to a stake
  pool. The sum of all these rewards cannot exceed the total available reward,
  let $Pool$ be the set of active stake pools:

  \begin{equation*}
    \forall R \in Coin:\sum_{p \in Pools} \floor*{\frac{R}{1+p_{a_{0}}}\cdot
      \left(
        p_{\sigma'}+p_{p'}\cdotp_{a_{0}}\cdot\frac{p_{\sigma'}-p_{p'}\cdot\frac{p_{z_{0}}-p_{\sigma'}}{p_{z_{0}}}}{p_{z_{0}}}
      \right)}\leq R
  \end{equation*}
\end{property}

\begin{property}[\textbf{Actual Reward}]
  \label{prop:actual-reward}

  The actual reward for a stake pool in an epoch is calculated by the function
  $\fun{poolReward}$. The actual reward per stake pool is non-negative and
  bounded by the maximal reward for the stake pool, with $\overline{p}$ being
  the relation $\frac{n}{\max(1, \overline{N})}$ of the number of produced
  blocks $n$ of one pool to the total number $\overline{N}$ of produced blocks
  in an epoch and $maxP$ being the maximal reward for the stake pool. This gives
  us:

  \begin{equation*}
    \forall \gamma \in [0,1] \implies 0\leq \floor*{\overline{p}\cdot maxP} \leq maxP
  \end{equation*}
\end{property}

The two functions $\fun{r_{operator}}$ and $\fun{r_{member}}$ are closely related as
they both split the reward between the pool leader and the members.

\begin{property}[\textbf{Reward Splitting}]
  \label{prop:reward-splitting}

  The reward splitting is done via $\fun{r_{operator}}$ and $\fun{r_{member}}$, i.e.,
  a split between the pool leader and the pool members using the pool cost $c$
  and the pool margin $m$. Therefore the property relates the total reward
  $\hat{f}$ to the split rewards in the following way:

  \begin{multline*}
    \forall m\in [0,1], c\in Coin \implies c + \floor*{(\hat{f} - c)\cdot (m +
      (1 - m)) \cdot \frac{s}{\sigma}} + \sum_{j}\floor*{(\hat{f} -
      c)\cdot(1-m)\cdot\frac{t_{j}}{\sigma}} \leq \hat{f}
  \end{multline*}

\end{property}

\noindent
Reward calculations are described in detail in~\cite{deleg_design,ledger_rewards}.

\clearpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "ledger-spec"
%%% End:
<

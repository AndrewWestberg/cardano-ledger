\section{Introduction}

\TODO{Please run a spell checker over the final document}
\TODO{Please fix up all missing references}

This document describes the extensions to the multi-asset formal ledger specification~\ref{XX} \TODO{Fix this reference} that are
required for the support of non-native scripts, in particular Plutus Core. This underpins future Plutus development: there should be minimal or no changes to these ledger rules to support new Plutus requirements.
%
The two major extensions that are described here are:
\begin{inparaenum}
\item
the introduction
of \emph{non-native} scripts, i.e. scripts that are not evaluated internally by the ledger; and
\item
  additions to the Shelley-era UTxO (unspent transaction output) model that are needed to support Plutus
  constructs (the ``extended UTxO'' model).
\end{inparaenum}
This document defines these extensions as changes to the multi-asset structured transition system,
using the same notation and conventions that were used for the multi-asset specification~\cite{XX}.\TODO{Add this reference!!}
As with the multi-asset formal specification, these rules will be implemented in the form of an executable ledger specification that will then be
integrated with the Cardano node.

\subsection{Non-Native Scripts}

The Shelley formal specification introduced the concept of ``multi-signature'' scripts.
\emph{Native scripts}, such as these, are captured entirely by the ledger rules.
Execution costs can therefore be easily assessed \emph{before} they are processed by the implementation,
and any fees can be calculated directly within the ledger rule implementation,
based on e.g. the size of the transaction that includes the script.

In contrast, \emph{non-native} scripts can perform arbitrary
(and, in principle, Turing-complete) computations.
In order to bound execution costs to a pre-determined constant, we use a standard ``fuel'' approach~\cite{XX}.\TODO{And this one, please!}
We require transactions that use non-native scripts
to have a budget in terms of a number of abstract $\ExUnits$.
This budget gives a quantitative bound on resource usage in terms of a number of specific metrics, including memory usage or abstract execution steps.
The budget is then used as part of the concrete transaction fee calculation.
\khcomment{Implies that the budget is a parameter in the fee calculation?  Is that right?  Maybe say that if so.}

Every scripting language
converts the calculated execution cost into a number of $\ExUnits$s using a cost model,
$\CostMod$, which is provided as a protocol parameter.
This allows execution costs (and so transaction fees) to be varied without requiring a major protocol version change (``hard fork'').
This may be used, for example, if a more efficient interpreter is produced.
%% Rather confusing -- KH
% vary the number $\ExUnits$ required to
% run the same computation without a hard fork (for example, because a
% more efficient interpreter was introduced),

\subsection{Extended UTxO}

The specification of the extended UTxO model follows the description that was given in~\cite{plutus_eutxo}.
All transaction outputs that are locked by non-native scripts must include the hash for an additional ``data'' item.  The actual data item needs to be supplied in the body of the transaction,  \khcomment{Is this correct?} and can be used to encode state, for example.
While this data item could instead have been stored directly in the UTxO, our choice of storing it in the transaction body improves space efficiency in the implementation by reducing the UTxO storage requirements. The actual data item is passed to a script that validates that the output is spent correctly.
All transactions also need to supply a \emph{redeemer} for all items that are validated by a script.  This is an additional piece of data that is passed to the script, and that could be considered as a form of user-input to the script. Note that the same script could be used for multiple different purposes in the same transaction, so in general it might be necessary to include more than one redeemer per script.
There will, of course, always be at least one redeemer per script.  \khcomment{confirm this}

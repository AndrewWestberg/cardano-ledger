\begin{figure*}[t!]
  %
  \emph{Scripts}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}

    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{lng} & \Language & \N \\
      %\text{script language}
      \var{cid} & \CurrencyID & \PolicyID\\
%       \var{pid} & \PolicyID & \PolicyID\\
       % \text{currency ID}\\
      \var{tok} & \AssetID & \mathbb{H}\\
       % \text{token identifier}\\
      \var{quan} & \Quantity & \Z \\
      %\text{quantity of a token}\\
      \var{v}, \var{w} & \Value
      & \CurrencyID \mapsto ( \AssetID \mapsto \Quantity ) \\
%      & \text{a collection of tokens}
      \var{txout}
      & \TxOut
      & \Addr \times \Value
%      & \text{tx outputs}
      \\
      \var{utxoout}
      & \UTxOOut
      & \Addr \times \Value \\
%      & \text{utxo outputs}
      \var{utxo}
      & \UTxO
      & \TxIn \to \UTxOOut
%      & \text{unspent tx outputs}
    \end{array}
  \end{equation*}
  %
  \caption{Type Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}

\section{Transactions}
\label{sec:transactions}

This section describes the changes that are necessary to the transaction and
UTxO type structure to support native multicurrency functionality
in Cardano.

\subsection*{Representing Multi-currency Types and Values.}
Some new types (and some changes to existing types) are required for
the ledger to support multi-currencies, as shown in Figure~\ref{fig:defs:utxo-shelley-1}.
All other types are as specified in the Shelley ledger design and implementation~\ref{...}.
A \emph{Currency}, $\mathit{Currency}$, comprises a set of different \emph{Asset Classes}, each of which has
a unique identifier, $\AssetID$  (of type $\mathbb{H}$, that is \emph{arbitrary length byte strings}). We will informally refer to these identifiers as ``tokens''.
The set of tokens that are referred to by the underlying monetary policy represents the coinage that the currency supports.  A multi-currency value, $\Value$ is a map over zero or more currencies
to single currency values.  A single currency value is then a finite map from
$\AssetID$s to quantities.  Any omitted tokens in the domain of a currency are assumed to be zero.

$$
 \begin{array}{lcl}
   \var{token} \in \mathit{Coinage} &=& \{ \AssetID \}
%% % \\
%% % v, w \in \mathit{Value} &=& \{ \AssetID \mapsto \Quantity \}
\end{array}
$$

%% I'm going to leave this for now.  It would be  nice.
%% Currency values support arithmetic and equality operations in the obvious way.  They do not, of course, support general
%% comparisons ($<$, $>$, etc).  We extend the

%% $$
%% \begin{array}{lcl}
%%   v \oplus w &=&  \forall (c_1 \mapsto t_1)

%%   (a \arrow \_) \in (\var{coins} v \cup \var{coins} w),~~ a \arrow (v a \oplus w a), \var{currency} v = \var{currency} w \\
%%   \var{currency} ( c \mapsto \_ ) & = & c \\
%%   \var{coins}    ( \_ \mapsto \var{tkns}) & = & \var{dom} (\var{tkns})
%% \end{array}
%% $$

\begin{itemize}

  \item $\Language$ is a natural number that labels the type scripting language, e.g.
    $\mathsf{nativeMSigTag}$ or $\mathsf{nativeMCTag}$. \khcomment{Why a number rather than a symbolic label/identifier - ordering
    and arithmetic are not needed, are they, and you might need to worry about bounding?}

  \item $\CurrencyID$ identifies a specific currency.  As in normal life, two
    currencies may use the same \emph{coinage} (sets of tokens that distinguish different values in the currency),
    but are distinguished by their \emph{monetary policy}, which governs how values of the currency may be created,
    exchanged, destroyed etc.
    The monetary
    policy for a currency $\var{cid}$ is given by the \emph{Monetary Policy Script}
    (MPS) $s$, where $\fun{hashScript}~s~=~cid$. When executed, the script verifies that the coinage for currency $\var{cid}$
    respects the restrictions that are imposed by the
    monetary policy. If the restrictions are complied with, it returns
    $\mathsf{True}$, and
    $\mathsf{False}$ otherwise.  Monetary Policy Scripts are described in more detail below.
\khcomment{I need to re-read this - I have a question about when things are executed.}

%% \item $\PolicyID$ identifies a specific monetary policy.  Each monetary policy is distinct. The monetary
%%   policy for a currency $\var{c} = \{ \var{tok_1} \ldots \var{tok}_n \}$ is given by the \emph{Monetary Policy Script}
%%   (MPS) $s$, such that $\fun{hashScript}~s~=~pid$. The script is called a
%%   monetary policy script because when run, it verifies that the tokens of a currency
%%   with the corresponding $\var{cid}$ are according to the restrictions imposed by the
%%   monetary policy. If the restrictions are complied with, it returns
%%   $\mathsf{True}$, and
%%   $\mathsf{False}$ otherwise.  Monetary Policy Scripts are described in more detail below.


\item $\AssetID$ : the coinage for a currency $\var{cid} \in \var{CurrencyID}$ is a set of terms
  $t\in\AssetID$.  Each $t$ identifies a unique kind of token in $\var{cid}$. Within a single currency $\var{cid}$,
  tokens of the same type (i.e. those with the same identifier $t\in\AssetID$) are \emph{fungible}
  with each other. That is, they are completely interchangeable, in the same way that
  every Ada coin in the standard Shelley specification is indistinguishable from any other Ada coin.
  We will assume that Ada has the currency ID $\mathsf{adaID}$, and its coinage contains the single token $\mathsf{adaToken}$.

  %%
  %% The statement \textit{all of the tokens
  %% of this currency must
  %% be the same}, in a MC scheme, means that there is only one kind of term of
  %% type $\AssetID$ associated
  %% with $\mathsf{adaID}$, and we call it $\mathsf{adaToken}$. \khcomment{The meaning of the statement isn't clear to me.}
  %% See below for a more detailed discussion of Ada representation.

  Note that multiple currencies may support tokens which have the same names, but which are not interchangeable.
  For example, a new currency $\mathsf{NotAda}$ can also have an $\mathsf{adaToken}$.
  This is not the same token as the one in $\mathsf{adaID}$, and the two tokens are therefore not fungible with each other.

  \item $\Quantity$ is an integer type that represents an amount of a specific $\AssetID$. We associate
  a term $q\in\Quantity$ with a specific token to track how much of   that token is contained in a given currency value.

  \item $\Value$ is the multicurrency type that is used to represent
    the value of all tokens, including Ada.
    % The key of this finite map type is
  %   the hash of the monetary policy script for this currency.
  A value $v\in\Value$ is a finite map from zero or more currencies to single currency values $\var{tkns}\in\AssetID \mapsto \Quantity$.
  This represents the values of all the tokens that are contained in $v$.

%  The $tkns$ map gives the quantity of tokens of type $t\in\AssetID.
%  Values in the same currency are fungible with each other if
%  they have the same asset id $\AssetID$.
  %% You don't have the notion of a token defined as currency, token pair, so this definition doesn't work.
  %% Best not to give it - it's hard to work out.

\item $\TxOut$ : The type of outputs that carried by a transaction. This differs from the base Shelley
  $\TxOut$ type in that it contains a $\Value$ rather than a $\Coin$

  \item $\UTxOOut$ is the type of UTxO entry that is created when a transaction
  output is processed. This has the same structure as
  the transaction output $\TxOut$, but is given a different name to
  account for the fact that $\Value$ is stored differently in the outputs of $\UTxO$ and $\Tx$
  (due to optimization in the $\UTxO$).


  \item $\UTxO$ entries are stored in the finite map $\TxIn\mapsto \UTxOOut$
  (this type also differs from the Shelley $\UTxO$ type in \khcomment{How?}).

\end{itemize}

\begin{figure*}[t!]
  %% \emph{Script Types} \quad
  %% %
  %% \begin{equation*}
  %%   \begin{array}{r@{~\in~}l@{~}lr}
  %%     \var{smc} & \ScriptMPS & \text{monetary policy script} \\
  %%     \var{scr} & \Script &=~ \ScriptMSig \uniondistinct \ScriptMPS
  %%   \end{array}
  %% \end{equation*}
    %
    \emph{Helper Functions}
  %
  \begin{align*}
    \fun{language} ~\in~& \Script \to \Language \\
    &\text{returns the language tag, e.g. $\mathsf{mcTag}$ for the MPS language}
    % \\
%   \caption{Languages}
  \end{align*}
  %
  \emph{MPS Script definition}
  %
  \begin{equation*}
    \begin{array}{rllll}
 %     \ScriptMPS & \subseteq & \Script \\
 %     \\~\\
      \var{s_{mc}}\in\ScriptMPS & = & \powerset{} & ( & \ScriptMSig\\
      &  & & & \uniondistinct ~~
         (\AssetID \mapsto (\Slot\times\Slot\times\Quantity\times\Quantity))~~) \\
%       & \uniondistinct&
%         \powerset{\ScriptMPS}
    \end{array}
  \end{equation*}
  %
  \emph{Language Tags}
  %
  \begin{align*}
%    & s_{mc} & ~\in~ \ScriptMPS \\
    & \mathsf{nativeMCTag} & ~=~ \fun{language}~s_{mc}
    \end{align*}
  \caption{The Multicurrency Scripting Language}
  \label{fig:defs:tx-mc-script}
  %% \emph{Script Types}
  %% %
  %% \begin{equation*}
  %%   \begin{array}{r@{~\in~}l@{~}lr}
  %%     \var{smc} & \ScriptMPS & \text{monetary policy script} \\
  %%     \var{scr} & \Script &=~ \ScriptMSig \uniondistinct \ScriptMPS
  %%   \end{array}
  %% \end{equation*}
  %%   %
  %% \emph{Helper Functions}
  %% %
  %% \begin{align*}
  %%   \fun{language} ~\in~& \Script \to \Language \\
  %%   &\text{returns the language tag, e.g. $\mathsf{mcTag}$ for the MPS language} \\
  %% \caption{Languages}
  %% \end{align*}
  %% %
  %% \emph{MPS Script definition}
  %% %
  %% \begin{equation*}
  %%   \begin{array}{rll}
  %%     \ScriptMPS & \subseteq & \Script \\
  %%     \\~\\
  %%     \var{s_{mc}}\in\ScriptMPS & = & \type{JustMSig}~ \ScriptMSig\\
  %%     & \uniondistinct &
  %%        \type{MaxMinTimedTotal}~(\AssetID \mapsto (\Slot\times\Slot\times\Quantity\times\Quantity)) \\
  %%     & \uniondistinct&
  %%       \type{RequireAll}~\powerset{\ScriptMPS}
  %%   \end{array}
  %% \end{equation*}
  %% \caption{The Multicurrency Scripting Language}
  %% \label{fig:defs:tx-mc-script}
\end{figure*}

\paragraph*{The Monetary Policy Scripting Language.}
Recall that a currency is identified by the hash of its MPS.
Figure~\ref{fig:defs:tx-mc-script} gives the types that relate to monetary
policy scripts. % The $\Script$ type
% is made up of multisig scripts and monetary policy scripts.
As discussed below, the monetary policy script type, $\ScriptMPS$, groups multisig scripts
and resourced scripts.
% has several constructors, each of which
% is used in a different way during script evaluation
The abstract
function $\fun{language}$ returns a value of type $\type{Language}$,
corresponding to the language that is used by a given script.

\paragraph*{Multicurrency Script Evaluation.}
A monetary policy is a collection of restrictions on the tokens of a
specific multicurrency. MP scripts are evaluated for the purpose of checking that
the given currency adheres to its monetary policy. The monetary policy scripting
language is a basic scripting language that
allows for expressing some of the most common restrictions, e.g.
the maximum total number of different kinds of tokens of a given currency.
A suggestion for $\ScriptMPS$ and the implementation of the function
$\fun{evalMPSScript}$, which evaluates MPS scripts, is given in
Appendix~\ref{sec:mps-lang}. As inputs, $\fun{evalMPSScript}$ takes

\begin{itemize}
\item the script getting evaluated
\item the currency ID of the currency being forged
\item the current slot number,
\item a set of key hashes (needed to use MSig scripts as MPS scripts)
\item the transaction body
\item the inputs of the transaction as a UTxO finite map (with addresses and values),
i.e. the outputs it is spending
\end{itemize}


\subsection*{MPS Script Validation.}

In the Shelley ledger specification, a script validation function
is used to evaluate all types of native (ledger-rule-defined) scripts.
In Figure~\ref{fig:defs:tx-mc-valid}, we modify this function to also call the
evaluation function that is specific to our new MPS script type.

The arguments that are passed to the $\fun{validateScript}$ function include all those
needed for MPS and MSig script evaluation. Because of the extra arguments
(the slot number and the UTxO), we also modify the call to this function
within the UTXOW rule.

\begin{figure*}[htb]
    \begin{align*}
      \fun{validateScript} & \in\Script\to\PolicyID\to\Slot\to
      \powerset{\KeyHash}\to\TxBody\to\UTxO\to\Bool \\
      \fun{validateScript} & ~s~\var{cid}~\var{slot}~\var{vhks}
       ~\var{txb}~\var{spentouts} =
                             \begin{cases}
                               \fun{evalMultiSigScript}~s~vhks & \text{if}~s \in\MSig \\
                               \fun{evalMPSScript}~s~\var{cid}~\var{slot}~\var{vhks} \\
                                ~~~~txb~\var{utxo} & \text{if}~s \in\ScriptMPS \\
                               \mathsf{False} & \text{otherwise}
                             \end{cases} \\
    \end{align*}
  \caption{Script Validation}
  \label{fig:defs:tx-mc-valid}
\end{figure*}

\subsection*{The Forge Field.}

The body of a transaction with multicurrency support contains one additional
field, the $\fun{forge}$ field (see Figure~\ref{fig:defs:utxo-shelley-2}).
The $\fun{forge}$ field is a term of type $\Value$, which contains
tokens the transaction is putting into circulation or taking out of
circulation. Here, by "circulation", we mean specifically "the UTxO on the
ledger". Since the administrative fields cannot contain tokens other than Ada,
and Ada cannot be forged, they are not affected in any way by forging.

Putting tokens into circulation is done with positive values in the $\Quantity$
fields of the tokens forged, and taking tokens out of circulation can be done
with negative quantities.

A transaction cannot simply forge arbitrary tokens. Recall that restrictions on
MC tokens are imposed, for each currency with ID $\var{cid}$, by the script
with the hash $\var{cid}$. Whether a given currency adheres to the restrictions
prescribed by its script is verified at forging time (i.e. when the transaction
forging it is being processed). Another restriction on forging is imposed by
the preservation of value conditition. Also, no forging Ada
is permitted. In Section~\ref{sec:utxo}, we specify the mechanism by which
forging is done, and rules which enforce these restrictions.

\subsection*{Transaction Body.}

Besides the addition of the $\fun{forge}$ field to the transaction body,
note that the $\TxOut$ type in the body is not the same as
the $\TxOut$ in the system without multicurrency support. Instead of
$\Coin$, the transaction outputs now have type $\Value$.

The only change to the types related to transaction witnessing is the addition
of MPS scripts to the $\Script$ type, so we do not include the whole $\Tx$ type here.

\begin{figure*}[htb]
  \emph{Transaction Type}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txbody} ~\in~ \TxBody ~=~
      & \powerset{\TxIn} & \fun{txinputs}& \text{inputs}\\
      &\times ~(\Ix \mapsto \TxOut) & \fun{txouts}& \text{outputs}\\
      & \times~ \seqof{\DCert} & \fun{txcerts}& \text{certificates}\\
       & \times ~\Value  & \fun{forge} &\text{value forged}\\
       & \times ~\Coin & \fun{txfee} &\text{non-script fee}\\
       & \times ~\Slot & \fun{txttl} & \text{time to live}\\
       & \times~ \Wdrl  & \fun{txwdrls} &\text{reward withdrawals}\\
       & \times ~\Update  & \fun{txUpdates} & \text{update proposals}\\
       & \times ~\MetaDataHash^? & \fun{txMDhash} & \text{metadata hash}\\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{getValue} & \TxOut \uniondistinct \UTxOOut \to \Value & \text{output value} \\
      \fun{getAddr} & \TxOut \uniondistinct \UTxOOut \to \Addr & \text{output address} \\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}

\subsection*{Coin and Multicurrency Tokens}
When multicurrency is introduced, Ada is still expected to be
the most common type of token on the ledger.
The $\Coin$ type is used to represent an amount of Ada.
It is the only
type of token which can be used for all non-UTxO ledger accounting, including deposits,
fees, rewards, treasury, and the proof of stake protocol. Under no circumstances
are these administrative fields and calculations ever expected to operate on
any types of tokens besides Ada. These fiels will continue to have the type $\Coin$.

The exact representation of tokens in the UTxO and inside transactions
is an implementation detail, which we omit here.
Note that it necessarily is equivalent to $\Value$, optimized
for Ada-only cases, has a unique representation for Ada tokens,
and does not allow Ada to have tokens denoted by anything other than $\mathsf{adaToken}$.

In Figure \ref{fig:defs:functions-helper} we give the following helper functions
and constants, needed for using Ada in a multicurrency setting.

\begin{itemize}
  \item $\mathsf{adaID}$ is a random script hash value with no known associated
  script. It is the currency ID of Ada. Even if a
  script that hashes to this value
  and validates is found, the UTXO rule forbids forging Ada
  \item $\mathsf{adaToken}$ is a byte string representation of the word "Ada".
  The ledger should never allow the use of any other token name associated
  with Ada's currency ID
  \item $\fun{qu}$ and $\fun{co}$ are type conversions from quantity to
  coin. Both of these types are synonyms for $\Z$, so they are
  type re-naming conversions that are mutual inverses, with

  $\fun{qu} ~(\fun{co} ~q )~= ~q$, and

  $\fun{co}~ (\fun{qu}~ c) ~=~ c$, for $c \in \Coin,~q \in \Quantity$.

  \item $\fun{coinToValue}$ takes a coin value and generates a $\Value$ type representation
  of it
\end{itemize}

An amount of Ada can also be represented as a multicurrency value
using the notation in Figure \ref{fig:defs:functions-helper}, as
$\fun{coinToValue}~c$ where $c \in \Coin$. We must use this representation
when adding or subtracting Ada and other tokens as $\Value$, e.g. in the
preservation of value calculations.

\begin{figure*}[htb]
  \emph{Abstract Functions and Values}
  %
  \begin{align*}
    \mathsf{adaID} \in& ~\PolicyID
    & \text{Ada currency ID} \\
    \mathsf{adaToken} \in& ~\AssetID
    & \text{Ada Token} \\
    \mathsf{co} \in& ~\Quantity \to \Coin
    & \text{type conversion} \\
    \mathsf{qu} \in& ~\Coin \to \Quantity
    & \text{type conversion} \\
  \end{align*}
  \emph{Helper Functions}
  %
  \begin{align*}
    \fun{coinToValue} \in & ~\Coin\to \Value \\
    \fun{coinToValue}~ c = & \{\mathsf{adaID} \mapsto \{\mathsf{adaToken} \mapsto \fun{qu}~c\}\} \\
    &\text{convert a Coin amount to a Value} \\
  \end{align*}
  \caption{Multicurrency}
  \label{fig:defs:functions-helper}
\end{figure*}

\clearpage

\section{UTxO}
\label{sec:utxo}

\subsection*{UTxO Helper Functions}

\begin{figure}[htb]
  \emph{Helper Functions}
  \begin{align*}
    & \fun{getCoin} \in \UTxOOut \to \Coin \\
    & \fun{getCoin}~{(\wcard,~\var{out})} ~=~\fun{co}~(\var{out}~\mathsf{adaID}~\mathsf{adaToken}) \\
    \nextdef
    & \fun{ubalance} \in \UTxO \to \Value \\
    & \fun{ubalance} ~ utxo = \sum_{\wcard\mapsto\var{u}\in~\var{utxo}}
    \fun{getValue}~\var{u} \\
    \nextdef
    & \fun{valueSize} \in \Value \to \N \\
    & \fun{valueSize}~\var{v} = k + k' * |\{ (\var{pid}, \var{aid}) : \var{v}~\var{pid}~\var{aid} \neq 0
      \land (\var{pid}, \var{aid}) \neq (\mathsf{adaID}, \mathsf{adaToken}) \}|
  \end{align*}
  %
  \emph{Produced and Consumed Calculations}
  \begin{align*}
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeCreds \to \Wdrl \to \TxBody \to \Value \\
    & \consumed{pp}{utxo}{stkCreds}{rewards}~{txb} = \\
    & ~~\ubalance{(\txins{txb} \restrictdom \var{utxo})} + \\
    &~~  \fun{coinToValue}(\fun{wbalance}~(\fun{txwdrls}~{txb})~+~ \keyRefunds{pp}{stkCreds}{txb}) \\
    &~~+~\fun{forge}~\var{txb} \\
    \nextdef
    & \fun{produced} \to \PParams \to \StakePools \to \TxBody \to \Value \\
    & \fun{produced}~\var{pp}~\var{stpools}~\var{txb} = \\
    &~~\ubalance{(\fun{outs}~{txb})} \\
    &~~+ \fun{coinToValue}(\txfee{txb} + \totalDeposits{pp}{stpools}{(\txcerts{txb})})\\
  \end{align*}
  \caption{UTxO Calculations}
  \label{fig:functions:utxo}
\end{figure}

Figure~\ref{fig:functions:utxo} defines additional calculations that are needed for the
UTxO transition system with multi-assets:

\begin{itemize}

  \item The function $\fun{getCoin}$ returns the Ada in a given output as a $\Coin$ value.

  \item
    The $\fun{ubalance}$ function calculates the sum total in a given UTxO,
    aggregated by $\PolicyID$ and $\AssetID$.

  \item The $\fun{valueSize}$ function provides a rough estimate of
    the amount of memory the storage of a certain value will consume.

  \item As in Shelley, the $\fun{consumed}$ calculation is the sum of: i) the values of the
   UTxO entries consumed; ii) the reward address value consumed;
   and iii) the amount that is removed from the deposit pot as a result of
   the transaction collecting the deposit refunds that are due. There is an additional
   summand in this calculation, namely the value forged by a transaction.
   This calculation now returns a $\Value$.

  \item The $\fun{produced}$ calculation sums the same values
  as its Shelley counterpart.
  This calculation also returns a $\Value$.
\end{itemize}

\subsection*{Produced and Consumed Calculations and Preservation of Value}
Note that because the outputs of a transaction, as well as UTxO
outputs, are of the $\Value$ type, the $\fun{consumed}$ and
$\fun{produced}$ calculations both have to produce a $\Value$. The
administrative amounts (of $\Coin$ type) thus have to be converted
into $\Value$.

While the preservation of value is a single
equality, it is really a comparison of token quantities aggregated by
$\AssetID$ and by $\PolicyID$. In particular, ensuring that the produced
amount equals the consumed amount also implies that the total quantity of
Ada tokens is preserved.

\subsection*{Forging and the Preservation of Value}
What does it mean to preserve the value of non-Ada tokens, since they
are put in and taken out of circulation by the users themselves?
This is expressed by including the $\fun{forge}$ value of the transaction
in the preservation of value equation.

The \textit{produced} side of the equation adds up, among other things, the
values in the
outputs that will be added to the ledger UTxO by the transaction. These outputs are
where the
forged value is "put into of circulation", i.e. how it ends up in the UTxO.
Suppose a transaction $tx$ contains a single output $(a, pid \mapsto tkns)$. Suppose
also that it does not
have any inputs spending any UTxO outputs with policy ID $pid$.

A valid transaction $tx$ satisfies the preservation of value
condition by adding the value $pid \mapsto tkns$ to the \textit{consumed} side as well.
To do this, the $tx$ declares that it is forging the tokens $pid \mapsto tkns$
via the $\fun{forge}$ field, i.e. $tx$ must have

\[pid \mapsto tkns\in\fun{forge}~tx\]

The forge field value is then added to the consumed side. This approach
to balancing the \emph{preservation of value} (POV) equation (Equation~\ref{eqn:pov}) extends
to cases where the transaction might also be consuming some existing $pid$ tokens,
or taking the out of circulation with negative quantities in the forge field.

The forge field value represents the change in total existing tokens of each given asset
as a result of processing the transaction. It is added to the
\textit{consumed} side of the POV equation, because the signs of the
quantities in the forge field match the signs of the change. Thus, to add tokens to the UTxO,
their quantities in the forge field are positive, and to
take them out of circulation, the signs are negative.

Note also that the UTXO rule only checks that the transaction is forging the
amount it has declared using the forge field, and that no Ada is forged.
The forging scripts themselves are not evaluated there, but instead
as part of witnessing, i.e. in the UTXOW rule, see Figure~\ref{fig:functions-witnesses}.

\subsection*{The UTXO Transition Rule}
In Figure \ref{fig:rules:utxo-shelley}, we give the UTXO transition rule,
updated for multi-asset support. There are the following changes to the preconditions
of this rule as compared to the original Shelley UTXO rule:

\begin{itemize}
  \item The transaction is not forging any Ada.

  \item All outputs of the transaction contain only non-negative quantities
  (this is the $\Value$-type version to the corresponding rule about non-negative
  $\Coin$ amounts in the Shelley ledger rules).

  \item In the preservation of value calculation (which looks the same as in
  Shelley), the value in the $\fun{forge}$ field is taken into account.
\end{itemize}

Note that updating the $\UTxO$ with the inputs and the outputs of the transaction
looks the same as in the Shelley rule, however, there is a type-level difference, as
the outputs of a transaction contain a $\Value$ term, rather than
$\Coin$. Moreover, the $\fun{outs}$ map converts $\TxOut$ terms into $\UTxOOut$.


\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \var{txb}\leteq\txbody{tx}
      & \txttl txb \geq \var{slot}
      \\ \txins{txb} \neq \emptyset
      & \minfee{pp}{tx} \leq \txfee{txb}
      & \txins{txb} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stkCreds}{rewards}~{txb} = \produced{pp}{stpools}~{txb}
      \\
      ~
      \\
      {
        \begin{array}{r}
          \var{slot} \\
          \var{pp} \\
          \var{genDelegs} \\
        \end{array}
      }
      \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
      \\
      ~
      \\
      \mathsf{adaID}~\notin \dom~{\fun{forge}~tx} \\
      ~\\
      \forall txout \in \txouts{txb}, ~ \fun{getValue}~txout  ~\geq ~ 0, \\~
      \fun{getCoin}~txout ~\geq ~\fun{valueSize}~(\fun{getValue}~txout) * \fun{minUTxOValue}~pp \\~
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp}
      \\
      ~
      \\
      \var{refunded} \leteq \keyRefunds{pp}{stkCreds}{txb}
      \\
      \var{depositChange} \leteq
        \totalDeposits{pp}{stpools}{(\txcerts{txb})} - \var{refunded}
    }
    {
      \begin{array}{r}
        \var{slot}\\
        \var{pp}\\
        \var{stkCreds}\\
        \var{stpools}\\
        \var{genDelegs}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{(\txins{txb} \subtractdom \var{utxo}) \cup \fun{outs}~{txb}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{txb}} \\
        \varUpdate{ups'}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}


\subsection*{Witnessing and Monetary Policy Script Validation}

\begin{figure}[htb]
  \begin{align*}
    \fun{scriptsNeeded} & \in \UTxO \to \Tx \to \powerset{\ScriptHash} \hspace{2cm} \text{required script hashes} \\
    \fun{scriptsNeeded} &~\var{utxo}~\var{tx} = \\
    & ~~\{ \fun{validatorHash}~a \mid i \mapsto (a, \wcard) \in \var{utxo},\\
    & ~~~~~i\in\fun{txinsScript}~{(\fun{txins~\var{txb}})}~{utxo}\} \\
    \cup & ~~\{ \fun{stakeCred_{r}}~\var{a} \mid a \in \dom (\AddrRWDScr
           \restrictdom \fun{txwdrls}~\var{txb}) \} \\
      \cup & ~~(\AddrScr \cap \fun{certWitsNeeded}~{txb}) \\
      \cup & ~~\dom~(\fun{forge}~{txb}) \\
      & \where \\
    & ~~~~~~~ \var{txb}~=~\txbody{tx} \\
    \nextdef
      \fun{validateScript} & \in\Script\to\ScriptHash\to\Slot\to
      \powerset{\KeyHash}\to\TxBody\to\UTxO\to\Bool \\
      \fun{validateScript} & ~s~\var{pid}~\var{slot}~\var{vhks}
       ~\var{txb}~\var{utxo} =
                             \begin{cases}
                               \fun{evalMultiSigScript}~s~vhks & \text{if}~s \in\ScriptMSig \\
                               \fun{evalMPSScript}~s~\var{pid}~\var{slot}~\var{vhks} \\
                                ~~~~txb~\var{utxo} & \text{if}~s \in\ScriptMPS \\
                               \mathsf{False} & \text{otherwise}
                             \end{cases} \\
  \end{align*}
  \caption{Scripts Needed}
  \label{fig:functions-witnesses}
\end{figure}

Figure~\ref{fig:functions-witnesses} contains the changed definition
of the function $\fun{scriptsNeeded}$, to also collect the scripts
necessary for forging. It is also necessary to update the
$\fun{validateScripts}$ function, to allow for the validation of
monetary policy scripts.

The arguments that are passed to the $\fun{validateScript}$ function include all those
that are needed for MPS and MSig script evaluation. Because of the extra arguments
(the slot number and the UTxO), we also modify the call to this function
within the UTXOW rule.

As inputs, $\fun{evalMPSScript}$ takes:

\begin{itemize}
\item The script getting evaluated.
\item The $\PolicyID$ of the asset being forged.
  \begin{note}
    What do we put here if we don't forge anything? Do we make this argument optional?
  \end{note}
\item The current slot number.
\item The set of key hashes (needed to use MSig scripts as MP scripts).
\item The transaction body.
\item The inputs of the transaction as a UTxO.
\end{itemize}


\clearpage

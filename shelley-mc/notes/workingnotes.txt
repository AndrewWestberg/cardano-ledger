----------------------------------------------------------------
July 30, 2020
-- Notes on the potential scripting language

An advantage of a primitive scripting language would be that common
operations could be executed much cheaper than with Plutus, and with a
much higher degree of trust in the correctness of the implementation
(there is a real possibility of losing funds from bad or malicious
scripts, much less so if there is a very primitive language that
anyone can understand).

Two ideas about features that might be nice in the scripting language:

- Locking an output with a script that allows anyone to spend from
  that output, as long as it is the only input spending Ada in the
  transaction, its fee is smaller than a certain value (specified by
  the primitive) and it produces a single output that is locked
  exactly the way the input was. This is to allow a person A to send B
  assets that are not Ada, without requiring A to also send some Ada
  to B (because of the minimum deposit). There is an attack here
  though: A could make some tokens that inflate the size of to output
  to the point where all the Ada are locked up by the minimum
  deposit. If B can't spend or unforge the tokens, B has essentially
  lost some Ada. One way to prevent this would be to include a
  whitelist in the primitive.

- An exchange primitive, that allows a seller to specify a Value, and
  a transaction that creates an output that locks that Value in a way
  specified by a parameter can then spend that output. This has to be
  implemented carefully as not to allow spending multiple such outputs
  when only one of them should be spendable.

It might be possible to implement both of these with the same
primitive, depending on how exactly those would work.

----------------------------------------------------------------
July 30, 2020
-- Andre's notes on operations the MC spec uses on Value

These can be turned into the operations in the Val class. Note that
everything here ignores serialization and any operation not in the MC
spec.

It should be a partially ordered monoid (with decidable equality)

- 0 : Value
- _+_ : Value -> Value -> Value
- _>_, _=_ : Value -> Value -> Bool

that embeds from and projects to Coin

- coinToValue : Coin -> Value
- valueToCoin : Value -> Coin

with two extra operations

- valueSize : Value -> N
- getScripts : Value -> P PolicyID

Assuming we want to express Value as Value = Coin x M (which looks a
lot like CompactValue), we can get away with a partially ordered
monoid M (as above) with the operations

- valueSizeM : M -> N
- getScriptsM : M -> P PolicyID

This gives us a class that I'll call PreVal here, that M should
satisfy so that we can derive PreVal M => Val (Coin x M). The
non-trivial operations are:

- valueSize (x, m) = 1 + valueSizeM m
- getScripts (x, m) = getScriptsM m + if x = 0 then {} else {adaID}

Interestingly, getScripts(M) is a monoid morphism, if P PolicyID is
equipped with + := sup, but there is probably no way valueSize is
going to be one.

----------------------------------------------------------------
July 29, 2020
-- Notes for Goguen meeting
-- Strategy make small non-breaking changes to master
-- for as long as we can.

Abstractly we have:

data TxOut crypto where
   TxOut:: Crypto crypto => Addr crypto ->  Coin -> TxOut crypto



newtype UTxO crypto = UTxO {unUTxO :: Map (TxIn crypto) (TxOut crypto)}

We should change these to

data TxOut crypto v where
   TxOut:: (Val v,Crypto crypto) => Addr crypto -> v -> TxOut crypto

newtype UTxO crypto v = UTxO {unUTxO :: Map (TxIn crypto) (TxOut crypto v)}

we can keep this in master by making Coin the only instance of Val

This would mean change every file that uses the types (TxOut crypto) and (UTxO crypto) to use
(TxOut crypto v) and (UTxO crypto v)

UTxO is mentioned (as a type) in
src/Shelley/Spec/Ledger/API/Wallet.hs
src/Shelley/Spec/Ledger/STS/Utxo.hs
src/Shelley/Spec/Ledger/STS/Chain.hs
src/Shelley/Spec/Ledger/EpochBoundary.hs
src/Shelley/Spec/Ledger/LedgerState.hs
src/Shelley/Spec/Ledger/UTxO.hs
src/Shelley/Spec/Ledger/Genesis.hs

TxOut is mentioned in
src/Shelley/Spec/Ledger/STS/Utxo.hs
src/Shelley/Spec/Ledger/UTxO.hs
src/Shelley/Spec/Ledger/TxData.hs

functions:: foo :: Crypto crypto => ...... UTxO crypto .......
            foo :: (Val v,Crypto crypto) => ...... UTxO crypto v .......
            foo :: CV c v =>  ...... UTxO crypto v .......

type CV c v = (Val v, Crypto c)
The idea is to make these things parametric over c and v.
Then the changed code should still work when we fix v to Coin.
If we add a method asCoin to class Val

class Val t where
  vadd: t -> t -> t
  ...
  asCoin :: t -> Coin
  deSerialise:: ShortByteString -> t

In administrative calculations we can do things like

  TxOut addr coin ->  .... foo coin
changes to
  TxOut addr val -> .... foo (asCoin val)


---------------------------------------------------------------
Where are the specs

https://github.com/input-output-hk/cardano-ledger-specs/tree/master/shelley-mc/formal-spec

https://github.com/input-output-hk/cardano-ledger-specs/tree/nonbreaking-multiassets/goguen/formal-spec

\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\left\{\,#1\mid#2\,\right\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\pp}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}
\newcommand{\serialised}[1]{\llbracket \var{#1} \rrbracket}

\newcommand{\leteq}{\ensuremath{\mathrel{\mathop:}=}}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}  % hashes of various things, including blocks
\newcommand{\Slot}{\type{Slot}}
\newcommand{\BlockIx}{\type{BlockIx}}
\newcommand{\Block}{\type{Block}}
\newcommand{\DCert}{\type{DCert}}
\newcommand{\Queue}{\type{Q}}

\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
\newcommand{\DelegState}{\type{DIState}}

\newcommand{\ProtParams}{\type{PParams}} % protocol parameters

%%
%% Function and relation names
%%
\newcommand{\bsizename}{bSize}
\newcommand{\bhdrsizename}{bHeaderSize}
\newcommand{\verifyname}{verify}
\newcommand{\signmapname}{\mathcal{M}}
\newcommand{\trimixname}{trimIx}
\newcommand{\incixmapname}{incIxMap}

\newcommand{\isebbname}{bIsEBB}
\newcommand{\bcertsname}{bCerts}
\newcommand{\bsigname}{bSig}
\newcommand{\bissuername}{bIssuer}

\newcommand{\qrestrname}{qRestrict}
\newcommand{\qpopname}{qPop}
\newcommand{\qheadname}{qHead}
\newcommand{\qpushname}{qPush}

%%
%% Functions and relations
%%
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\bsize}[1]{\fun{\bsizename} ~ #1}
\newcommand{\bhdrsize}[1]{\fun{\bhdrsizename} ~ #1}
\newcommand{\delegation}[2]{\fun{\delegationname} ~ #1 ~ #2}
\newcommand{\signmap}[1]{\fun{\signmapname} ~ #1}
\newcommand{\qrestr}[2]{\fun{\qrestrname} ~ #1 ~ #2}
\newcommand{\trimix}[2]{\fun{\trimixname} ~ #1 ~ #2}
\newcommand{\incixmap}[3]{\fun{\incixmapname} ~ #1 ~ #2 ~ #3}

\newcommand{\hashofblock}[1]{\fun{\hashofblockname} ~ #1}
\newcommand{\blocksizelimit}[2]{\fun{\blocksizelimitname} ~ #1 ~ #2}
\newcommand{\isebb}[1]{\fun{\isebbname} ~ #1}
\newcommand{\bcerts}[1]{\fun{\bcertsname} ~ #1}
\newcommand{\bsig}[1]{\fun{\bsigname} ~ #1}
\newcommand{\bissuer}[1]{\fun{\bissuername} ~ #1}

\newcommand{\qpop}[1]{\fun{\qpopname} ~ #1}
\newcommand{\qhead}[1]{\fun{\qheadname} ~ #1}
\newcommand{\qpush}[1]{\fun{\qpushname} ~ #1}


% A type alias for a map from a genesis block verification key to a queue of indices
\newcommand{\mapqueue}{\mathcal{Q}}
% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}

\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević \\ Nicholas Clarke}

\date{December 13, 2018}

\maketitle

\begin{abstract}
  This documents defines inference rules for operations on a blockchain as a
  specification of the blockchain layer of Cardano in the Byron release and in
  a transition to the Shelley release.
  %
  In particular, a block validity definition is given, which is accompanied by
  small-step operational semantics inference rules.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

The idea behind this document is to formalise what it means for a new block to
be added to the blockchain to be valid.
%
The scope of the document is the Byron release and a transition phase to the
Shelley release of the Cardano blockchain platform.


Unless a new block is valid, it cannot be added to the blockchain and thereby
extend it.
%
This is needed for a system that is subscribed to the blockchain and keeps a
copy of it locally.
%
In particular, this document gives a formalisation that should be
straightforward to implement in a programming language, e.g., in Haskell.

This document is intended to be read in conjunction with \cite{byron_ledger_spec},
which covers the payload carried around in the blockchain. Certain of the
underlying systems and types defined will rely on definitions in that document.

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\item[Union override] The union override operation is defined in
  Figure~\ref{fig:unionoverride}.
  %
  \begin{figure}
    \begin{align*}
      \var{K} \restrictdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \in \var{K} \}
      & \text{domain restriction}
      \\
      \var{K} \subtractdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \notin \var{K} \}
      & \text{domain exclusion}
      \\
      \var{M} \restrictrange \var{V}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ o \in \var{V} \}
      & \text{range restriction}
      \\
      & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
      & \text{union override}\\
      & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
    \end{align*}
    \caption{Definition of the Union Override Operation}
    \label{fig:unionoverride}
  \end{figure}
\end{description}

\subsection{Sets}
\label{sec:sets}

There are several standard sets used in the document:
%
\begin{description}
\item[Booleans] The set of booleans is denoted with $\mathbb{B}$ and has two
  values, $\mathbb{B} = \{\bot, \top\}$.
\item[Natural numbers] The set of natural numbers is denoted with
  $\mathbb{N}$ and defined as $\mathbb{N} = \{0, 1, 2, \dots\}$.
\end{description}

\section{Update interface}

\newcommand{\bupdprop}[1]{\fun{bUpdProp}\ #1}
\newcommand{\bupdvotes}[1]{\fun{bUpdVotes}\ #1}
\newcommand{\bprotver}[1]{\fun{bProtVer}\ #1}
\newcommand{\bendorsment}[1]{\fun{bEndorsment}\ #1}

\newcommand{\Bupisig}{\type{BUPISig}}
% Imported definitions

\newcommand{\UPIEnv}{\type{UPIEnv}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UProp}{\type{UProp}}
\newcommand{\Vote}{\ensuremath{\type{Vote}}}
\newcommand{\ProtVer}{\ensuremath{\type{ProtVer}}}

\begin{figure}[ht]
  \emph{Update interface signals}
  \begin{equation*}
    \Bupisig =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{mprop} & \UProp^{?} & \text{Possible update proposal}\\
        \var{votes} & \seqof{\Vote} & \text{Votes for update proposals}\\
        \var{end} & (\VKey \times \ProtVer) & \text{Protocol version endorsment}
      \end{array}
    \right)
  \end{equation*}

  \caption{Update interface processing types and functions}
  \label{fig:defs:bupi}
\end{figure}

\begin{figure}[ht]
  \emph{Update interface processing transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bupi}{\_} \var{\_} \subseteq
    \powerset (\UPIEnv \times \UPIState \times \Bupisig \times \UPIState)
  \end{equation*}
  \caption{Update interface processing transition-system types}
  \label{fig:ts-types:bupi}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    { {\left(
          \begin{array}{l}
            \bslot{b} \\
            \var{e_n} \\
            \fun{dms} ~ \var{ds}
          \end{array}
        \right)
      }
      \vdash \var{us} \trans{upireg}{\var{prop}} \var{us'}
      \\
      {\left(
          \begin{array}{l}
            \bslot{b} \\
            \var{e_n} \\
            \fun{dms} ~ \var{ds}
          \end{array}
        \right)}
      \vdash \var{us'} \trans{upivotes}{\var{votes}} \var{us''}
      &
      {\left(
          \begin{array}{l}
            \bslot{b} \\
            \var{e_n} \\
            \fun{dms} ~ \var{ds}
          \end{array}
        \right)}
      \vdash \var{us''} \trans{upiend}{\var{end}} \var{us'''}
    }
    {
      \left(
        {\begin{array}{c}
           \var{pps} \\
           \var{e_n}
         \end{array}}
     \right)
     \vdash
     {
       \left(
         {\begin{array}{c}
            \var{utxo} \\
            \var{ds} \\
            \var{us}
          \end{array}}
      \right)
    }
    \trans{upi}
    {
      \left(
        \begin{array}{l}
          \var{prop} \\
          \var{votes} \\
          \var{end}
        \end{array}
      \right)
    }
    {
      \left(
        {\begin{array}{c}
           \var{utxo'} \\
           \var{ds'} \\
           \var{us'''}
         \end{array}}
     \right)
   }
 }
\end{equation*}
\vspace{20pt}
\begin{equation*}
 \inference
 { {\left(
       \begin{array}{l}
         \bslot{b} \\
         \var{e_n} \\
         \fun{dms} ~ \var{ds}
       \end{array}
     \right)}
   \vdash \var{us} \trans{upivotes}{\var{votes}} \var{us'}
   &
   {\left(
       \begin{array}{l}
         \bslot{b} \\
         \var{e_n} \\
         \fun{dms} ~ \var{ds}
       \end{array}
     \right)}
   \vdash \var{us'} \trans{upiend}{\var{end}} \var{us''}
 }
 {
   \left(
     {\begin{array}{c}
        \var{pps} \\
        \var{e_n}
      \end{array}}
  \right)
  \vdash
  {
    \left(
      {\begin{array}{c}
         \var{utxo} \\
         \var{ds} \\
         \var{us}
       \end{array}}
   \right)
 }
 \trans{upi}
 {
   \left(
     \begin{array}{l}
       1 \\
       \var{votes} \\
       \var{end}
     \end{array}
   \right)
 }
 {
   \left(
     {\begin{array}{c}
        \var{utxo'} \\
        \var{ds'} \\
        \var{us''}
      \end{array}}
  \right)
}
}

\end{equation*}
\caption{Update interface processing rules}
\label{fig:rules:bbody}
\end{figure}

\clearpage

\section{Epoch transitions}

\newcommand{\Epoch}{\type{Epoch}}

\newcommand{\ETState}{\type{ETState}}
\newcommand{\ETEnv}{\type{ETEnv}}

\newcommand{\sepochname}{sEpoch}
\newcommand{\sepoch}[1]{\fun{\sepochname}\ #1}

This section should cover:
\begin{itemize}
\item How we determine the end of an epoch
\item Epoch-transition bookkeeping
\end{itemize}

The epoch transition rules should compute whether a given slot is at the end of
an epoch
\begin{figure}[ht]
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{\sepochname} & \Slot \totalf \Epoch & \text{Epoch containing this slot} \\
    \end{array}
  \end{equation*}
  \caption{Epoch transition types and functions}
  \label{fig:defs:epoch}
\end{figure}

\begin{figure}[ht]

  \emph{Epoch transition states}
  \begin{equation*}
    \ETState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{e_c} & \Epoch & \text{Current epoch} \\
        \var{us} & \UPIState & \text{Update interface state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Epoch transition transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{epoch}{\_} \var{\_} \subseteq
    \powerset ((\VKey \mapsto \VKeyGen) \times \ETState \times \Slot \times \ETState)
  \end{equation*}
  \caption{Epoch transition transition-system types}
  \label{fig:ts-types:epoch}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    {
      \var{e_c} \geq \sepoch{s}
    }
    {\var{dms} \vdash
      {
        \left(
          {\begin{array}{c}
             \var{e_c} \\
             \var{us}
           \end{array}
         }
       \right)
     }
     \trans{epoch}{s}
     {
       \left(
         {\begin{array}{c}
            \var{e_c} \\
            \var{us}
          \end{array}
        }
      \right)
    }
  }
\end{equation*}
\vspace{20pt}
\begin{equation*}
  \inference
  {
    \var{e_c} < \sepoch{s}
    \\
    {\left(
        \begin{array}{l}
          \var{\var{e_c}} \\
          \var{s} \\
          \var{dms}
        \end{array}
      \right)
    }
    \vdash \var{us} \trans{upiec}{\sepoch{s}} \var{us'}
  }
  {
    \var{dms} \vdash
    {
      \left(
        {\begin{array}{c}
           \var{e_c} \\
           \var{us}
         \end{array}
       }
     \right)
   }
   \trans{epoch}{\var{s}}
   {
     \left(
       {\begin{array}{c}
          \sepoch{s} \\
          \var{us'}
        \end{array}
      }
    \right)
  }
}
\end{equation*}
\caption{Epoch transition rules}
\label{fig:rules:epoch}
\end{figure}

\clearpage
\section{Counting signed blocks}

\newcommand{\BSCEnv}{\type{BSCEnv}}
\newcommand{\BSCState}{\type{BSCState}}

To guard against the compromise of a minority of the genesis keys,
we require that in the rolling window of the last $K$ blocks, the number of
blocks signed by keys that $sk_s$ delegated to is no more than a threshold $K
\cdot t$, where $t$ is a constant\footnote{This is not the same $t$ from the
  Ouroboros BFT paper draft where it denotes the number of Byzantine servers,
  though it should be somehow related to it.} that will be picked in the range
$1/5 \leq t \leq 1/4$.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{align*}
    q  & \in \Queue_\BlockIx  & \text{block index queue}\\
  \end{align*}
  %
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
      \signmapname & \mapqueue & \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map}\\
      \var{bIx} & \BlockIx & \var{bIx} & \mathbb{N} & \text{Block index}
    \end{array}
  \end{equation*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \fun{\qheadname} & \in \Queue_\BlockIx \totalf \BlockIx^? & \text{head of queue function} \\
    \fun{\qpushname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
                                                              & \text{queue push function} \\
    \fun{\qpopname} & \in \Queue_\BlockIx \totalf {\Queue_\BlockIx}^?
                                                              & \text{queue pop function} \\
    \fun{\qrestrname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
                                                              & \text{restricted queue pop function} \\
    \fun{\incixmapname} & \in \BlockIx \times \powerset \VKeyGen \times \mapqueue \totalf \mapqueue
                                                              & \text{block count increment function}\\
  \end{align*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
      \pp{blockSignatureCountWindow} & \mathbb{N} & \text{Block signature count window size} \\
      \pp{blockSignatureCountThreshold} & \left[\frac{1}{5}, \frac{1}{4}\right] & \text{Block signature count threshold} \\
    \end{array}
  \end{equation*}

  \begin{align}
    \label{eq:trimix}
    \trimix{\signmapname}{\var{ix}} & = \Set{(\var{vk_s} \partialf q)}{\var{vk_s} \in \dom \signmapname.~
                                      q = \qrestr{\var{ix}}{(\signmap{\var{vk_s}}})} \\
    \qrestr{\var{ix}}{q} & = \
                           \begin{cases}
                             \qpop{q} & \text{if } \size{q} > 0 \wedge \qhead{q} + K < \var{ix} \\
                             q & \text{otherwise}
                           \end{cases} \\
    \label{eq:incixmap}
    \incixmap{\var{ix}}{\var{X}}{\signmapname} & = \signmapname \unionoverride
                                                 \Set{\var{vk_s} \partialf \qpush{\var{ix}}(\signmap{\var{vk_s}})}{vk_s \in \var{X}}
  \end{align}
  \caption{Blockchain signature count types and functions}
  \label{fig:defs:sigcnt}
\end{figure}

\begin{figure}[ht]
  \emph{Block signature count environments}
  \begin{equation*}
    \BSCEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pps} & \ProtParams & \text{Protocol parameters} \\
        \var{ds} & \DelegState & \text{Delegation state} \\
        \var{bIx} & \BlockIx & \text{Block index}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block signature count transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{sigcnt}{\_} \var{\_} \subseteq
    \powerset (\BSCEnv \times \signmapname \times \VKey \times \signmapname)
  \end{equation*}
  \caption{Block signature count transition-system types}
  \label{fig:ts-types:sigcnt}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    {
      \pp{blockSignatureCountWindow} \partialf \var{K} \in pps & \pp{blockSignatureCountThreshold} \partialf \var{t} \in pps \\
      \var{D} \leteq (\fun{dms} ~ \var{ds})^{-1} ~ \var{vk_d} & \forall \var{vk_s} \in \var{D} . \size{\signmap{\var{vk_s}}} \leq K \cdot t \\
      \signmapname' \leteq \incixmap{\var{bIx}}{\var{D}}{(\trimix{\signmapname}{\var{bIx}})}
    }
    {
      \left(
        {\begin{array}{c}
           \var{pps} \\
           \var{ds} \\
           \var{bIx}
         \end{array}}
     \right)
     \vdash
     {\signmapname}
     \trans{sigcnt}{\var{vk_d}}
     {\signmapname'}
   }
   \label{eq:rule:sigcnt}
 \end{equation*}
 \caption{Block signature count rules}
 \label{fig:rules:sigcnt}
\end{figure}

\clearpage

\section{Block processing}
\label{sec:block-processing}

\newcommand{\BHEnv}{\type{BHEnv}}
\newcommand{\BHState}{\type{BHState}}

\newcommand{\BBEnv}{\type{BBEnv}}
\newcommand{\BBState}{\type{BBState}}

\newcommand{\Bhead}{\type{BlockHeader}}
\newcommand{\Bbody}{\type{BlockBody}}
\newcommand{\Bhtosign}{\type{BHToSign}}

\newcommand{\bheadname}{bHead}
\newcommand{\bhead}[1]{\fun{\bheadname}\ #1}
\newcommand{\bhhashname}{bhHash}
\newcommand{\bhhash}[1]{\fun{\bhhashname}\ #1}
\newcommand{\bhprevhashname}{bhPrevHash}
\newcommand{\bhprevhash}[1]{\fun{\bhprevhashname}\ #1}
\newcommand{\bhtosignname}{bhToSign}
\newcommand{\bhtosign}[1]{\fun{\bhtosignname}\ #1}
\newcommand{\bhslotname}{bhSlot}
\newcommand{\bhslot}[1]{\fun{\bhslotname}\ #1}
\newcommand{\bupdpayloadname}{bUpdPayload}
\newcommand{\bupdpayload}[1]{\fun{\bupdpayloadname}\ #1}

\newcommand{\bslotname}{bSlot}
\newcommand{\bslot}[1]{\fun{\bslotname}\ #1}

\newcommand{\butxo}[1]{\fun{bUtxo}\ #1}

\newcommand{\maxblocksize}{\pp{maxBlockSize}}
\newcommand{\maxheadersize}{\pp{maxHeaderSize}}

% Imported definitions
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\DIEnv}{\type{DIEnv}}
\newcommand{\DIState}{\type{DIState}}

We delineate here between processing the header and body of a block. It's useful
to make this distinction since we may process headers ahead of the
block body, and we have less context available to process headers - in
particular, we must be able to process block headers without the recent history
of block bodies.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      b & \Block & \text{block} \\
      h & \Hash   & \text{hash} \\
      \var{data} & \Data    & \text{data}
    \end{array}
  \end{equation*}
  %
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{\bsizename} & \Block \totalf \mathbb{N} & \text{block size in bytes} \\
      \fun{\verifyname} & \VKey \times \Data \times \Sig & \text{verification relation} \\
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
      \maxblocksize & \mathbb{N} & \text{maximum block size} \\
    \end{array}
  \end{equation*}
  \caption{Basic Block-related Types and Functions}
  \label{fig:block-defs}
\end{figure}

\subsection{Block header processing}

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      bh & \Bhead & \text{Block header} \\
      bts & \Bhtosign & \text{Part of the block header which must be signed}
    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{\bheadname} & \Block \totalf \Bhead & \text{Block header} \\
      \fun{\bhprevhashname} & \Bhead \totalf \Hash & \text{Previous header hash} \\
      \fun{\bhhashname} & \Bhead \totalf \Hash & \text{Header hash} \\
      \fun{\bsigname} & \Bhead \totalf \Sig & \text{Block signature} \\
      \fun{\bissuername} & \Bhead \totalf \VKey & \text{Block issuer} \\
      \fun{\bhdrsizename} & \Bhead \totalf \mathbb{N} & \text{Block header size in bytes}\\
      \fun{\bhtosignname} & \Bhead \totalf \Bhtosign & \text{Block header to sign}\\
      \fun{\bhslotname} & \Bhead \totalf \Slot & \text{Slot for which this block is issued}
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
      \maxheadersize & \mathbb{N} & \text{maximum block header size} \\
    \end{array}
  \end{equation*}
  \caption{Block header processing types and functions}
  \label{fig:defs:bhead}
\end{figure}

\begin{figure}[ht]
  \emph{Block header processing environments}
  \begin{equation*}
    \BHEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{ds} & \DelegState & \text{Delegation state} \\
        \var{s_{last}} & \Slot & \text{Slot for which the last known block was issued} \\
        \var{s_{now}} & \Slot & \text{Current slot} \\
      \end{array}
    \right)
  \end{equation*}

  \emph{Block header processing states}
  \begin{equation*}
    \BHState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{h} & \Hash & \text{Tip header hash} \\
        \var{us} & \UPIState & \text{Update state} \\
        \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map} \\
        \var{bIx} & \BlockIx & \text{Current block index} \\
      \end{array}
    \right)
  \end{equation*}
  \emph{Block header processing transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bhead}{\_} \var{\_} \subseteq
    \powerset (\BHEnv \times \BHState \times \Bhead \times \BHState)
  \end{equation*}
  \caption{Block header processing transition-system types}
  \label{fig:ts-types:bhead}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    { {\left(
          \begin{array}{l}
            \sepoch{s_{last}} \\
            us
          \end{array}
        \right)}
      \trans{epoch}{\bslot{b}}
      {\left(
          \begin{array}{l}
            \var{e_n} \\
            us'
          \end{array}
        \right)}
      \\
      \var{vk_d} \leteq \bissuer{bh} & \var{s} \leteq \bhslot{bh}
      \\ \maxheadersize \mapsto \var{s_{max}} \in \fun{pps}~\var{us'} & \bhdrsize{bh} \leq \var{s_{max}}
      \\ \var{s} > \var{s_{last}} & \var{s} \leq \var{s_{now}}
      \\ \fun{dms} ~  \var{ds} \restrictrange \{\var{vk_d}\} \neq \emptyset
      \\ \bhprevhash{bh} = \var{h} & \verify{vk_d}{\serialised{\bhtosign{bh}}}{(\bsig{bh})}
      \\
      {\left(
          \begin{array}{l}
            \fun{pps} ~  us' \\
            ds \\
            bIx
          \end{array}
        \right)}
      \vdash
      \signmapname \trans{sigcnt}{\var{vk_d}} \signmapname'
      \\
    }
    {
      \left(
        {\begin{array}{c}
           \var{ds} \\
           \var{s_{last}} \\
           \var{s_{now}} \\
         \end{array}}
     \right)
     \vdash
     \left(
       {\begin{array}{c}
          \var{h} \\
          \var{us} \\
          \signmapname \\
          bIx \\
        \end{array}}
    \right)
    \trans{bhead}{\var{bh}}
    \left(
      {\begin{array}{c}
         \bhhash{bh} \\
         \var{us'} \\
         \signmapname' \\
         bIx + 1 \\
       \end{array}}
   \right)
 }
\end{equation*}
\caption{Block header processing rules}
\label{fig:rules:bhead}
\end{figure}

\clearpage

\subsection{Block body processing}
\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      bb & \Bbody & \text{Block body} \\

    \end{array}
  \end{equation*}
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{bUtxo} & \Block \totalf \UTxO & \text{Block UTxO payload} \\
      \fun{\bcertsname} & \Block \totalf \seqof{\DCert}
                                         & \text{block certificates} \\
      \fun{bUpdProp} & \Block \totalf \UProp^{?} & \text{Block update proposal payload} \\
      \fun{bUpdVotes} & \Block \totalf \seqof{\Vote} & \text{Block update votes payload} \\
      \fun{bProtVer} & \Block \totalf \ProtVer & \text{Block protocol version} \\
      \fun{bhUtxoSig} & \Bhead \totalf \Sig & \text{UTxO payload signature} \\
      \fun{bhDlgSig} & \Bhead \totalf \Sig & \text{Delegation payload signature} \\
      \fun{bhUpdSig} & \Bhead \totalf \Sig & \text{Update payload signature} \\
    \end{array}
  \end{equation*}
  \emph{Derived functions}
  \begin{equation*}
    \begin{array}{rlr}
      \fun{bEndorsment} & \in \Block \to \ProtVer \times \VKey & \text{Protocol version endorsment} \\
      \bendorsment{b} & = (\bprotver{b}, \bissuer{b}) \\
      \fun{\bslotname} & \in \Block \to \Slot & \text{Slot for which this block is being issued} \\
      \bslot{b} & = (\bhslotname \cdot \bheadname)~b \\
      \fun{\bupdpayloadname} & \in \Block \to (\UProp^{?}\times\seqof{\Vote}) & \text{Block update payload} \\
      \bupdpayload{b} & = (\bupdprop{b},~\bupdvotes{b})
    \end{array}
  \end{equation*}
  \caption{Block body processing types and functions}
  \label{fig:defs:bbody}
\end{figure}

\begin{figure}[ht]
  \emph{Block body processing environments}
  \begin{equation*}
    \BBEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pps} & \ProtParams & \text{Protocol parameters} \\
        \var{e_n} & \Epoch & \text{Epoch we are currently processing blocks for}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block body processing states}
  \begin{equation*}
    \BBState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO} \\
        \var{us} & \UPIState & \text{Update interface state} \\
        \var{ds} & \DIState & \text{Delegation state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block body processing transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{bbody}{\_} \var{\_} \subseteq
    \powerset (\BBEnv \times \BBState \times \Block \times \BBState)
  \end{equation*}
  \caption{Block body processing transition-system types}
  \label{fig:ts-types:bbody}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    { \maxblocksize \mapsto \var{b_{max}} \in \var{pps} && \bsize{b} \leq \var{b_{max}} \\
      \var{bh} \leteq \bhead{b} & \var{vk_d} \leteq \bissuer{\var{bh}} \\
      \verify{\var{vk_d}}{\serialised{\butxo{b}}}{(\fun{bhUtxoSig}~\var{bh})} &
      \verify{\var{vk_d}}{\serialised{\bcerts{b}}}{(\fun{bhDlgSig}~\var{bh})} \\
      \verify{\var{vk_d}}{\serialised{\bupdpayload{b}}}{(\fun{bhUpdSig}~\var{bh})} \\
      {\left(
          \begin{array}{l}
            \bslot{b} \\
            \var{e_n} \\
            \fun{dms} ~ \var{ds}
          \end{array}
        \right)}
      \vdash \var{us} \trans{bupi}{
        {\left(
            \begin{array}{l}
              \bupdprop{b} \\
              \bupdvotes{b} \\
              \bendorsment{b}
            \end{array}
          \right)}
      } \var{us'}
      \\
      {\left(
          \begin{array}{l}
            \dom{(\fun{dms}~ ds)} \\
            (\fun{\sepochname} \cdot \fun{\bslotname}) ~ b \\
            \bslot{b} \\
            \fun{pps} ~  us \\
          \end{array}
        \right)}
      \vdash \var{ds} \trans{deleg}{\bcerts{b}} \var{ds'} &
      \fun{pps} ~  us \vdash \var{utxo} \trans{utxow}{\butxo{b}} \var{utxo'} \\
    }
    {
      \left(
        {\begin{array}{c}
           \var{pps} \\
           \var{e_n}
         \end{array}}
     \right)
     \vdash
     {
       \left(
         {\begin{array}{c}
            \var{utxo} \\
            \var{ds} \\
            \var{us}
          \end{array}}
      \right)
    }
    \trans{bbody}{\var{b}}
    {
      \left(
        {\begin{array}{c}
           \var{utxo'} \\
           \var{ds'} \\
           \var{us'}
         \end{array}}
     \right)
   }
 }
\end{equation*}
\caption{Block body processing rules}
\label{fig:rules:bbody}
\end{figure}

\clearpage

\section{Blockchain Extension}
\label{sec:chain-extension}

\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}


\begin{figure}[ht]
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{\isebbname} & \Block \totalf \mathbb{B} & \text{epoch boundary block check} \\
    \end{array}
  \end{equation*}
  \caption{Blockchain Extension Types and Functions}
  \label{fig:defs:chain-extension}
\end{figure}

\begin{figure}[ht]
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{bIx} & \BlockIx & \text{Current block index} \\
        \var{s_{last}} & \Slot & \text{Slot of the last seen block} \\
        \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map} \\
        \var{h} & \Hash & \text{Current block hash} \\
        \var{utxo} & \UTxO & \text{UTxO} \\
        \var{us} & \UPIState & \text{Update interface state} \\
        \var{ds} & \DIState & \text{Delegation state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\Slot \times \CEState \times \Block \times \CEState)
  \end{equation*}

  \caption{Blockchain extension transition-system types}
  \label{fig:ts-types:chain-extension}
\end{figure}

The central rule that captures blockchain extension is given with
Figure~\ref{fig:rules:chain-extension}.

\begin{figure}
  \begin{equation*}
    \inference
    { \isebb{b} & \bsize{b} \leq 2^{21}
      \\ \var{h'} = \bhhash{(\bhead b)}
    }
    {
      \left(
        {\begin{array}{c}
           \var{s_{now}}
         \end{array}}
     \right)
     \vdash
     \left(
       {\begin{array}{c}
          bIx \\
          \var{s_{last}} \\
          \signmapname \\
          \var{h} \\
          \var{utxo} \\
          \var{us} \\
          \var{ds}
        \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx \\
         \var{s_{last}} \\
         \signmapname \\
         \var{h'} \\
         \var{utxo} \\
         \var{us} \\
         \var{ds}
       \end{array}}
   \right)
 }
\end{equation*}
\vspace{20pt}
\begin{equation*}
  \inference
  {
    \neg\isebb{b} \\
    {\left(
        \begin{array}{l}
          ds \\
          \var{s_{last}} \\
          \var{s_{now}} \\
        \end{array}
      \right)}
    \vdash
    \left(
      {\begin{array}{c}
         \var{h} \\
         \var{us} \\
         \signmapname \\
         bIx \\
       \end{array}}
   \right)
   \trans{bhead}{\bhead{b}}
   \left(
     {\begin{array}{c}
        \var{h'} \\
        \var{us'} \\
        \signmapname' \\
        bIx' \\
      \end{array}}
  \right)
  \\
  {\left(
      \begin{array}{l}
        \fun{pps} ~  us' \\
        \sepoch{(\bslot{b})} \\
      \end{array}
    \right)}
  \vdash
  {
    \left(
      {\begin{array}{c}
         \var{utxo} \\
         \var{ds} \\
         \var{us'}
       \end{array}}
   \right)
 }
 \trans{bbody}{b}
 {
   \left(
     {\begin{array}{c}
        \var{utxo'} \\
        \var{ds'} \\
        \var{us''}
      \end{array}}
  \right)
}
}
{
  \left(
    {\begin{array}{c}
       \var{s_{now}}
     \end{array}}
 \right)
 \vdash
 \left(
   {\begin{array}{c}
      bIx \\
      \var{s_{last}} \\
      \signmapname \\
      \var{h} \\
      \var{utxo} \\
      \var{us'} \\
      \var{ds}
    \end{array}}
\right)
\trans{chain}{b}
\left(
  {\begin{array}{c}
     bIx' \\
     \var{\bslot{b}} \\
     \signmapname' \\
     \var{h'} \\
     \var{utxo'} \\
     \var{us''} \\
     \var{ds'}
   \end{array}}
\right)
}
\end{equation*}
\caption{Blockchain extension rules}
\label{fig:rules:chain-extension}
\end{figure}
\clearpage
\bibliographystyle{plainnat}
\bibliography{references}
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "nix-shell --run make"
%%% End:

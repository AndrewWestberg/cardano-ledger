\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\left\{\,#1\mid#2\,\right\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}  % hashes of various things, including blocks
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\BlockIx}{\type{BlockIx}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\DCert}{\type{DCert}}
\newcommand{\Queue}{\type{Q}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
\newcommand{\DelegState}{\type{DIState}}

\newcommand{\ProtParams}{\type{PParams}} % protocol parameters

%%
%% Function and relation names
%%
\newcommand{\hashname}{bHash}
\newcommand{\bsizename}{bSize}
\newcommand{\bhdrsizename}{bHeaderSize}
\newcommand{\verifyname}{verify}
\newcommand{\delegationname}{delegates} % the delegation relation
\newcommand{\signmapname}{\mathcal{M}}
\newcommand{\trimixname}{trimIx}
\newcommand{\incixmapname}{incIxMap}

\newcommand{\hashofblockname}{hashBlock}
\newcommand{\blocksizelimitname}{blockSizeLimit}
\newcommand{\maxblocksizename}{maxBlockSize}
\newcommand{\maxheadersizename}{maxHeaderSize}
\newcommand{\isebbname}{bIsEBB}
\newcommand{\bcertsname}{bCerts}
\newcommand{\bsigname}{bSig}
\newcommand{\bissuername}{bissuer}

\newcommand{\qrestrname}{qRestrict}
\newcommand{\qpopname}{qPop}
\newcommand{\qheadname}{qHead}
\newcommand{\qpushname}{qPush}

%%
%% Functions and relations
%%
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\bsize}[1]{\fun{\bsizename} ~ #1}
\newcommand{\bhdrsize}[1]{\fun{\bhdrsizename} ~ #1}
\newcommand{\delegation}[2]{\fun{\delegationname} ~ #1 ~ #2}
\newcommand{\signmap}[1]{\fun{\signmapname} ~ #1}
\newcommand{\qrestr}[2]{\fun{\qrestrname} ~ #1 ~ #2}
\newcommand{\trimix}[2]{\fun{\trimixname} ~ #1 ~ #2}
\newcommand{\incixmap}[3]{\fun{\incixmapname} ~ #1 ~ #2 ~ #3}

\newcommand{\hashofblock}[1]{\fun{\hashofblockname} ~ #1}
\newcommand{\blocksizelimit}[2]{\fun{\blocksizelimitname} ~ #1 ~ #2}
\newcommand{\maxblocksize}[1]{\fun{\maxblocksizename} ~ #1}
\newcommand{\maxheadersize}[1]{\fun{\maxheadersizename} ~ #1}
\newcommand{\isebb}[1]{\fun{\isebbname} ~ #1}
\newcommand{\bcerts}[1]{\fun{\bcertsname} ~ #1}
\newcommand{\bsig}[1]{\fun{\bsigname} ~ #1}
\newcommand{\bissuer}[1]{\fun{\bissuername} ~ #1}

\newcommand{\qpop}[1]{\fun{\qpopname} ~ #1}
\newcommand{\qhead}[1]{\fun{\qheadname} ~ #1}
\newcommand{\qpush}[1]{\fun{\qpushname} ~ #1}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

% A type alias for a map from a genesis block verification key to a queue of indices
\newcommand{\mapqueue}{\mathcal{Q}}
% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}

\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević}

\date{December 13, 2018}

\maketitle

\begin{abstract}
  This documents defines inference rules for operations on a blockchain as a
  specification of the blockchain layer of Cardano in the Byron release and in
  a transition to the Shelley release.
  %
  In particular, a block validity definition is given, which is accompanied by
  small-step operational semantics inference rules.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

The idea behind this document is to formalise what it means for a new block to
be added to the blockchain to be valid.
%
The scope of the document is the Byron release and a transition phase to the
Shelley release of the Cardano blockchain platform.


Unless a new block is valid, it cannot be added to the blockchain and thereby
extend it.
%
This is needed for a system that is subscribed to the blockchain and keeps a
copy of it locally.
%
In particular, this document gives a formalisation that should be
straightforward to implement in a programming language, e.g., in Haskell.

This document is intended to be read in conjunction with \cite{byron_ledger_spec},
which covers the payload carried around in the blockchain. Certain of the
underlying systems and types defined will rely on definitions in that document.

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\item[Union override] The union override operation is defined in
  Figure~\ref{fig:unionoverride}.
  %
  \begin{figure}
    \begin{align*}
      \var{K} \restrictdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \in \var{K} \}
      & \text{domain restriction}
      \\
      \var{K} \subtractdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \notin \var{K} \}
      & \text{domain exclusion}
      \\
      \var{M} \restrictrange \var{V}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ o \in \var{V} \}
      & \text{range restriction}
      \\
      & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
      & \text{union override}\\
      & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
    \end{align*}
    \caption{Definition of the Union Override Operation}
    \label{fig:unionoverride}
  \end{figure}
\end{description}

\subsection{Sets}
\label{sec:sets}

There are several standard sets used in the document:
%
\begin{description}
\item[Booleans] The set of booleans is denoted with $\mathbb{B}$ and has two
  values, $\mathbb{B} = \{\bot, \top\}$.
\item[Natural numbers] The set of natural numbers is denoted with
  $\mathbb{N}$ and defined as $\mathbb{N} = \{0, 1, 2, \dots\}$.
\end{description}

\section{Epoch transitions}

This section should cover:
\begin{itemize}
\item How we determine the end of an epoch
\item Epoch-transition bookkeeping
\end{itemize}

\section{Counting signed blocks}

\newcommand{\BSCEnv}{\type{BSCEnv}}
\newcommand{\BSCState}{\type{BSCState}}

To guard against the compromise of a minority of the genesis keys,
we require that in the rolling window of the last $K$ blocks, the number of
blocks signed by keys that $sk_s$ delegated to is no more than a threshold $K
\cdot t$, where $t$ is a constant\footnote{This is not the same $t$ from the
  Ouroboros BFT paper draft where it denotes the number of Byzantine servers,
  though it should be somehow related to it.} that will be picked in the range
$1/5 \leq t \leq 1/4$.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{align*}
    q  & \in \Queue_\BlockIx  & \text{block index queue}\\
    \var{ds} & \in \DelegState & \text{ledger layer delegation state}
  \end{align*}
  %
  \emph{Derived types}
  \begin{equation*}
  \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
    \var{sk_s} & \SKeyGen & \var{sk_s} &  \SKey & \text{genesis stakeholder signing key}\\
    \signmapname & \mapqueue & \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map}\\
    \var{bIx} & \BlockIx & \var{bIx} & \mathbb{N} & \text{Block index}
  \end{array}
  \end{equation*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \fun{\qheadname} & \in \Queue_\BlockIx \totalf \BlockIx^? & \text{head of queue function} \\
    \fun{\qpushname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{queue push function} \\
    \fun{\qpopname} & \in \Queue_\BlockIx \totalf {\Queue_\BlockIx}^?
      & \text{queue pop function} \\
    \fun{\qrestrname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{restricted queue pop function} \\
    \fun{\incixmapname} & \in \BlockIx \times \powerset \VKeyGen \times \mapqueue \totalf \mapqueue
      & \text{block count increment function}\\
  \end{align*}
  \begin{align}
  \label{eq:trimix}
  \trimix{\signmapname}{\var{ix}} & = \Set{(\var{vk_s} \partialf q)}{\var{vk_s} \in \dom \signmapname.~
  q = \qrestr{\var{ix}}{(\signmap{\var{vk_s}}})} \\
  \qrestr{\var{ix}}{q} & = \
  \begin{cases}
    \qpop{q} & \text{if } \size{q} > 0 \wedge \qhead{q} + K < \var{ix} \\
    q & \text{otherwise}
  \end{cases} \\
  \label{eq:incixmap}
    \incixmap{\var{ix}}{\var{X}}{\signmapname} & = \signmapname \unionoverride
                                                 \Set{\var{vk_s} \partialf \qpush{\var{ix}}(\signmap{\var{vk_s}})}{vk_s \in \var{X}}
  \end{align}
  \caption{Blockchain signature count types and functions}
  \label{fig:defs:sigcnt}
\end{figure}

\begin{figure}[ht]
  \emph{Block signature count environments}
  \begin{equation*}
    \BSCEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pp} & \ProtParams & \text{Protocol parameters} \\
        \var{ds} & \DelegState & \text{Delegation state} \\
        \var{bIx} & \BlockIx & \text{Block index}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block signature count transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{sigcnt}{\_} \var{\_} \subseteq
    \powerset (\BSCEnv \times \signmapname \times \VKey \times \signmapname)
  \end{equation*}
  \caption{Block signature count transition-system types}
  \label{fig:ts-types:sigcnt}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    {
      \var{K} = \fun{blockSignatureCountWindow} ~ pp & \var{t} = \fun{blockSignatureCountThreshold} ~ pp \\
      \forall \var{vk_s} \in \var{dms^{-1}} ~ \var{vk_d} . \size{\signmap{\var{vk_s}}} \leq K \cdot t \\
      \signmapname' = \incixmap{\var{bIx}}{\left( \var{dms^{-1}} ~ \var{vk_d} \right)}{(\trimix{\signmapname}{\var{bIx}})}
    }
    {
      \left(
        {\begin{array}{c}
          \var{pp} \\
          \var{ds} \\
          \var{bIx}
        \end{array}}
      \right)
      \vdash
        {\signmapname}
      \trans{sigcnt}{\var{vk_d}}
        {\signmapname'}
    }
    \label{eq:rule:sigcnt}
  \end{equation*}
  \caption{Block signature count rules}
  \label{fig:rules:sigcnt}
\end{figure}

\clearpage

\section{Block validation}
\label{sec:block-validation}

\newcommand{\bhead}{\type{BlockHeader}}
\newcommand{\bbody}{\type{BlockBody}}

We delineate here between validating the header and body of a block. It's useful
to make this distinction since we may validate headers ahead of validating the
block body, and we have less context available to validate headers - in
particular, we must be able to validate block headers without the recent history
of block bodies.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    b & \Block & \text{block} \\
    h & \Hash   & \text{hash} \\
    \end{array}
  \end{equation*}
  %
  %
  \emph{Abstract functions}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    \fun{\hashname} & \Block \totalf \Hash
      & \text{previous block's hash} \\
    \fun{\bissuername} & \Block \totalf \VKey & \text{block issuer} \\
    \fun{\bsigname} & \Block \totalf \Sig & \text{block signature} \\
    \fun{\hashofblockname} & \Block \totalf \Hash & \text{hash of block} \\
    \fun{\bsizename} & \Block \totalf \mathbb{N} & \text{block size in bytes} \\
    \fun{\bhdrsizename} & \Block \totalf \mathbb{N}
      & \text{block header size in bytes}\\
    \end{array}
  \end{equation*}
  \emph{Protocol parameters}
  \begin{equation*}
    \begin{array}{r@{~\partialf~}l!{~\in~\ProtParams~}r}
    \fun{\maxblocksizename} & \mathbb{N} & \text{maximum block size} \\
    \fun{\maxheadersizename} & \mathbb{N} & \text{maximum block header size} \\
    \fun{blockSignatureCountWindow} & \mathbb{N} & \text{Block signature count window size} \\
    \fun{blockSignatureCountThreshold} & \left[\frac{1}{5}, \frac{1}{4}\right] & \text{Block signature count threshold} \\
    \end{array}
  \end{equation*}
  \caption{Basic Block-related Types and Functions}
  \label{fig:block-defs}
\end{figure}

\subsection{Block header validation}
\subsection{Block body validation}


\subsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from shelley-plan.md, which is written by
% Duncan Coutts

A block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a signing key $sk_d$ for which a valid heavyweight
  delegation certificate $c$ that is active at the time of signing exists.
  %
  The certificate $c$ carries information that signing rights from a
  genesis verification key $vk_s$ are transferred to a verification key $vk_d$
  starting in a slot $sl$,
\item the corresponding certificate $c$ is signed by a genesis key $sk_s$. The
  certificate therefore carries a a cryptographic signature $\sigma'$,
\item new delegation certificates that are in the body of $b$ are not in
  conflict with earlier delegation certificates,
\item the size of the block in bytes is within limits, as defined by
  protocol parameters.
\item the size of the block header in bytes is within limits, as defined by
  protocol parameters.
\end{enumerate}

\clearpage

\section{Blockchain Extension}
\label{sec:chain-extension}

\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}

\newcommand{\butxo}[1]{\fun{bUtxo}\ #1}
\newcommand{\bupdprop}[1]{\fun{bUpdProp}\ #1}
\newcommand{\bupdvotes}[1]{\fun{bUpdVotes}\ #1}

% Imported definitions
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\DIEnv}{\type{DIEnv}}
\newcommand{\DIState}{\type{DIState}}

\newcommand{\UPIEnv}{\type{UPIEnv}}
\newcommand{\UPIState}{\type{UPIState}}
\newcommand{\UProp}{\type{UProp}}
\newcommand{\Vote}{\ensuremath{\type{Vote}}}

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
    \var{data} & \Data    & \text{data}\\
    \var{ds} & \DelegState & \text{ledger layer delegation state}
  \end{array}
  \end{equation*}
  \emph{Abstract functions}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}lr}
    \fun{\verifyname} & \VKey \times \Data \times \Sig
      & \text{verification relation} \\
    \fun{bUtxo} & \Block \totalf \UTxO & \text{Block UTxO payload} \\
    \fun{\bcertsname} & \Block \totalf \seqof{\DCert}
      & \text{block certificates} \\
    \fun{bUpdProp} & \Block \totalf \UProp & \text{Block update proposal payload} \\
    \fun{\isebbname} & \Block \totalf \mathbb{B} & \text{epoch boundary block check} \\
  \end{array}
  \end{equation*}

  %
  \caption{Blockchain Extension Types and Functions}
  \label{fig:defs:chain-extension}
\end{figure}

\begin{figure}[ht]
  % \emph{Chain extension environments}
  % \begin{equation*}
  %   \CEEnv =
  %   \left(
  %     \begin{array}{r@{~\in~}lr}
  %       \var{slot} & \Slot & \text{Current slot}
  %     \end{array}
  %   \right)
  % \end{equation*}
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{bIx} & \BlockIx & \text{Current block index} \\
        \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map} \\
        \var{utxo} & \UTxO & \text{UTxO} \\
        \var{upiState} & \UPIState & \text{Update interface state} \\
        \var{ds} & \DIState & \text{Delegation state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\Slot \times \CEState \times \Block \times \CEState)
  \end{equation*}

  \caption{Blockchain extension transition-system types}
  \label{fig:ts-types:chain-extension}
\end{figure}

The central rule that captures blockchain extension is given with
Figure~\ref{fig:defs:chain-extension}.

\begin{figure}
  \begin{equation*}
  \inference
  { \isebb{b} & \bsize{b} \leq 2^{21} }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{upiState} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{upiState} \\
         \var{ds}
       \end{array}}
    \right)
  }
  \end{equation*}
  \vspace{20pt}
  \begin{equation*}
  \inference
  {
    \neg\isebb{b} &
    \var{vk_d} = \bissuer{b} & \hash{b} \equiv \hashofblock{p} \\
    \bsize{b} \leq \maxblocksize{b}{\var{pp}} & \bhdrsize{b} \leq \maxheadersize{\var{pp}} \\
    \verify{\var{vk_d}}{b}{(\bsig{b})} \\
    \var{pp} \vdash \var{utxo} \trans{utxow}{\butxo{b}} \var{utxo'} \\
    {\left(
      \begin{array}{l}
        pp \\
        ds \\
        bIx
      \end{array}
    \right)}
    \vdash
    \signmapname \trans{sigcnt}{\var{vk_d}} \signmapname' &&
    \var{diEnv} \vdash \var{ds} \trans{deleg}{\bcerts{b}} \var{ds'}
  }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{upiState} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx + 1 \\
         \signmapname' \\
         \var{utxo}' \\
         \var{upiState} \\
         \var{ds'}
       \end{array}}
    \right)
  }
  \end{equation*}
  \caption{Blockchain extension rules}
  \label{fig:blockchain-extension}
\end{figure}
\clearpage
\bibliographystyle{plainnat}
\bibliography{references}
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "nix-shell --run make"
%%% End:

\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\left\{\,#1\mid#2\,\right\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}  % hashes of various things, including blocks
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\BlockIx}{\type{BlockIx}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\DCert}{\type{DCert}}
\newcommand{\Queue}{\type{Q}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}
\newcommand{\DelegState}{\type{DIState}}

\newcommand{\ProtParams}{\type{ProtParams}} % protocol parameters


%%
%% Function and relation names
%%
\newcommand{\hashname}{bHash}
\newcommand{\bsizename}{bSize}
\newcommand{\bhdrsizename}{bHeaderSize}
\newcommand{\signname}{sign}
\newcommand{\verifyname}{verify}
\newcommand{\delegationname}{delegates} % the delegation relation
\newcommand{\signmapname}{\mathcal{M}}
\newcommand{\trimixname}{trimIx}
\newcommand{\incixmapname}{incIxMap}

\newcommand{\hashofblockname}{hashBlock}
\newcommand{\blocksizelimitname}{blockSizeLimit}
\newcommand{\maxblocksizename}{maxBlockSize}
\newcommand{\maxheadersizename}{maxHeaderSize}
\newcommand{\isebbname}{bIsEBB}
\newcommand{\bdataname}{bData}
\newcommand{\bcertsname}{bCerts}
\newcommand{\bsigname}{bSig}
\newcommand{\bixname}{bIx}
\newcommand{\bslname}{bSl}
\newcommand{\bsignername}{bSigner}

\newcommand{\qrestrname}{qRestrict}
\newcommand{\qpopname}{qPop}
\newcommand{\qheadname}{qHead}
\newcommand{\qpushname}{qPush}

%%
%% Functions and relations
%%
\newcommand{\sign}[4]{\fun{\signname}\ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\bsize}[1]{\fun{\bsizename} ~ #1}
\newcommand{\bhdrsize}[1]{\fun{\bhdrsizename} ~ #1}
\newcommand{\delegation}[2]{\fun{\delegationname} ~ #1 ~ #2}
\newcommand{\signmap}[1]{\fun{\signmapname} ~ #1}
\newcommand{\qrestr}[2]{\fun{\qrestrname} ~ #1 ~ #2}
\newcommand{\trimix}[2]{\fun{\trimixname} ~ #1 ~ #2}
\newcommand{\incixmap}[3]{\fun{\incixmapname} ~ #1 ~ #2 ~ #3}

\newcommand{\hashofblock}[1]{\fun{\hashofblockname} ~ #1}
\newcommand{\blocksizelimit}[2]{\fun{\blocksizelimitname} ~ #1 ~ #2}
\newcommand{\maxblocksize}[1]{\fun{\maxblocksizename} ~ #1}
\newcommand{\maxheadersize}[1]{\fun{\maxheadersizename} ~ #1}
\newcommand{\isebb}[1]{\fun{\isebbname} ~ #1}
\newcommand{\bdata}[1]{\fun{\bdataname} ~ #1}
\newcommand{\bcerts}[1]{\fun{\bcertsname} ~ #1}
\newcommand{\bsig}[1]{\fun{\bsigname} ~ #1}
\newcommand{\bix}[1]{\fun{\bixname} ~ #1}
\newcommand{\bsl}[1]{\fun{\bslname} ~ #1}
\newcommand{\bsigner}[1]{\fun{\bsignername} ~ #1}

\newcommand{\qpop}[1]{\fun{\qpopname} ~ #1}
\newcommand{\qhead}[1]{\fun{\qheadname} ~ #1}
\newcommand{\qpush}[1]{\fun{\qpushname} ~ #1}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

% A type alias for a map from a genesis block verification key to a queue of indices
\newcommand{\mapqueue}{\mathcal{Q}}
% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}

\title{Specification of the Blockchain Layer}

\author{Marko Dimjašević}

\date{December 13, 2018}

\maketitle

\begin{abstract}
  This documents defines inference rules for operations on a blockchain as a
  specification of the blockchain layer of Cardano in the Byron release and in
  a transition to the Shelley release.
  %
  In particular, a block validity definition is given, which is accompanied by
  small-step operational semantics inference rules.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

The idea behind this document is to formalise what it means for a new block to
be added to the blockchain to be valid.
%
The scope of the document is the Byron release and a transition phase to the
Shelley release of the Cardano blockchain platform.


Unless a new block is valid, it cannot be added to the blockchain and thereby
extend it.
%
This is needed for a system that is subscribed to the blockchain and keeps a
copy of it locally.
%
In particular, this document gives a formalisation that should be
straightforward to implement in a programming language, e.g., in Haskell.

This document is intended to be read in conjunction with \cite{byron_ledger_spec},
which covers the payload carried around in the blockchain. Certain of the
underlying systems and types defined will rely on definitions in that document.

\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\item[Union override] The union override operation is defined in
  Figure~\ref{fig:unionoverride}.
  %
  \begin{figure}
    \begin{align*}
      \var{K} \restrictdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \in \var{K} \}
      & \text{domain restriction}
      \\
      \var{K} \subtractdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \notin \var{K} \}
      & \text{domain exclusion}
      \\
      \var{M} \restrictrange \var{V}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ o \in \var{V} \}
      & \text{range restriction}
      \\
      & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
      & \text{union override}\\
      & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
    \end{align*}
    \caption{Definition of the Union Override Operation}
    \label{fig:unionoverride}
  \end{figure}
\end{description}

\subsection{Sets}
\label{sec:sets}

There are several standard sets used in the document:
%
\begin{description}
\item[Booleans] The set of booleans is denoted with $\mathbb{B}$ and has two
  values, $\mathbb{B} = \{\bot, \top\}$.
\item[Natural numbers] The set of natural numbers is denoted with
  $\mathbb{N}$ and defined as $\mathbb{N} = \{0, 1, 2, \dots\}$.
\end{description}

\subsection{Blocks}
\label{sec:blocks}

\begin{figure}
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
    b & \Block & \text{block} \\
    h & \Hash   & \text{hash} \\
    pp & \ProtParams & \text{protocol parameters}
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  %
  \begin{equation*}
  \begin{array}{r@{~\in~}l@{\qquad=\qquad}r@{~\in~}lr}
    \var{bIx} & \BlockIx & \var{bIx} & \mathbb{N} & \text{Block index}
  \end{array}
  \end{equation*}
  %
  \emph{Projection functions}
  %
  \begin{align*}
    \fun{\hashname} & \in \Block \totalf \Hash
      & \text{previous block's hash} \\
    \fun{\bslname} & \in \Block \totalf \Slot & \text{block slot} \\
    \fun{\bsignername} & \in \Block \totalf \VKey & \text{block signer} \\
    \fun{\bcertsname} & \in \Block \totalf \seqof{\DCert}
      & \text{block certificates} \\
    \fun{\bsigname} & \in \Block \totalf \Sig & \text{block signature} \\
    \fun{\bdataname} & \in \Block \totalf \Data & \text{block data} \\
    \fun{\maxblocksizename} & \in \ProtParams \totalf \mathbb{N} & \text{maximum block size} \\
    \fun{\maxheadersizename} & \in \ProtParams \totalf \mathbb{N}
      & \text{maximum block header size} \\
    \fun{blockSignatureCountWindow} & \in \ProtParams \totalf \mathbb{N} & \text{Block signature count window size} \\
    \fun{blockSignatureCountThreshold} & \in \ProtParams \totalf \left[\frac{1}{5}, \frac{1}{4}\right] & \text{Block signature count threshold}
  \end{align*}
  %
  \emph{Functions}
  %
  \begin{align*}
    \fun{\hashofblockname} & \in \Block \totalf \Hash & \text{hash of block} \\
    \fun{\bsizename} & \in \Block \totalf \mathbb{N} & \text{block size in bytes} \\
    \fun{\bhdrsizename} & \in \Block \totalf \mathbb{N}
      & \text{block header size in bytes}\\
  \end{align*}
  %
  \caption{Basic Block-related Types and Functions}
  \label{fig:block-defs}
\end{figure}


A block is an element of a blockchain.
%
A blockchain is extended by appending a block, denoted by $\Block$.
%
In this document $\Block$ is kept abstract, but it is a product type with
projection functions for the following:
%
\begin{itemize}
\item a block hash pointing to the block's predecessor,
\item a block index,
\item a verification key of the block signer,
\item a list\footnote{There is no justification why this should be a list,
    instead of a set of certificates. There is no order between
    certificates. That said, list was chosen to align with the ledger
    specification.} of heavyweight delegation certificates in the body,
\item a slot it is in,
\item data that is the block body. Note this comprises delegation certificates
  and possibly other information that might not be of interest for this
  specification,
\item a cryptographic signature, and
\item a flag indicating if this is an epoch boundary block.
\end{itemize}


For every block, it is possible to compute its hash with the
$\fun{\hashofblockname}$ function.
%
Furthermore, note that the $\fun{\maxblocksizename}$ parameter of a
$\ProtParams$ is the maximum size only of blocks that are not epoch boundary
blocks.
%
Basic types and functions pertaining to blocks are given in
Figure~\ref{fig:block-defs}.

\section{Epoch transitions}

This section should cover:
\begin{itemize}
\item How we determine the end of an epoch
\item Epoch-transition bookkeeping
\end{itemize}

\section{Counting signed blocks}

\newcommand{\BSCEnv}{\type{BSCEnv}}
\newcommand{\BSCState}{\type{BSCState}}

To guard against the compromise of a minority of the genesis keys,
we require that in the rolling window of the last $K$ blocks, the number of
blocks signed by keys that $sk_s$ delegated to is no more than a threshold $K
\cdot t$, where $t$ is a constant\footnote{This is not the same $t$ from the
  Ouroboros BFT paper draft where it denotes the number of Byzantine servers,
  though it should be somehow related to it.} that will be picked in the range
$1/5 \leq t \leq 1/4$.

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{align*}
    q  & \in \Queue_\BlockIx  & \text{block index queue}\\
    \var{ds} & \in \DelegState & \text{ledger layer delegation state}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    \signmapname & \in \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map}\\
    \var{sk_s} & \in \SKeyGen \subseteq \SKey & \text{genesis block's signing key}\\
  \end{align*}
  %
  \emph{Type aliases}
  %
  \begin{align*}
    \mapqueue = \VKeyGen \totalf \Queue_\BlockIx
  \end{align*}
  \emph{Functions and relations}
  %
  \begin{align*}
    \fun{\qheadname} & \in \Queue_\BlockIx \totalf \BlockIx^? & \text{head of queue function} \\
    \fun{\qpushname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{queue push function} \\
    \fun{\qpopname} & \in \Queue_\BlockIx \totalf {\Queue_\BlockIx}^?
      & \text{queue pop function} \\
    \fun{\qrestrname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{restricted queue pop function} \\
    \fun{\incixmapname} & \in \BlockIx \times \powerset \VKeyGen \times \mapqueue \totalf \mapqueue
      & \text{block count increment function}\\
    \fun{\signname} & \in \SKey \times \Hash \times \Slot \times \Data \partialf \Sig
      & \text{signature function}\\
  \end{align*}
  \begin{align}
  \label{eq:trimix}
  \trimix{\signmapname}{\var{ix}} & = \Set{(\var{vk_s} \partialf q)}{\var{vk_s} \in \dom \signmapname.~
  q = \qrestr{\var{ix}}{(\signmap{\var{vk_s}}})} \\
  \qrestr{\var{ix}}{q} & = \
  \begin{cases}
    \qpop{q} & \text{if } \size{q} > 0 \wedge \qhead{q} + K < \var{ix} \\
    q & \text{otherwise}
  \end{cases} \\
  \label{eq:incixmap}
    \incixmap{\var{ix}}{\var{X}}{\signmapname} & = \signmapname \unionoverride
                                                 \Set{\var{vk_s} \partialf \qpush{\var{ix}}(\signmap{\var{vk_s}})}{vk_s \in \var{X}}
  \end{align}
  \caption{Blockchain signature count types and functions}
  \label{fig:defs:sigcnt}
\end{figure}

\begin{figure}[ht]
  \emph{Block signature count environments}
  \begin{equation*}
    \BSCEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pp} & \ProtParams & \text{Protocol parameters} \\
        \var{ds} & \DelegState & \text{Delegation state} \\
        \var{bIx} & \BlockIx & \text{Block index}
      \end{array}
    \right)
  \end{equation*}

  \emph{Block signature count transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{sigcnt}{\_} \var{\_} \subseteq
    \powerset (\BSCEnv \times \signmapname \times \VKey \times \signmapname)
  \end{equation*}
  \caption{Block signature count transition-system types}
  \label{fig:ts-types:sigcnt}
\end{figure}

\begin{figure}[ht]
  \begin{equation*}
    \inference
    {
      \var{K} = \fun{blockSignatureCountWindow} ~ pp & \var{t} = \fun{blockSignatureCountThreshold} ~ pp \\
      \forall \var{vk_s} \in \var{dms^{-1}} ~ \var{vk_d} . \size{\signmap{\var{vk_s}}} \leq K \cdot t \\
      \signmapname' = \incixmap{\var{bIx}}{\left( \var{dms^{-1}} ~ \var{vk_d} \right)}{(\trimix{\signmapname}{\var{bIx}})}
    }
    {
      \left(
        {\begin{array}{c}
          \var{pp} \\
          \var{ds} \\
          \var{bIx}
        \end{array}}
      \right)
      \vdash
        {\signmapname}
      \trans{sigcnt}{\var{vk_d}}
        {\signmapname'}
    }
    \label{eq:rule:sigcnt}
  \end{equation*}
  \caption{Block signature count rules}
  \label{fig:rules:sigcnt}
\end{figure}

\clearpage

\section{Block validation}
\label{sec:block-validation}

We delineate here between validating the header and body of a block. It's useful
to make this distinction since we may validate headers ahead of validating the
block body, and we have less context available to validate headers - in
particular, we must be able to validate block headers without the recent history
of block bodies.

\todo{Block header validation}
\todo{Block body validation}

\subsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from shelley-plan.md, which is written by
% Duncan Coutts

A block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a signing key $sk_d$ for which a valid heavyweight
  delegation certificate $c$ that is active at the time of signing exists.
  %
  The certificate $c$ carries information that signing rights from a
  genesis verification key $vk_s$ are transferred to a verification key $vk_d$
  starting in a slot $sl$,
\item the corresponding certificate $c$ is signed by a genesis key $sk_s$. The
  certificate therefore carries a a cryptographic signature $\sigma'$,
\item new delegation certificates that are in the body of $b$ are not in
  conflict with earlier delegation certificates,
\item the size of the block in bytes is within limits, as defined by
  protocol parameters.
\item the size of the block header in bytes is within limits, as defined by
  protocol parameters.
\end{enumerate}

\clearpage

\section{Blockchain Extension}
\label{sec:chain-extension}

\newcommand{\CEEnv}{\type{CEEnv}}
\newcommand{\CEState}{\type{CEState}}

\newcommand{\butxo}[1]{\fun{bUtxo}\ #1}

% Imported definitions
\newcommand{\UTxO}{\type{UTxO}}
\newcommand{\DIEnv}{\type{DIEnv}}
\newcommand{\DIState}{\type{DIState}}

\newcommand{\UPIEnv}{\type{UPIEnv}}
\newcommand{\UPIState}{\type{UPIState}}

\begin{figure}[ht]
  \emph{Abstract types}
  %
  \begin{align*}
    \var{data} & \in \Data    & \text{data}\\
    \var{ds} & \in \DelegState & \text{ledger layer delegation state}
  \end{align*}
  \emph{Abstract functions}
  %
  \begin{align*}
    \fun{\verifyname} & \in \VKey \times \Data \times \Sig
      & \text{verification relation} \\
    \fun{\blocksizelimitname} & \in \Block \times \ProtParams \totalf \mathbb{N}
      & \text{block size limit in bytes function} \\
    \butxo & \in \Block \totalf \UTxO & \text{Block UTxO payload} \\
    \fun{\isebbname} & \in \Block \totalf \mathbb{B} & \text{epoch boundary block check}
  \end{align*}
  %
  \caption{Blockchain Extension Types and Functions}
  \label{fig:defs:chain-extension}
\end{figure}

\begin{figure}[ht]
  % \emph{Chain extension environments}
  % \begin{equation*}
  %   \CEEnv =
  %   \left(
  %     \begin{array}{r@{~\in~}lr}
  %       \var{slot} & \Slot & \text{Current slot}
  %     \end{array}
  %   \right)
  % \end{equation*}
  \emph{Chain extension states}
  \begin{equation*}
    \CEState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{bIx} & \BlockIx & \text{Current block index} \\
        \signmapname & \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map} \\
        \var{utxo} & \UTxO & \text{UTxO} \\
        \var{ds} & \DIState & \text{Delegation state}
      \end{array}
    \right)
  \end{equation*}

  \emph{Chain extension transitions}
  \begin{equation*}
    \_ \vdash \var{\_} \trans{chain}{\_} \var{\_} \subseteq
    \powerset (\Slot \times \CEState \times \Block \times \CEState)
  \end{equation*}

  \caption{Blockchain extension transition-system types}
  \label{fig:ts-types:chain-extension}
\end{figure}

The central rule that captures blockchain extension is given with
Figure~\ref{fig:defs:chain-extension}.

\begin{figure}
  \begin{equation*}
  \inference
  { \isebb{b} & \bsize{b} \leq 2^{21} }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{ds}
       \end{array}}
    \right)
  }
  \end{equation*}
  \vspace{20pt}
  \begin{equation*}
  \inference
  {
    !\isebb{b} &
    \var{vk_d} = \bsigner{b} & \hash{b} \equiv \hashofblock{p} \\
    \bsize{b} \leq \maxblocksize{b}{\var{pp}} & \bhdrsize{b} \leq \maxheadersize{\var{pp}} \\
    \verify{\var{vk_d}}{(\bdata{b})}{(\bsig{b})} \\
    \var{pp} \vdash \var{utxo} \trans{utxow}{\butxo{b}} \var{utxo'} \\
    {\left(
      \begin{array}{l}
        pp \\
        ds \\
        bIx
      \end{array}
    \right)}
    \vdash
    \signmapname \trans{sigcnt}{\var{vk_d}} \signmapname' &&
    \var{diEnv} \vdash \var{ds} \trans{deleg}{\bcerts{b}} \var{ds'}
  }
  {
    \left(
      {\begin{array}{c}
         \var{slot}
       \end{array}}
    \right)
    \vdash
    \left(
      {\begin{array}{c}
         bIx \\
         \signmapname \\
         \var{utxo} \\
         \var{ds}
       \end{array}}
    \right)
    \trans{chain}{b}
    \left(
      {\begin{array}{c}
         bIx + 1 \\
         \signmapname' \\
         \var{utxo}' \\
         \var{ds'}
       \end{array}}
    \right)
  }
  \end{equation*}
  \caption{The Blockchain Extension Rule}
  \label{fig:blockchain-extension}
\end{figure}
\clearpage
\bibliographystyle{plainnat}
\bibliography{references}
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "nix-shell --run make"
%%% End:

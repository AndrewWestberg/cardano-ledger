\section{Protocol Parameters}
\label{sec:protocol-parameters}


% The transition from a Shelley ledger to a Goguen ledger model includes,
The most significant change that is needed is a change from the original Byron/Shelley UTxO (Unspent Transaction Output) model
to the extended UTxO model that is used for Goguen.
We denote the latter as EUTxO in this document, and use UTxO to refer to the original form.
\todo{Make sure that this is done.}
% For Plutus integration, the EUTxO model, and other Goguen features,
We require the following types (see Figure~\ref{fig:defs:protocol-parameters})
in addition to those that are already defined in the Shelley specification.


\vspace{12pt}
\begin{tabular}{lp{5in}}
  $\Language$ &
  This represents the language name/tag (including the Plutus
  version number).
  \\
  $\ExUnits$ &
  A term of this type has two integer values,
  $(mem, steps)$.
  These represent abstract notions of the relative memory usage and script execution steps,
  respectively (a ``unit model'').
  \\
  $\CostMod$ &
  A term of this type represents the vector of coefficients that are used to generate
  a term of type $\ExUnits$ given a vector of some resource primitives.  The mapping is defined
  concretely by the specific version of the Plutus interpreter that is associated with $\Language$.
%  We keep this type as
%   abstract in the specification - it is defined concretely in the Plutus interpreter.
%  The
%  conversion to $\ExUnits$ is also done by the interpreter (thus, is opaque to the ledger rules).
  \\
  $\Prices$ &
  A term of this type comprises three integer values,
  $\var{(pr_{init}, pr_{mem}, pr_{steps})}$: ($pr_{init}$) represents the initial
  cost of running a script; $pr_{mem}$ is the price (in Ada)\todo[inline]{Confirm}) per unit of memory, and $pr_{steps}$ is the price (in Ada)\todo[inline]{Also confirm} per
  reduction step. This is used to calculate the Ada cost for a specific script execution.
\end{tabular}
\vspace{12pt}



\todo[inline]{Confirm - does it make sense to compare/add etc ExUnits, rather than treating them as semantic values.}
\todo[inline]{Confirm - is price in Ada?}

We have also need a number of additional protocol parameters and accessor functions: ...\todo{List these.}

\subsection{Plutus vs. Native Script Languages}
\label{sec:plutus-native}

The new protocol parameter values are concerned with determining the cost of executing Plutus scripts (which
involve calling an external interpreter).
% These are only relevant for processing scripts that are opaque
% to the ledger, that is, scripts that are not processed by the ledger rules,
% but rather by using an interpreter. Currently, this refers specifically
% to Plutus scripts.
% Because the ledger knows only the validation result, and
% nothing about their execution, it relies on the interpreter to compute resources
% used during the validation process. Hence the need for these parameters,
% the use of which is discussed below.
%
In contrast, \emph{native ledger scripts} (such as Shelley  multi-signature scripts), are processed entirely by the ledger rules,
% Currently, this includes only the multisignature scripts.
and their costs can therefore be easily assessed prior to execution.
% In the current version of the Shelley ledger, there is no assessment of cost
% of checking multisignatures (abbreviated MSig's). Instead,
Fees for such scripts are charged based on the transaction size,
which approximates the storage and processing costs.
% incurred as a result of
% spending MSig-locked outputs are proportional to the change in transaction
% size due to including all the necessary signatures (rather than the
% cost of verifying them). Therefore, the transaction size is the only
% value needed to calculate the fees of all Shelley transactions, and MSig
% scripts do not require any cost model.
%% Doesn't add anything -- KH
%% Scripts in any future native scripting languages will also
%% have their cost analyzed by the ledger rules ahead of running them.
%% The $\Prices, \ExUnits$ or $\CostMod$ types will not be used
%% in processing native scripts. There will be language-specific
%% costing strategies added as needed to asses the running cost.
%% The running cost will be used in calculating the minimum transaction
%% fee, and its payment verified by comparing the minimum fee to the fee the transaction
%% is actually paying.

\subsection{Plutus Versions and Backwards Compatibility Requirements}
\label{sec:versions}

Each version of Plutus (as identified by a $\Language$ value) is considered to be a different
\emph{language}.  Each such language needs to be interpreted by a language-specific interpreter, called from the ledger implementation,
and provided with the arguments that it requires (which may be version-specific).
% Each language has a (version-specific) set of arguments that is passed to the corresponding script interpreter.
The $\Language$ type initially contains the value $\Plutus$\todo{V0?}.
Note that it is necessary to execute scripts both for the current language, and for all previous languages.
%
% The ledger is expected to be capable of running Plutus scripts of
% all existing versions at all times.
This implies that it is necessary to maintain all ledger
data that is needed by any past or current Plutus version. Introducing a new Plutus version will also
involve a hard fork, since the ledger rules must be updated to use the new interpreter.

\subsection{Determinism of Plutus Script Evaluation}
\label{sec:determinism}

The data that is passed to the interpreter
includes the validator\todo{explain}, redeemer\todo{explain}, information about the transaction carrying
the script, and some ledger data or protocol parameters.
%The exact set of arguments may be different for different versions.
%% A change in data passed to the interpreter for
%% validating a given script can cause a change in the validation result. Such
%% a change may occur between the time a transaction is submitted by the wallet
%% and the time the block containing it is processed.
It is necessary to maintain a predictable (deterministic) validation outcome over the period between transaction
submission and script processing.
%
In order to achieve this,
any data that is passed to the interpreter must be
identical to the data that was provided when the transaction that carries the script was
constructed.
Because of this requirement, the carrying transation thus includes a hash of any such data.
When the transaction is processed, this hash is compared with a hash of the equivalent data. If the hashes do not match, the interpreter is not invoked.
This check is part of the \emph{two-phase validation model} that conserves time and computation
resources during transaction processing (see Section~\ref{sec:utxo}).

The function $\fun{hashLanguagePP}$ (Figure~\ref{fig:defs:protocol-parameters}) selects the protocol parameters that are relevant to
a given set of languages and computes their hash
%
At this time, the only parameter that is passed to the interpreter is the version-specific cost model.
%% Not sure what this means??
% For the rule
% where this comparison is performed, see Section~\ref{sec:block-body-trans}.

\subsection{Plutus Script Evaluation Cost Model and Prices}
\label{sec:cost-mod}

A version-specific cost model is used to convert resource
primitives into the
more abstract $\ExUnits$. As this conversion is done by the Plutus interpreter,
we will keep the cost model abstract in this specification.
The actual cost models are recorded in the protocol
parameters ($\var{costmdls}$).
%
By having distinct cost models for each version and changing the conversion coefficients, we can discourage users from
paying into scripts that have been made using old versions of Plutus, by making these more expensive to execute.
%
The calculation of the actual cost, in Ada, of running
a script that takes $\var{exunits} \in \ExUnits$ resources to run,
is done by a formula specified in the ledger rules, which uses the
$\var{prices}$ parameter. This is a parameter that applies to all
scripts and cannot be varied for individual languages. This parameter
reflects the real-world costs of electicity, hardware etc.

\textbf{Limiting Script Execution Costs.}
The $\var{maxTxExUnits}$ and $\var{maxBlockExUnits}$  protocol parameters are
used to limit the total per-transaction and per-script resource use for every
type of scripts. These will only have non-trivial values for
(non-native) Plutus scripts.

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{costm} & \CostMod & \text{coefficients for cost model} \\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{plv}
      & \Language
      & \{\Plutus, \dotsb\}
      & \text{Script Language}
      \\
      \var{(pr_{init}, pr_{mem}, pr_{steps})}
      & \Prices
      & \Coin \times \Coin \times \Coin
      & \text {coefficients for ExUnits prices}
      \\
      \var{(mem, steps)}
      & \ExUnits
      & \N \times \N
      & \text{abstract execution units} \\
    \end{array}
  \end{equation*}
  %
  \emph{Protocol Parameters}
  %
  \begin{equation*}
      \begin{array}{r@{~\in~}lr}
        \var{costmdls} \mapsto (\Language \mapsto \CostMod) & \PParams & \text{script exec cost model}\\
        \var{prices} \mapsto \Prices & \PParams & \text{coefficients for ExUnits prices} \\
        \var{maxTxExUnits} \mapsto \ExUnits & \PParams & \text{max total tx script execution resources}\\
        \var{maxBlockExUnits} \mapsto \ExUnits & \PParams & \text{max total block script execution resources}\\
      \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  %
  \begin{center}
  \fun{costmdls},~\fun{maxTxExUnits},~\fun{maxBlockExUnits},~\fun{prices}
  \end{center}
  %
  \emph{Helper Functions}
  %
  \begin{align*}
    & \fun{hashLanguagePP} \in \PParams \to \powerset{(\Language)} \to \PPHash^?   \\
    & \fun{hashLanguagePP}~\var{pp}~\var{lgs} = \begin{cases}
         \fun{hash}~(\var{lgs} \restrictdom \fun{costmdls}~{pp})
                           & \text{if~} \var{lgs} \restrictdom \fun{costmdls}~{pp} \neq \{\} \\
              \Nothing & \text{otherwise} \\
      \end{cases} \\
    & \text{this calculation creates a hash for the protocol parameters that are relevant to
    a given set of versions}
  \end{align*}
  %
  \caption{Definitions Used in Protocol Parameters}
  \label{fig:defs:protocol-parameters}
\end{figure*}


\clearpage

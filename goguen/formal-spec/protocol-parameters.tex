\section{Protocol Parameters}
\label{sec:protocol-parameters}

We require following types
in addition to those already defined in the Shelley specification
(see Figure~\ref{fig:defs:protocol-parameters}):

\begin{itemize}
  \item $\Language$: The language name/tag, including the version number.
  \item $\ExUnits$: A term of this type has two integer values,
  $(mem, steps)$. These represent the amount of memory used and number
  of steps performed during the execution of a script
  respectively. These values are intentionally not in terms of any
  concrete units.
\item $\CostMod$: The cost model is used by a language interpreter to
  calculate the $\ExUnits$ used by a script. If the efficiency of a
  script interpreter is improved, this parameter can be adjusted to
  lower script execution units (and thus prices) without a hard fork.
  \item $\Prices$: A term of type is made up of three integer values,
  $\var{(pr_{init}, pr_{mem}, pr_{steps})}$. $pr_{init}$ represents a fixed
  cost of running a script, $pr_{mem}$ is a price for a unit of memory
  used by script execution, and $pr_{steps}$ is the price per
  reduction step. It is used to calculate the cost of using an amount of execution
  units.
\end{itemize}

Several additional protocol parameters and accessor functions are also necessary.
All the newly added protocol parameters are related to limiting and calculating
the script execution cost.
They are only relevant for processing scripts that are opaque
to the ledger, that is, scripts that are processed by external an interpreter.

\subsection{Plutus Versions}
\label{sec:versions}

The ledger is expected to be capable of running any script it ever
supported at all times. This means maintaining any ledger
data nedeed by any version. Introducing a new language or version of an existing language
into the set of languages is a hard fork, as the actual ledger rules
and code must be updated manually to use the new interpreter.

\subsection{Plutus Script Evaluation Determinism}
\label{sec:determinism}

Data passed to the interpreter
includes the validator, redeemer, information about the transaction carrying
the script, and some ledger data or protocol parameters.
The exact set of arguments may depend on the language (as identified by a $\Language$ value).

A change in data passed to the interpreter for
validating a given script can cause a change in the validation result. Such
a change may occur between the time a transaction is submitted by the wallet
and the time the block containing it is processed. 

It is necessary to maintain a deterministic validation outcome over this period,
so any data passed to the interpreter must be
the same as it was at the time the transaction carrying this script was
constructed.
To ensure this, the carrying transation includes the hash of any such data.
If the hash does not match the data passed to the interpreter, it is never invoked.
This check is part of the two-phase validation model for saving time and computation
resources during transaction processing (see Section~\ref{sec:two-phase}).

The function $\fun{hashLanguagePP}$ selects the protocol parameters relevant to
the a given set of languages and computes their hash.
See Figure~\ref{fig:defs:protocol-parameters}.
\begin{note}
  It's probably better to separate hashing and selecting parameters.
\end{note}

\subsection{Plutus Script Evaluation Cost Model and Prices}
\label{sec:cost-mod}

Having distinct cost models for each version will allow us to discourage users from
paying into scripts made using old versions of Plutus, which could have bugs
in them that are fixed in newer versions. Changing the conversion coefficients
of resource primitives into $\ExUnits$ can make paying into old versions
more expensive.
\begin{note}
  This seems like a bad idea. What if funds are locked by a script that forces every output of a transaction to be locked by the same script?
\end{note}

Note here that the calculation of the actual cost, in Ada, of running
running a script that takes $\var{exunits} \in \ExUnits$ resources to run,
is done by a formula specified in the ledger rules, and uses the parameter
$\var{prices}$. This is a parameter that applies to all
scripts and cannot be toggled for individual languages. This parameter is
used to reflect real-world prices of things like electicity or hardware.

\textbf{Limiting Script Execution Costs.}
The protocol parameters $\var{maxTxExUnits}$ and $\var{maxBlockExUnits}$ are
used to limit the total per-transaction and per-script resource use of all
types of scripts.

\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{costm} & \CostMod & \text{coefficients for cost model} \\
    \end{array}
  \end{equation*}
  %
  \emph{Derived types}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{plv}
      & \Language
      & \{\Plutus, \dotsb\}
      & \text{Script Language}
      \\
      \var{(pr_{init}, pr_{mem}, pr_{steps})}
      & \Prices
      & \Coin \times \Coin \times \Coin
      & \text {coefficients for ExUnits prices}
      \\
      \var{(mem, steps)}
      & \ExUnits
      & \N \times \N
      & \text{abstract execution units} \\
    \end{array}
  \end{equation*}
  %
  \emph{Protocol Parameters}
  %
  \begin{equation*}
      \begin{array}{r@{~\in~}lr}
        \var{costmdls} \mapsto (\Language \mapsto \CostMod) & \PParams & \text{script exec cost model}\\
        \var{prices} \mapsto \Prices & \PParams & \text{coefficients for ExUnits prices} \\
        \var{maxTxExUnits} \mapsto \ExUnits & \PParams & \text{max total tx script execution resources}\\
        \var{maxBlockExUnits} \mapsto \ExUnits & \PParams & \text{max total block script execution resources}\\
      \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  %
  \begin{center}
  \fun{costmdls},~\fun{maxTxExUnits},~\fun{maxBlockExUnits},~\fun{prices}
  \end{center}
  %
  \emph{Helper Functions}
  %
  \begin{align*}
    & \fun{hashLanguagePP} \in \PParams \to \powerset{(\Language)} \to \PPHash^?   \\
    & \fun{hashLanguagePP}~\var{pp}~\var{lgs} = \begin{cases}
         \fun{hash}~(\var{lgs} \restrictdom \fun{costmdls}~{pp})
                           & \text{if~} \var{lgs} \restrictdom \fun{costmdls}~{pp} \neq \{\} \\
              \Nothing & \text{otherwise} \\
      \end{cases} 
  \end{align*}
  %
  \caption{Definitions Used in Protocol Parameters}
  \label{fig:defs:protocol-parameters}
\end{figure*}

\section{Transaction Validation}
\label{sec:transactions}

This section outlines the changes that are needed to the transaction and
UTxO structure to enable non-native scripts to validate
certain actions: forging tokens, spending outputs, verifying certificates, and
verifying withdrawals).\todo{Is this the complete set of actions?}
%
Figure \ref{fig:defs:utxo-shelley-1} gives the modified transaction types.
We make the following changes and additions over the corresponding types in the
Shelley specification~\ref{XX}:

\begin{itemize}
  \item $\Value$ represents the type of
  both \emph{fungible} and \emph{non-fungible} multi-asset tokens. For details, see the multi-asset formal specification~\ref{XX}.

  \item $\RdmrsHash$ is the type of a hash of the indexed redeemer structure,
  included within a transaction (this structure is described in detail below).

  \item $\ScriptMSig$ is the type of the existing native multi-signature scripts.

  \item $\ScriptPlutus$ is a type for scripts that use the initial version of Plutus.

  \item $\Data$ is the same type as in the Plutus libraries (see the note on ``Data Representation'' below).

  \item $\Script$ is a sum type that includes all possible scripts (both native and non-native\todo{Confirm}).

  \item $\IsValidating$ is a tag that indicates that a transaction
  expects that all its non-native scripts validate.
  This tag is added by the block creator when
  constructing a block, and is checked when running scripts.\todo{Not sure I got this right?}

  \item $\IsFee$ is a tag that indicates when an input has been marked
    to be used for paying transaction fees.
    This provides a way to prevent
  the entire value of a transaction's UTxO entries being used as fees if a script fails to validate.

  \item $\TxIn$ is a transaction input. It includes a reference to the UTxO entry that it is spending
  and an $\IsFee$ tag.
% , which indicates if this input should
%   be used to pay script execution fees.

  \item $\TxOutND$ is a transaction output with no datum hash
  (this type is for VKey\todo{What is VK?} and multi-signature script outputs).

  \item $\TxOutP$ is a transaction output that comes from a Plutus script (these include a datum hash).\todo{Confirm this.}

  \item $\HasDV$
  is a tag that is attached to a transaction output if it is \emph{locked} by a Plutus
  script. The output contains an address, a value, and a datum hash.
  This tag indicates whether the transaction carrying the output
  contains, in its set of datum objects, the full datum that corresponds
  to the datum hash.

  Note that it is up to the user to decide whether the transaction should have the full datum. The purpose of
  including it is just so that it can be communicated to the user who will be spending
  the output in the future, and who will require the full datum in order to validate
  the Plutus script that is locking the output. However, this tag must be applied
  correctly, otherwise the transaction will not validate.
  \begin{note}
    The purpose of this tag is to ensure that it is evident if such a
    datum has been removed. We may do something else and remove this tag.
  \end{note}

  \item $\TxOut$ is the type of transaction outputs, either
  $\TxOutND$ or a pair of $\TxOutP$ and $\HasDV$.

  \item $\Tag$ let us differentiate what a script
  can validate, i.e. \\

  \begin{tabular}{l@{~to validate~}l}
  $\mathsf{inputTag}$ & spending a script UTxO entry, \\
  $\mathsf{forgeTag}$ & forging tokens, \\
  $\mathsf{certTag}$  & certificates with script credentials, and  \\
  $\mathsf{wdrlTag}$ & reward withdrawals from script addresses.
  \end{tabular}

  \item $\RdmrPtr$ is a pair of a tag and an index. This type is
  used to index the Plutus redeemers that are included in a transaction. See
  below.

\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\quad\quad\quad\quad}r}
      \var{v} &\Value & \text{Multi-asset value}\\
      \var{hdv} &\RdmrsHash & \text{Indexed redeemer hash}\\
      \var{msig} & \ScriptMSig & \text{Multi-signature scripts} \\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts from the initial Plutus version} \\
      \var{dat} & \Data & \text{The Plutus $\Data$ type} \\
    \end{array}
  \end{equation*}
  %
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{isv} & \IsValidating & \Bool \\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{isf}
      & \IsFee
      & \Bool
%      & \text {tag for inputs used to pay script fees}
      \\
      \var{txin}
      & \TxIn
      & \TxId \times \Ix \times \IsFee
%      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutND}
      & \Addr \times \Value
%      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutP}
      & \type{TxOutND} \times \DataHash
%      & \text{script address output}
      \\
      \var{hdv}
      & \HasDV
      & \Bool
      %      & \text {tag for outputs that come with datums}
      \\
      \var{txotx}
      & \TxOut
      & \TxOutND \uniondistinct (\TxOutP \times \HasDV)
%      & \text{transaction outputs in a transaction}
      \\
      \var{tag}
      & \Tag
      & \{\mathsf{inputTag},~\mathsf{forgeTag},~\mathsf{certTag},~\mathsf{wdrlTag}\}
      \\
      \var{dvin}
      & \RdmrPtr
      & \Tag \times \Ix
%      & \text{reverse pointer to thing dv is for}
    \end{array}
  \end{equation*}
  \caption{Definitions for Transactions}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}


\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{wits} ~\in~ \TxWitness ~=~
       & (\VKey \mapsto \Sig) & \fun{txwitsVKey} & \text{VKey signatures}\\
       & \times ~\powerset{\Script}  & \fun{txscripts} & \text{All scripts}\\
       & \times~ \powerset{\Data} & \fun{txdats} & \text{All datum objects}\\
       & \times ~(\RdmrPtr \mapsto \Data)& \fun{txrdmrs}& \text{Indexed redeemers}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txbody} ~\in~ \TxBody ~=~
      & \powerset{\TxIn} & \fun{txinputs}& \text{Inputs}\\
      &\times ~(\Ix \mapsto \TxOut) & \fun{txouts}& \text{Outputs}\\
      & \times~ \seqof{\DCert} & \fun{txcerts}& \text{Certificates}\\
       & \times ~\Value  & \fun{forge} &\text{A forged value}\\
       & \times ~\ExUnits  & \fun{txexunits}& \text{Script exec. budget}\\
       & \times ~\Coin & \fun{txfee} &\text{Non-script fee}\\
       & \times ~(\Slot\times\Slot) & \fun{txfst},~\fun{txttl} & \text{Validity interval}\\
       & \times~ \Wdrl  & \fun{txwdrls} &\text{Reward withdrawals}\\
       & \times ~\Update  & \fun{txUpdates} & \text{Update proposals}\\
       & \times ~\PPHash^?  & \fun{ppHash} & \text{Hash of PPs}\\
       & \times ~\RdmrsHash^? & \fun{rdmrsHash} & \text{Hash of indexed redeemers}\\
       & \times ~\MetaDataHash^? & \fun{txMDhash} & \text{Metadata hash}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txg} ~\in~ \GoguenTx ~=~
      & \TxBody & \fun{txbody} & \text{Body}\\
      & \times ~\TxWitness & \fun{txwits} & \text{Witnesses}\\
      & \times ~\IsValidating & \fun{txvaltag}&\text{Validation tag}\\
      & \times ~\MetaData^? & \fun{txMD}&\text{Metadata}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l@{\qquad\qquad}l}
\qquad\qquad      \var{tx} & \Tx & \ShelleyTx \uniondistinct \GoguenTx &
      \text{A Shelley or Goguen transaction}\\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad}l}
      \fun{getValue} & \TxOut \uniondistinct \UTxOOut \to \Value & \text{Output value} \\
      \fun{getAddr} & \TxOut \uniondistinct \UTxOOut \to \Addr & \text{Output address} \\
      \fun{getDataHash} & \TxOut \uniondistinct \UTxOOut \to \DataHash & \text{Data hash}
    \end{array}
  \end{equation*}
  \caption{Definitions for transactions, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}


\textbf{Data Representation.}
The type $\Data$ is a Plutus type that represents all valid ground types in Plutus\todo{Confirm}.
\begin{note}
There is a similar type in the
ledger. We do not assume these are the same $\Data$, but we do assume there
is structural equality between them. TODO: {Fix this.  Is one a subset of the other?  Are they actually related in any way; if so, how?}
  Is this supposed to be this similar type? From what I've seen, those
  two types are not actually equal, so this needs an update.
\end{note}

\subsection{Witnessing}
Figure \ref{fig:defs:utxo-shelley-2} defines the witness type, $\TxWitness$.  This contains everything
in a transaction that is needed for witnessing, namely:

\begin{itemize}
  \item VKey\todo{What is VK} signatures;
  \item a set of scripts that is needed to \emph{validate} the transaction, including for forging tokens, spending outputs, verifying certificates, and
  verifying withdrawals;
  \item a set of terms of type $\Data$, which contains all required datum objects; and
  \item a map of $\Data$ values indexed by $\RdmrPtr$, which includes all the
  required redeemers.
\end{itemize}

Note that there is a difference between the way scripts and datum objects are included in
a transaction (as a set) versus how redeemers are included
(as an indexed structure). % This is driven by their different relationships to the item:

\begin{description}
\item
  [Hash reference (script/datum object):]
  The item that needs to be validated (output, forge, etc.) explicitly references the hash of
  the witness data.
%  This is the case for all scripts and datum:
  Script addresses, currency IDs, and certificate credentials must contain
  the hash of the validator script that will be run, and script-locked UTxO entries
  must contain the hash of a datum. % which has to be included. Included in what??

  \item[No hash reference (redeemers):] The item that needs to be validated has no explicit % link to, hash of, or
  hash reference to the witness data.
  % This is the case for redeemers.
  In this case, we use a reverse pointer approach and
  index the redeemer by a pointer to the item for which it will be used.
  For details on how a script finds its redeemer, see Section~\ref{sec:scripts-inputs}.
\end{description}

\subsection{Goguen transactions}
We have also made the following changes to
the body of the transaction:

\begin{itemize}
  \item A term of type $\ExUnits$ is included, which is the total quantity of execution units
  that may be used by all non-native scripts in the transaction.
  This execution units budget is intended to be computed
  by executing the scripts off-chain before the transaction is submitted.
  \item The body has a hash of the the indexed redeemer structure
    with accessor $\fun{rdmrsHash}$. The reason for including this hash is explained below.
  \item A hash of a subset of the current protocol parameters relevant for script execution is included.
\end{itemize}

Finally, the complete Goguen transaction is made up of:

\begin{itemize}
  \item the transaction body
  \item all info needed for transaction witnessing
  \item $\IsValidating$ is a tag that is
  set by the user submitting the block containing this transaction.
  Its correctness is verified as part of the ledger rules, and the block is
  deemed invalid if this tag is applied incorrectly.
  It can later be used to re-apply blocks without performing script validation
  again. This tag does not need to be signed, since incorrect use will result
  in the whole block being invalid, which benefits no one.
  \begin{note}
    Not sure if I understand that argument, but it cannot be signed,
    because it's not applied by the transaction creator.
  \end{note}
  \item transaction metadata
\end{itemize}

\subsection{Processing Shelley Transactions in the Goguen Era}
Everything we have discussed so far in this document is about the structure and data
in Goguen era protocol parameters and transactions. Some type names are reinterpreted
for different purposes in the Goguen era than they were used for in Shelley, and
we specify the differences in these cases.

To make the transition from one era to the next smoother and less restrictive,
in the Goguen era, we will be able to process both transaction formats.
For this reason, we refer to the Shelley
trasaction type as $\ShelleyTx$, and $\GoguenTx$ is the new style Goguen transaction.
A true Goguen transaction is really of either type,
i.e. $\ShelleyTx \uniondistinct \GoguenTx$.

Shelley transactions have less data than the Goguen ones, so we can interpret
a Shelley transaction as a Goguen one and process it using Goguen ledger
rules. A crucial part of a Shelley transaction,
however, that cannot be transformed, is the witnesses.
We will specify how to verify signatures before transforming and processing
the rest of a Shelley transction in the Goguen format when we discuss witnessing.

\subsection{Additional Role of Signatures on TxBody}
The transaction body must contain every bit of data
(or at least the hash of the data) that can influence the
on-chain transfer of value resulting from this transaction being processed
(see Figure \ref{fig:defs:utxo-shelley-2}).
This means that, for example,
every input being spent and every output being created are in the body.

As a valid transaction can now be "fully validated" or "only paying
fees" (explained in detail in Section~\ref{sec:utxo}), anything that
can influence these outcomes has to be included in the body as well.

There is no need to ever sign anything related to validator scripts or datum objects,
because a hash of every validator script that will be run during the validation
of the transaction is always part of the body, and the hash of every datum
is recorded in the UTxO.

The body is signed by every key
whose outputs are being spent, which additionally offers
protection from tampering with Plutus interpreter arguments, which may cause
script validation failure (thus putting the transaction in the "only paying fees" case).
The hash of the indexed redeemer structure and the protocol parameters used by
script interpreters are included in the body for this reason. In the future, other parts of the ledger
state may need to be included in this hash as well, if they are passed as
arguments to new interpreters. Note also that data from the UTxO
is passed to the interpreter, but does not require this type of hash comparison.
This is because if the entries the transaction being processed is trying to
spend have already been spent, there is a phase 1 validation check that
will fail.

Anyone whose tokens are being spent as part of a given transaction
signs the transaction body. The body also includes the for-fee tags attached to inputs.
Because of this, the users whose tokens are being spent by the transaction have
signed their selection of
inputs that will be put in the fee pot in case of script validation failure.
As before, a change in the body of the transaction
will make the transaction completely invalid, rather than cause the fee-paying script validation
failure or change the amount of fees it pays.

\subsection{Partially processing transactions}

Note that in Goguen, it is possible for a transaction
to either be processed in full, or do nothing but pay fees for script
validation (in the case of script validation failure, see Section
\ref{sec:utxo} for details).
In designing a way to prevent all Ada in the transaction outputs from going into
the fee pot (in case of script validation failure), we have considered two
possibilities:

\begin{itemize}
  \item[(-)] programmatically select the inputs which will be used to pay fees
  \item[(-)] allow the user to decide which inputs will be used to pay fees
\end{itemize}

We have decided to give control over input selection for this purpose to the user,
as users may have different considerations when making their selection. This
option will additionally allow users to write their own programmatic solutions
to choosing for-fees inputs.

Only VKeys that spend inputs\todo{Inputs that spend VKeys? Or VKeys that spend inputs?} or native scripts that spend inputs can
be used to pay fees. In Shelley, spending VKey or script outputs is
validated in a single witnessing rule application, so either all
required signatures are valid, or a transaction is completely
invalid. We kept this model, but chose a different approach to
charging users for running Plutus scripts, see
Section~\ref{sec:two-phase}.

It is expected that Plutus scripts will be more expensive to run, on
average, than only checking signatures. We want to charge users for
running Plutus scripts, even if they do not validate. The outputs
spent to pay for running them (the ones marked as for-fees) must be
validated fully before validating Plutus scripts.

\subsection{Protocol Parameter Hash Comparison Considerations}

\begin{note}
  This should probably be in the previous section, but we don't have
  the Script type there. Maybe move it there anyways and either
  reference to this section or move the script type there as well...
\end{note}

To select the relevant protocol parameters to hash, we have defined two helper
functions (see Figure \ref{fig:defs:functions-chain-helper}). The first
is an accessor function that returns the language tag of a given script, $\fun{language}$.
The second is $\fun{cmlangs}$, which, given a set of scripts, returns the set
of language tags of scripts whose languages have a corresponding cost model,
e.g. MSig (recall the discussion in \ref{sec:plutus-native}).
We will use these in the rules we present later to compare the hashes.

\begin{figure*}[htb]
  \emph{Helper Functions}
  %
  \begin{align*}
    \fun{language} ~\in~& \Script \to \Language \\
    &\text{returns the language tag, $\Plutus$ for Plutus V1}
    \nextdef
    \fun{cmlangs} ~\in~& \powerset{\Script} \to \powerset{(\Language)} \\
    \fun{cmlangs}~ \var{scrts} ~=~ & \{ \fun{language}~\var{scr} ~\vert~
      \var{scr}~\in~ \var{scrts}, \fun{language}~\var{scr} \in \{\Plutus\}  \}\\
    &\text{get all languages that have cost models}
  \end{align*}
  \caption{Languages and Plutus Versions}
  \label{fig:defs:functions-chain-helper}
\end{figure*}

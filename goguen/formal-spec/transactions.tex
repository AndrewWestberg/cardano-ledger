\section{Transactions}
\label{sec:transactions}

In this chapter, we outline the changes necessary to transaction and
UTxO structure to make it possible to use Plutus scripts to validate
certain actions. Note that we use EUTxO and UTxO interchangably here,
implicitly referring to the extended version.

In Figure \ref{fig:defs:utxo-shelley-1}, we give the transaction types modified
to support Plutus.

These types are consistent with the Shelley ledger
as much as possible,
except for the following changes and additions:

\begin{itemize}
  \item $\RdmrsHash$ is the type of hashes of the indexed redeemer structure
  included in the transaction (details about this structure below).

  \item  $\ScriptMSig$ is the native multisignature scripts already supported.

  \item $\ScriptPlutus$ is a type for scripts made with the Plutus version
  that is the first version of Plutus supported. Subsequent versions will
  have names like $\type{ScriptPlutusV2}$. Recall that introducing
  a new version of Plutus necessitates a hard fork, and requires changes
  to the formal and executable specs.

  \item $\Yes$ and $\Nope$: These are single-value types used in tags. These
  values are used instead of booleans for clarity.

  \item The tags indicate which of the (currently, four) types of things a script
  can be validating, i.e. \\
  $\mathsf{inputTag}$ is for validating spending a (Plutus) script UTxO entry, \\
  $\mathsf{forgeTag}$ is for validating forging tokens, \\
  $\mathsf{certTag}$  is for validating certificates with script credentials, and  \\
  $\mathsf{wdrlTag}$ is for validating reward withdrawals from (Plutus) script addresses.

  \item $\Script$ is a sum type for all types of scripts, currently only
  Plutus V1 and multisig.
  \item $\IsValidating$ is a tag that indicates when a transaction is
  expected to have all the non-native scripts inside it validate.
  This value is added by the block creator when
  constructing a block, and is checked as part of running scripts.
  $\Yes$ for when when all scripts will validate,
  $\Nope$ is for when one of them does not.

  \item $\Data$ refers to the type defined in Plutus libraries, but is
  related to a ledger type (see note "Data Representation" below).

  \item $\Value$ is the multicurrency type used to represent
  both fungible and non fungible tokens. For details, see the MA spec.

  \item $\IsFee$ is a tag that indicates when an input has been marked
  to be used for paying transaction fees ($\Yes$ for when it is for fees,
  $\Nope$ when it is not). The purpose of this tag is to give users a way to prevent
  the entire value of the UTxO entries spent by the transaction
  from going into the fee pot in case of script validation failure.
  Instead, only the total amount referenced by for-fees inputs goes
  to the fee pot.

  Note that in the extended UTxO model, it is possible for a transaction
  to either be processed in full, or do nothing but pay fees for script
  validation (in the case of script validation failure, see Section
  \ref{sec:utxo} for details).
  In designing a way to prevent all Ada in the transaction outputs from going into
  the fee pot (in case of script validation failure), we have considered two
  possibilities:

  \begin{itemize}
    \item[(-)] programmatically select the inputs which will be used to pay fees
    \item[(-)] allow the user to decide which inputs will be used to pay fees
  \end{itemize}

  We have decided to give control over input selection for this purpose to the user,
  as users may have different considerations when making their selection. This
  option will additionally allow users to write their own programmatic solutions
  to choosing for-fees inputs.

  Only VK-spending inputs and native-script (MSig) spending inputs can
  be used to pay fees. In Shelley, spending VK or MSig outputs is
  validated in a single witnessing rule application, so either all
  required signatures are valid, or a transaction is completely
  invalid. We kept this model, but chose a different approach to
  charging users for running Plutus scripts, see
  Section~\ref{sec:two-phase}.

  It is expected that Plutus scripts will be more expensive to run, on
  average, than only checking signatures. We want to charge users for
  running Plutus scripts, even if they do not validate. The outputs
  spent to pay for running them (the ones marked as for-fees) must be
  validated fully before validating Plutus scripts.

  \item $\UTxOIn$ is the type of the keys in the UTxO finite map. This
  is the same as the type of UTxO keys in Shelley, but we have changed
  the name because the types of transaction inputs and UTxO keys
  differ in Goguen.

  \item $\TxIn$ is a transaction input. It includes the reference to the UTxO entry it is spending
  (the UTxO output reference part) and the $\IsFee$ tag, which indicates if this input should
  be used to pay script execution fees.

  \item $\TxOutND$: A transaction output with no datum hash
  (this type is for VK and multisig scripts outputs).

  \item $\TxOutP$: A transaction output type for Plutus
  script outputs (which include datum hash).

  \item $\HasDV$:
  This is a tag attached to a transaction output if it is locked by a Plutus
  script. That is, the output contains an address, a value, and necessarily a
  hash of a datum.
  This tag indicates whether the transaction carrying the output
  contains, in its set of datum objects, the full datum corresponding
  to the hash of the datum in the output.

  Note that it is up to the user
  to decide whether the transaction should have the full datum. The purpose of
  including it is strictly to communicate it to the user who will be spending
  the output in the future, and will require the full datum to validate
  the Plutus script locking the output. However, this tag must be applied
  correctly, otherwise the transaction will not validate.

  \item $\UTxOOut$ is the type of UTxO entry that gets created when a transaction
  output is processed. Note that, like in the case of the type of transaction inputs,
  the type of a transaction output is distinct from the type of the
  UTxO entry that gets created with the transaction output data.

  The (extended) UTxO entries in the Goguen era include the slot numbers associated with each output
  to indicate when the output was created.
  This feature will be used for functionality that will be added in the future.

  \item $\TxOut$ : The type of outputs carried by a transaction,
  $\TxOutND$ or the pair of $\TxOutP$ with the tag $\HasDV$.

  \item $\UTxO$ entries are stored in the finite map $\UTxOIn\mapsto \UTxOOut$.

  \item $\RdmrPtr$: This type is a pair of a tag and an index. This type is
  used to index Plutus redeemers that are included in a transaction. More on this
  below.

  \item $\CurItem$ is either the hash of a
  forging script (currency ID), the current transaction input being
  spent, the current reward
  withdrawal, or the current certificate being validated.
  This current item is a sum type of all the types of things for which we want to
  run scripts to validate.

\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{v} &\Value & \text{Multi-asset value}\\
      \var{hdv} &\RdmrsHash & \text{hash of the indexed redeemers structure}\\
      \var{quan} & \Quantity & \text{quantity of a token}\\
      \var{msig} & \ScriptMSig & \text{Multisig scripts} \\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts of initial Plutus version} \\
      \var{yes} & \Yes & \text{tag type for yes} \\
      \var{no} & \Nope & \text{tag type for no} \\
      \var{dat} & \Data & \text{the $\Data$ type} \\
    \end{array}
  \end{equation*}
  %
  \emph{Tag types}
  \begin{center}
    $\mathsf{inputTag},~\mathsf{forgeTag},~\mathsf{certTag},~\mathsf{wdrlTag}$
  \end{center}
  %
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{isv} & \IsValidating & \Yes \uniondistinct \Nope \\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{isf}
      & \IsFee
      & \Yes \uniondistinct \Nope
%      & \text {tag for inputs used to pay script fees}
      \\
      \var{uin}
      & \UTxOIn
      & \TxId \times \Ix
%      & \text{transaction output preference}
      \\
      \var{txin}
      & \TxIn
      & \TxId \times \Ix \times \IsFee
%      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutND}
      & \Addr \times \Value
%      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutP}
      & \type{TxOutND} \times \DataHash
%      & \text{script address output}
      \\
      \var{hdv}
      & \HasDV
      & \Yes \uniondistinct \Nope
      %      & \text {tag for outputs that come with datums}
      \\
      \var{uout}
      & \UTxOOut
      & (\TxOutND \uniondistinct \TxOutP) \times \Slot
%      & \text{transaction outputs}
      \\
      \var{txotx}
      & \TxOut
      & \TxOutND \uniondistinct (\TxOutP \times \HasDV)
%      & \text{transaction outputs in a transaction}
      \\
      \var{utxo}
      & \UTxO
      & \UTxOIn \mapsto \UTxOOut
%      & \text{unspent tx outputs}
      \\
      \var{dvin}
      & \RdmrPtr
      & (\mathsf{inputTag} \uniondistinct \mathsf{forgeTag} \uniondistinct
      \mathsf{certTag} \uniondistinct \mathsf{wdrlTag}) \times \Ix
%      & \text{reverse pointer to thing dv is for}
      \\
      \var{cur}
      & \CurItem
      & \CurrencyId \uniondistinct (\TxId \times \Ix) \uniondistinct \AddrRWD \uniondistinct \DCert
%      & \text{item the script is validated for}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}


\textbf{Data Representation.}
The type $\Data$ is a Plutus type, however, there is a similar type in the
ledger. We do not assume these are the same $\Data$, but we do assume there
is structural equality between them.

\textbf{Witnessing.}
In Figure \ref{fig:defs:utxo-shelley-2}, the type $\TxWitness$ contains everything
in a transaction that is needed for witnessing (script and VK), including

\begin{itemize}
  \item VK signatures, as before
  \item a set of scripts (this includes scripts of all languages, and for all
  validation purposes - forging tokens, spending outputs, verifying certificates, and
  verifying withdrawals)
  \item a set of terms of type data, which contains all required datum objects
  \item an structure indexed by $\RdmrPtr$, with $\Data$ values, which includes all
  required redeemers
\end{itemize}

There is a difference between the way scripts and datum objects are included in
a transaction (as a set) versus how redeemers are
(as an indexed structure). The reason for this difference is a matter of matching
the pieces of witnessing info to the thing it is required for witnessing. There
are two possibilities here:

\begin{itemize}
  \item[(1)] The item being validated (output, forge, etc.) explicitly references
  the piece needed for witnessing, usually by containing its hash.
  In particular, this is the case for all scripts.
  Script addresses, currency IDs, and certificate credentials must contain
  the hash of the validator script that will be run.

  To find the script, we can look through
  the set of scripts for the one with the matching hash value.
  This is also the case with hashes of datum objects. A Plutus-script locked
  UTxO entry contains the hash of the datum, and we can look for
  the datum with this hash in the set.

  \item[(2)] The item being validated has no explicit link to, hash of, or
  reference to, the piece of data needed for validation. In this case, we must create
  the link.

  For redeemers, we use a reverse pointer approach. Instead of pairing
  a pointer (to the correct redeemer) with the item that redeemer is needed for,
  we make the index of the redeemer the pointer to the item for
  which it will be used. This pointer is the key in the indexed redeemer structure.
  This pointer is a pair of a tag indicating the type of
  thing being validated, and an index of it in the structure (list, set, or map)
  where it is stored.
\end{itemize}

\textbf{Body of the Transaction.}
We have also made the following changes to
the body of the transaction:

\begin{itemize}

  \item We have changed $\fun{txinputs}$ to map to $\TxIn$, and added other the relevant
  accessor functions. The transaction still contains inputs ($\TxIn$), and
  outputs ($\TxOut$), which are of different types than for Shelley transactions.
  \item The body now includes a term of type $\Value$, which represents
  the tokens forged (or taken out of circulation, if the quantity is negative)
  by the transaction,
  with accessor $\fun{forge}$. Ada cannot be forged this way.
  \item The body now includes a term of type $\ExUnits$, which is the total quantity of execution units
  that may be used by all Plutus scripts in the transaction.
  This execution units "budget" is pre-computed off-chain by a Plutus interpreter
  before the transaction is submitted, with accessor $\fun{txexunits}$.
  \item The
  time to live $\Slot$ was replaced by a liveness interval $\Slot \times \Slot$,
  where the first slot is accessed by $\fun{txfst}$.
  \item The body has a hash of the the indexed redeemer structure
    with accessor $\fun{rdmrsHash}$.
  (only the ones relevant to Plutus script validation of each Plutus
  version of the transaction's validators), $\PPHash$, with accessor $\fun{ppHash}$.
\end{itemize}

\textbf{Additional Role of Signatures on TxBody.}
Note that the transaction body must contain every bit of data
(or at least the hash of the data) that can influence the
on-chain transfer of value resulting from this transaction being processed
(see Figure \ref{fig:defs:utxo-shelley-2}).
In the classic UTxO case, this means that, for example,
every input being spent and every output being created are in the body.

There is no need to ever sign anything related to validator scripts or datum objects,
because a hash of every validator script that will be run during the validation
of the transaction is always part of the body, and the hash of every datum
is recorded in the UTxO.

In the EUTxO case, this means additionally including everything in the body that can change
the validation outcome of a transaction between "fully validated", and "only
paying fees" (two distinct cases of value transfer, which
we will explain in Section~\ref{sec:utxo}).

The signatures on transactions in both the extended and basic UTxO models
are outside the body of the transaction.
In both the basic and extended UTxO model, the body is signed by every key
whose outputs are being spent. In the extended case, this additionally offers
protection from tampering with Plutus interpreter arguments, which may cause
script validation failure (thus putting the transaction in the "only paying fees" case).
In particular, the hash of the indexed redeemer structure, which has type
$\RdmrPtr \mapsto \Data$, is part of the body.

Anyone whose tokens are being spent as part of a given transaction
signs the transaction body. The body also includes the for-fee tags attached to inputs.
Because of this, the users whose tokens are being spent by the transaction have
signed their selection of
inputs that will be put in the fee pot in case of script validation failure.
With this body structure, like in the basic UTxO case, a change in the body of the transaction
will make the transaction completely invalid, rather than cause the fee-paying script validation
failure or change the amount of fees it pays.

\textbf{GoguenTx}
Finally, the complete Goguen transaction is made up of:

\begin{itemize}
  \item the transaction body
  \item all info needed for transaction witnessing
  \item $\IsValidating$ is a tag that is
  set by the user submitting the block containing this transaction.
  Its correctness is verified as part of the ledger rules, and the block is
  deemed invalid if this tag is applied incorrectly.
  It can later be used to re-apply blocks without performing script validation
  again. This tag does not need to be signed, since incorrect use will result
  in the whole block being invalid, which benefits no one.
  \item transaction metadata
\end{itemize}

\textbf{Processing Shelley Transactions in the Goguen Era.}
Everything we have discussed so far in this document is about the structure and data
in Goguen era protocol parameters and transactions. Some type names are reinterpreted
for different purposes in the Goguen era than they were used for in Shelley, and
we specify the differences in these cases.

To make the transition from one era to the next smoother and less restrictive,
in the Goguen era, we will be able to process both transaction formats.
For this reason, we refer to the Shelley
trasaction type as $\ShelleyTx$, and $\GoguenTx$ is the new style Goguen transaction.
A true Goguen transaction is really of either type,
i.e. $\ShelleyTx \uniondistinct \GoguenTx$.

Shelley transactions have less data than the Goguen ones, so we can interpret
a Shelley transaction as a Goguen one and process it using Goguen ledger
rules. A crucial part of a Shelley transaction,
however, that cannot be transformed, is the witnesses.
We will specify how to verify signatures before transforming and processing
the rest of a Shelley transction in the Goguen format when we discuss witnessing.

\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{wits} ~\in~ \TxWitness ~=~
       & (\VKey \mapsto \Sig) & \fun{txwitsVKey} & \text{VK signatures}\\
       & \times ~\powerset{\Script}  & \fun{txscripts} & \text{all scripts}\\
       & \times~ \powerset{\Data} & \fun{txdats} & \text{all datum objects}\\
       & \times ~(\RdmrPtr \mapsto \Data)& \fun{txrdmrs}& \text{indexed redeemers}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txbody} ~\in~ \TxBody ~=~
      & \powerset{\TxIn} & \fun{txinputs}& \text{inputs}\\
      &\times ~(\Ix \mapsto \TxOut) & \fun{txouts}& \text{outputs}\\
      & \times~ \seqof{\DCert} & \fun{txcerts}& \text{certificates}\\
       & \times ~\Value  & \fun{forge} &\text{value forged}\\
       & \times ~\ExUnits  & \fun{txexunits}& \text{script exec budget}\\
       & \times ~\Coin & \fun{txfee} &\text{non-script fee}\\
       & \times ~(\Slot\times\Slot) & \fun{txfst},~\fun{txttl} & \text{validity interval}\\
       & \times~ \Wdrl  & \fun{txwdrls} &\text{reward withdrawals}\\
       & \times ~\Update  & \fun{txUpdates} & \text{update proposals}\\
       & \times ~\PPHash^?  & \fun{ppHash} & \text{hash or PPs}\\
       & \times ~\RdmrsHash^? & \fun{rdmrsHash} & \text{hash of indexed rdmrs}\\
       & \times ~\MetaDataHash^? & \fun{txMDhash} & \text{metadata hash}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txg} ~\in~ \GoguenTx ~=~
      & \TxBody & \fun{txbody} & \text{body}\\
      & \times ~\TxWitness & \fun{txwits} & \text{witnesses}\\
      & \times ~\IsValidating & \fun{txvaltag}&\text{validation tag}\\
      & \times ~\MetaData^? & \fun{txMD}&\text{metadata}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{tx} & \Tx & \ShelleyTx \uniondistinct \GoguenTx
      \text{~~a Shelley or Goguen transaction}\\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{getValue} & \TxOut \uniondistinct \UTxOOut \to \Value & \text{output value} \\
      \fun{getAddr} & \TxOut \uniondistinct \UTxOOut \to \Addr & \text{output address} \\
      \fun{outref} & \TxIn \to (\TxId \times \Ix) & \text{output reference $(txid,ix)$} \\
      \fun{getDataHash} & \TxOut \uniondistinct \UTxOOut \to \DataHash & \text{data hash} \\
      \fun{getDataTag} & \TxOut \to \HasDV & \text{data} \\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}

\textbf{Protocol Parameter Hash Comparison Considerations.}
Recall that to ensure deterministic script validation outcome, we must include
a hash of certain on-chain data (currently, only some protocol parameters)
inside the body of the transaction. This hash is accessed by $\fun{ppHash}$.
We must also compute the hash of a subset of the actual current protocol parameter values,
and compare it to the hash inside the transaction.

To select the relevant protocol parameters to hash, we have defined two helper
functions (see Figure \ref{fig:defs:functions-chain-helper}). The first
is an accessor function that returns the language tag of a given script, $\fun{language}$.
The second is $\fun{cmlangs}$, which, given a set of scripts, returns the set
of language tags of scripts whose languages have a corresponding cost model,
e.g. MSig (recall the discussion in \ref{sec:plutus-native}).
We will use these in the rules we present later to compare the hashes.

Note that at this time, only data from the protocol parameters must be hashed
for the comparison we defined. For future Plutus versions, parts of the ledger
state may need to be included in this hash as well, if they are passed as
arguments to the new interpreter versions. Note also that data from the UTxO
is passed to the interpreter, but does not require this type of hash comparison.
This is because if the entries the transaction being processed is trying to
spend have already been spent, there is a phase 1 validation check that
will fail.

In the future, additional functionality may be supported by the ledger that
allows a sequence of transactions built over a period of time to be put on-chain
as a single transaction. Over this period of time, the parameters or ledger
data that must be passed as an argument to script interpreters could have changed.
As a result, this transaction (that contains the whole sequence of
transactions) is still obligated to include the hash of the current parameters
and any additional script processing fees.

Additional fees may be required because of the changes in prices or the cost model
for script interpreter versions of the scripts inside the transaction.

\begin{figure*}[htb]
  \emph{Helper Functions}
  %
  \begin{align*}
    \fun{language} ~\in~& \Script \to \Language \\
    &\text{returns the language tag, $\mathsf{plcV1Tag}$ for Plutus V1} \\
    \nextdef
    \fun{cmlangs} ~\in~& \powerset{\Script} \to \powerset{(\Language)} \\
    \fun{cmlangs}~ \var{scrts} ~=~ & \{ \fun{language}~\var{scr} ~\vert~
      \var{scr}~\in~ \var{scrts}, \fun{language}~\var{scr} \in \{\mathsf{plcV1Tag} \}  \}\\
    &\text{get all languages that have cost models (just Plutus V1 at this time)} \\
  \end{align*}
  \caption{Languages and Plutus Versions}
  \label{fig:defs:functions-chain-helper}
\end{figure*}

\textbf{Plutus Script Validation}
In Figure \ref{fig:defs:functions-valid}, abstract functions for script validation
are presented.

\begin{itemize}
  \item $\fun{valContext}$ constructs the validation context value passed
  to the script interpreter (all the necessary transaction and chain state data)
  \item $\fun{hashScript},~ \fun{hashData}$ are abstract hashing functions.
  \item $\fun{runMSigScript}$ (replacing $\fun{evaluateScript}$ in Shelley the ledger spec) performs
  validation for multi-sig scripts.
  This validation works exactly as before.
  \item $\fun{runPLCScript}$ performs validation for Plutus scripts. It takes the following
  arguments:
  \begin{itemize}
  \item A cost model. The specific cost model is selected according to the Plutus
  version of the script, and is passed to allow the interpreter to do the
  correct conversion of the quantity of resource primitives the script validation
  computation used into $\ExUnits$. T
  \item
  a list of (at most three) terms of type $\Data$ (the datum, redeemer,
  and the validation context).
  \item the execution units budget (the maximum $\var{exunits}$
  the validation is allowed to use)
  \end{itemize}
  The script validation function outputs the pair of the validation result
  and the remaining execution units (after the ones used by script execution
  have been subtracted). Note that script exeuction stops if the full execution
  units budget has been spent before the validation is complete.
\end{itemize}

\begin{note}
  \textbf{Know your contract arguments}
A Plutus validator script may receive either a list of three terms of type $\Data$,
such as for output locking scripts, or two terms (redeemer and context, with
no datum), such as in the rest of the Plutus scripts use cases.
Contract authors must keep this in mind when writing contracts, as there is
only one function (per Plutus version) to interface with the Plutus interpreter,
that runs every kind of Plutus script - with no knowledge of what $\Data$ arguments
are passed to it via this list.
\end{note}

\begin{figure*}[htb]
  \emph{Abstract Script Validation Functions}
  %
  \begin{align*}
     &\fun{hashScript} \in  ~\Script\to \PolicyID \\
     &\text{compute script hash} \\~\\
     &\fun{hashData} \in  ~\Data \to \DataHash \\
     &\text{compute hash of data} \\~\\
     &\fun{valContext} \in  \UTxO \to \GoguenTx \to \CurItem \to \Data \\
     &\text{build Validation Data} \\~\\
     &\fun{runMSigScript} \in\ScriptMSig\to \GoguenTx \to \IsValidating  \\
     &\text{validation of a multi-sig script} \\~\\
     &\fun{runPLCScript} \in \CostMod \to\ScriptPlutus \to
    \seqof{\Data} \to \ExUnits \to (\IsValidating \times \ExUnits) \\
     &\text{resource-restricted validation of a Plutus script}
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{cm},\var{exunits}}(\var{dataval},~\var{rdmr},~\var{ptx})
    &=& \fun{runPLCScript} ~{cm}~\var{script_v}~((\var{dataval};~\var{rdmr};~\var{ptx};\epsilon),~
    \var{exunits})
  \end{align*}
  \caption{Script Validation, cont.}
  \label{fig:defs:functions-valid}
\end{figure*}


\clearpage

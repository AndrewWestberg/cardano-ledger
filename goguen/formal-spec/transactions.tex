\section{Transaction Validation}
\label{sec:transactions}

This section outlines the changes that are needed to the transaction and
UTxO structure to enable non-native scripts to validate
certain actions: forging tokens, spending outputs, verifying certificates, and
verifying withdrawals).\todo{Is this the complete set of actions?}
%
Figure \ref{fig:defs:utxo-shelley-1} gives the modified transaction types.
We make the following changes and additions over the corresponding types in the
Shelley specification~\cite{XX}:

\begin{itemize}
  \item $\Value$ represents the type of
  both \emph{fungible} and \emph{non-fungible} multi-asset tokens. For details, see the multi-asset formal specification~\cite{XX}.

  \item $\RdmrsHash$ is the type of a hash of the indexed redeemer structure,
  included within a transaction (this structure is described in detail below).

  \item $\ScriptMSig$ is the type of the existing native multi-signature scripts.

  \item $\ScriptPlutus$ is a type for scripts that use the initial version of Plutus.

  \item $\Data$ is the same type as in the Plutus libraries (see the note on ``Data Representation'' below).

  \item $\Script$ is a sum type that includes all possible scripts (both native and non-native\todo{Confirm}).

  \item $\IsValidating$ is a tag that indicates that a transaction
  expects that all its non-native scripts validate.
  This tag is added by the block creator when
  constructing a block, and is checked when running scripts.\todo{Not sure I got this right?}

  \item $\IsFee$ is a tag that indicates when an input has been marked
    to be used for paying transaction fees.
    This provides a way to prevent
  the entire value of a transaction's UTxO entries being used as fees if a script fails to validate.

  \item $\TxIn$ is a transaction input. It includes a reference to the UTxO entry that it is spending
  and an $\IsFee$ tag.
% , which indicates if this input should
%   be used to pay script execution fees.

  \item $\TxOutND$ is a transaction output with no datum hash
  (this type is for VKey\todo{What is VK?} and multi-signature script outputs).

  \item $\TxOutP$ is a transaction output that comes from a Plutus script (these include a datum hash).\todo{Confirm this.}

  \item $\HasDV$
  is a tag that is attached to a transaction output if it is \emph{locked} by a Plutus
  script. The output contains an address, a value, and a datum hash.
  This tag indicates whether the transaction carrying the output
  contains, in its set of datum objects, the full datum that corresponds
  to the datum hash.

  Note that it is up to the user to decide whether the transaction should have the full datum. The purpose of
  including it is just so that it can be communicated to the user who will be spending
  the output in the future, and who will require the full datum in order to validate
  the Plutus script that is locking the output. However, this tag must be applied
  correctly, otherwise the transaction will not validate.
  \begin{note}
    The purpose of this tag is to ensure that it is evident if such a
    datum has been removed. We may do something else and remove this tag.
  \end{note}

  \item $\TxOut$ is the type of transaction outputs, either
  $\TxOutND$ or a pair of $\TxOutP$ and $\HasDV$.

  \item $\Tag$ let us differentiate what a script
  can validate, i.e. \\

  \begin{tabular}{l@{~to validate~}l}
  $\mathsf{inputTag}$ & spending a script UTxO entry, \\
  $\mathsf{forgeTag}$ & forging tokens, \\
  $\mathsf{certTag}$  & certificates with script credentials, and  \\
  $\mathsf{wdrlTag}$ & reward withdrawals from script addresses.
  \end{tabular}

  \item $\RdmrPtr$ is a pair of a tag and an index. This type is
  used to index the Plutus redeemers that are included in a transaction. See
  below.

\end{itemize}


\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\quad\quad\quad\quad}r}
      \var{v} &\Value & \text{Multi-asset value}\\
      \var{hdv} &\RdmrsHash & \text{Indexed redeemer hash}\\
      \var{msig} & \ScriptMSig & \text{Multi-signature scripts} \\
      \var{plc} & \ScriptPlutus & \text{Plutus scripts from the initial Plutus version} \\
      \var{dat} & \Data & \text{The Plutus $\Data$ type} \\
    \end{array}
  \end{equation*}
  %
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{scr} & \Script & \ScriptPlutus \uniondistinct \ScriptMSig \\
      \var{isv} & \IsValidating & \Bool \\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{isf}
      & \IsFee
      & \Bool
%      & \text {tag for inputs used to pay script fees}
      \\
      \var{txin}
      & \TxIn
      & \TxId \times \Ix \times \IsFee
%      & \text{transaction input}
      \\
      (\var{addr}, v)
      & \type{TxOutND}
      & \Addr \times \Value
%      & \text{vk address output}
      \\
      (\var{addr}, v, \var{hashscr_d})
      & \type{TxOutP}
      & \type{TxOutND} \times \DataHash
%      & \text{script address output}
      \\
      \var{hdv}
      & \HasDV
      & \Bool
      %      & \text {tag for outputs that come with datums}
      \\
      \var{txotx}
      & \TxOut
      & \TxOutND \uniondistinct (\TxOutP \times \HasDV)
%      & \text{transaction outputs in a transaction}
      \\
      \var{tag}
      & \Tag
      & \{\mathsf{inputTag},~\mathsf{forgeTag},~\mathsf{certTag},~\mathsf{wdrlTag}\}
      \\
      \var{dvin}
      & \RdmrPtr
      & \Tag \times \Ix
%      & \text{reverse pointer to thing dv is for}
    \end{array}
  \end{equation*}
  \caption{Definitions for Transactions}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}


\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{wits} ~\in~ \TxWitness ~=~
       & (\VKey \mapsto \Sig) & \fun{txwitsVKey} & \text{VKey signatures}\\
       & \times ~\powerset{\Script}  & \fun{txscripts} & \text{All scripts}\\
       & \times~ \powerset{\Data} & \fun{txdats} & \text{All datum objects}\\
       & \times ~(\RdmrPtr \mapsto \Data)& \fun{txrdmrs}& \text{Indexed redeemers}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txbody} ~\in~ \TxBody ~=~
      & \powerset{\TxIn} & \fun{txinputs}& \text{Inputs}\\
      &\times ~(\Ix \mapsto \TxOut) & \fun{txouts}& \text{Outputs}\\
      & \times~ \seqof{\DCert} & \fun{txcerts}& \text{Certificates}\\
       & \times ~\Value  & \fun{forge} &\text{A forged value}\\
       & \times ~\ExUnits  & \fun{txexunits}& \text{Script exec. budget}\\
       & \times ~\Coin & \fun{txfee} &\text{Non-script fee}\\
       & \times ~(\Slot\times\Slot) & \fun{txfst},~\fun{txttl} & \text{Validity interval}\\
       & \times~ \Wdrl  & \fun{txwdrls} &\text{Reward withdrawals}\\
       & \times ~\Update  & \fun{txUpdates} & \text{Update proposals}\\
       & \times ~\PPHash^?  & \fun{ppHash} & \text{Hash of PPs}\\
       & \times ~\RdmrsHash^? & \fun{rdmrsHash} & \text{Hash of indexed redeemers}\\
       & \times ~\MetaDataHash^? & \fun{txMDhash} & \text{Metadata hash}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~~}l@{~~}l@{\qquad}l}
      \var{txg} ~\in~ \GoguenTx ~=~
      & \TxBody & \fun{txbody} & \text{Body}\\
      & \times ~\TxWitness & \fun{txwits} & \text{Witnesses}\\
      & \times ~\IsValidating & \fun{txvaltag}&\text{Validation tag}\\
      & \times ~\MetaData^? & \fun{txMD}&\text{Metadata}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l@{\qquad\qquad}l}
\qquad\qquad      \var{tx} & \Tx & \ShelleyTx \uniondistinct \GoguenTx &
      \text{All valid transactions}\\
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad}l}
      \fun{getValue} & \TxOut \uniondistinct \UTxOOut \to \Value & \text{Output value} \\
      \fun{getAddr} & \TxOut \uniondistinct \UTxOOut \to \Addr & \text{Output address} \\
      \fun{getDataHash} & \TxOut \uniondistinct \UTxOOut \to \DataHash & \text{Data hash}
    \end{array}
  \end{equation*}
  \caption{Definitions for transactions, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}


\textbf{Data Representation.}
The type $\Data$ is a Plutus type that represents all valid ground types in Plutus\todo{Confirm}.
\begin{note}
There is a similar type in the
ledger. We do not assume these are the same $\Data$, but we do assume there
is structural equality between them. TODO: {Fix this.  Is one a subset of the other?  Are they actually related in any way; if so, how?}
  Is this supposed to be this similar type? From what I've seen, those
  two types are not actually equal, so this needs an update.
\end{note}

\subsection{Witnessing}
Figure \ref{fig:defs:utxo-shelley-2} defines the witness type, $\TxWitness$.  This contains everything
in a transaction that is needed for witnessing, namely:

\begin{itemize}
  \item VKey\todo{What is VK} signatures;
  \item a set of scripts that is needed to \emph{validate} the transaction, including for forging tokens, spending outputs, verifying certificates, and
  verifying withdrawals;
  \item a set of terms of type $\Data$, which contains all required datum objects; and
  \item a map of $\Data$ values indexed by $\RdmrPtr$, which includes all the
  required redeemers.
\end{itemize}

Note that there is a difference between the way scripts and datum objects are included in
a transaction (as a set) versus how redeemers are included
(as an indexed structure). % This is driven by their different relationships to the item:

\begin{description}
\item
  [Hash reference (script/datum object):]
  The item that needs to be validated (output, forge, etc.) explicitly references the hash of
  the witness data.
%  This is the case for all scripts and datum:
  Script addresses, currency IDs, and certificate credentials must contain
  the hash of the validator script that will be run, and script-locked UTxO entries
  must contain the hash of a datum. % which has to be included. Included in what??

  \item[No hash reference (redeemers):] The item that needs to be validated has no explicit % link to, hash of, or
  hash reference to the witness data.
  % This is the case for redeemers.
  In this case, we use a reverse pointer approach and
  index the redeemer by a pointer to the item for which it will be used.
  For details on how a script finds its redeemer, see Section~\ref{sec:scripts-inputs}.
\end{description}

\subsection{Goguen transactions}
We have also made the following changes to
the body of the transaction:

\begin{itemize}
  \item We include a term of type $\ExUnits$. This is a limit on the total quantity of execution units
  that may be used by all non-native scripts in the transaction.
  The limit can be computed by, for example, executing the scripts off-chain prior to transaction submission.
  \item We include a hash of the the indexed redeemer structure
    with accessor $\fun{rdmrsHash}$. The reason for including this hash is explained below.
  \item We include a hash of the subset of current protocol parameters that is relevant for script execution.
\end{itemize}

A complete Goguen transaction comprises:

\begin{enumerate}
  \item the transaction body.
  \item all the information that is needed to witness transactions.
  \item the $\IsValidating$ tag, which indicates whether the transaction needs to be validated.
%   set by the user submitting the block containing this transaction.
  The correctness of the tag is verified as part of the ledger rules, and the block is
  deemed to be invalid if it is applied incorrectly.
  If it is set to \emph{false}, then the block can be re-applied without script re-validation.
  This tag does not need to be signed, since incorrect use will result
  in the whole block being invalid.\todo{Revised the description. Please confirm this is what was intended.}
 % , which benefits no one.
  \begin{note}
    Not sure if I understand that argument, but it cannot be signed,
    because it's not applied by the transaction creator.
    The ``which benefits noone'' probably doesn't matter...
  \end{note}
  \item any transaction metadata.
\end{enumerate}


\subsection{Processing Shelley Transactions in the Goguen Era}
%% No semantic content?  KH
%% Everything we have discussed so far in this document is about the structure and data
%% in Goguen era protocol parameters and transactions. Some type names are reinterpreted
%% for different purposes in the Goguen era than they were used for in Shelley, and
%% we specify the differences in these cases.

To simplify the transition from the Shelley to the Goguen era, the ledger rules support both Shelley and Goguen transaction formats simultaneously:
$\Tx ~~=~~ \ShelleyTx \uniondistinct \GoguenTx$, where Shelley transactions have the type $\ShelleyTx$, and  Goguen transactions have type $\GoguenTx$.
%
% A true Goguen transaction is really of either type,
% i.e.

Shelley transactions contain fewer data items than Goguen transactions, so we can interpret
a Shelley transaction as a Goguen one with some missing fields, and process it using the normal Goguen ledger
rules.  Shelley witnesses cannot, however, be transformed into Goguen witnesses.
Section~\ref{XX} specifies how to verify signatures before a
Shelley transaction is transformed to a Goguen one.

\subsection{Additional Role of Signatures on TxBody}
The transaction body must contain all data
(or at least a hash of the data) that can influence
on-chain transfer of value % resulting from this transaction being processed
(see Figure \ref{fig:defs:utxo-shelley-2}).
This means that, for example,
every input that is spent and every output that is created are present in the body of the transaction.
Since a valid transaction can now be ``fully validated'' or ``only paying
fees'' (explained in detail in Section~\ref{sec:utxo}), anything that
can influence these outcomes must also be included in the body.

There is no need to ever sign anything that is related to validator scripts or datum objects,
since a hash of every validator script that is needed % will be run during the validation of the transaction is always part of the body,
is included in the body of the transaction, and the hash of every datum that is needed
is recorded in the UTxO.
%
The body of the transaction, however, is signed by every key
whose outputs are being spent.
This provides % , which additionally offers
protection against tampering with Plutus interpreter arguments, which may cause
script validation failure (so placing the transaction in the category of ``only paying fees'').
For this reason, the hash of the indexed redeemer structure and the protocol parameters that are used by
script interpreters are included in the body of the transaction. In the future, other parts of the ledger
state may also need to be included in this hash, if they are passed as
arguments to new script interpreter. Note also that data from the UTxO
is passed to the interpreter, but does not require this type of hash comparison.
This is because, if the
entries % the transaction t being processed is trying to spend
have already been spent, the phase 1 validation check
will fail.

The owner of any tokens that are spent as part of a given transaction
must sign the transaction body. The body also includes the for-fee tags that are attached to inputs.
%% No obvious what the semantic content is here?
% Because of this, the owners of tokens that are spent by the transaction have
% signed their selection of inputs that will be put in the fee pot in case of script validation failure.
%
As before, a change in the body of the transaction
will make the transaction completely invalid, rather than cause the fee-paying script validation
failure or change the amount of fees it pays.

\subsection{Partially processing transactions}

Note that in Goguen, it is possible for a transaction
to either be fully processed in full, or else to do nothing apart from paying fees for script
validation (see Section~\ref{sec:utxo} for details).
We have considered two ways to prevent all the Ada in the transaction outputs from going into
the fee pot if script validation fails:
%
\begin{enumerate}
  \item programmatically select the inputs which will be used to pay fees;
  \item allow the user to decide which inputs will be used to pay fees.
\end{enumerate}
%
% Since different users may have different considerations,
To maximise flexibility, we have chosen to use the second option. %  decided to give control over input selection % for this purpose to the user.
This also allows users to write their own programmatic solutions to choosing for-fees inputs.

Only VKeys that spend inputs\todo{Inputs that spend VKeys? Or VKeys that spend inputs?} or native scripts that spend inputs can
be used to pay fees. In Shelley, spending VKey or script outputs is
validated as part of a single rule application, so either all
the required signatures will be valid, or a transaction is completely
invalid. We have retained this model, but have chosen a different approach to
charging users for running Plutus scripts, see
Section~\ref{sec:two-phase}.

Plutus scripts will generally be more expensive to run than simply checking signatures, as in Shelley.
We therefore want to charge users for running Plutus scripts, even if the scripts fail to validate. The outputs
that need to be spent to pay for running the scripts (the ones marked as for-fees) must therefore be
validated fully before validating the Plutus scripts themselves.\todo{These are different forms of validation, right?  This should be made clear.}

\section{The Extended UTxO Model}
\label{sec:utxo}


\begin{figure*}[htb]
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{uin}
      & \UTxOIn
      & \TxId \times \Ix
%      & \text{transaction output preference}
      \\
      \var{uout}
      & \UTxOOut
      & (\TxOutND \uniondistinct \TxOutP) \times \Slot
%      & \text{transaction outputs}
      \\
      \var{utxo}
      & \UTxO
      & \UTxOIn \mapsto \UTxOOut
%      & \text{unspent tx outputs}
      \\
      \var{cur}
      & \CurItem
      & \PolicyID \uniondistinct \UTxOIn \uniondistinct \AddrRWD \uniondistinct \DCert
%      & \text{item the script is validated for}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}


We make a number of changes to the Shelley UTxO model~\ref{XX} to support the Goguen Extended UTxO model
(see Figure~\ref{fig:defs:utxo-shelley-1}).

\begin{itemize}
\item
  $\UTxO$ entries are stored in the finite map $\UTxOIn\mapsto \UTxOOut$.

\item
  $\UTxOIn$ is the same type as $\TxIn$ in Shelley, but we have changed
  the name because the types of transaction inputs and UTxO keys
  differ in Goguen.

\item
  $\UTxOOut$ is the type of UTxO entries.
  Note that, like in the case of the type of transaction inputs,
  this type differs from the type of the output of a transaction.
  Goguen UTxO entries include a slot number for each output
  that indicates when the output was created.
  This will be used for future functionality.

\item
  $\CurItem$ is the type of the items that scripts can validate.\todo{Why is this called CurItem?}

\end{itemize}

\subsection{UTxO Transitions}
\label{sec:utxo-trans}

We have added several functions that deal with transaction and UTxO inputs and
outputs as shown in Figure \ref{fig:functions:insouts}. These are used in the definition of the UTxO transition system.

\begin{itemize}
  \item The function $\fun{txinputs_{vf}}$ returns only those transaction inputs
    that were selected to pay transaction fees (we call these ``fee-marked'' inputs).
    These inputs may only contain Ada.
    \begin{note}
      Make it more obvious that we check that the fee inputs only contain Ada, maybe mention it elsewhere. Also, what does vf stand for?
    \end{note}
  \item The predicate $\fun{feesOK}$ checks whether the transaction is
  paying the necessary fees, and that it does it correctly. That is, it checks that:
  \begin{enumerate}[label=({\roman*})]
    \item the fee-marked inputs are not locked by non-native scripts;
    \item all the fee-marked inputs contain strictly Ada and no other kinds of token;
    \item the fee-marked inputs are sufficient to cover the fee amount that is stated
    in the transaction; and
    \item the fee amount that the transaction states it is paying suffices to cover
    the minimum fee that the transaction is obligated to pay.
  \end{enumerate}
  \item The function $\fun{getOut}$ selects the data from a transaction output that
  will be stored in the UTxO, i.e. a $\UTxOOut$ without the slot number.
  \item The function $\fun{txins}$ returns the UTxO keys of transaction inputs.
\end{itemize}

Note that when creating a transaction, the wallet is responsible for
determining the fees. Thus, it also has to execute the non-native scripts
and include the fees for their execution.
\begin{figure}[htb]
  \begin{align*}
    & \fun{txinputs_{vf}} \in \TxBody \to \powerset{\TxId \times \Ix} \\
    & \fun{txinputs_{vf}} ~txb~= \\
    &~~\{ (txid,ix)~\vert~(txid,ix,\var{isfee}) \in
    \fun{txinputs} ~txb,~
     \var{isfee} = \True\}
    \nextdef
    & \fun{feesOK} \in \N \to \PParams \to \GoguenTx \to \UTxO \to \Bool  \\
    & \fun{feesOK} ~n~\var{pp}~tx~utxo~= \\
    &~~\fun{range}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo}) \subseteq \TxOutND ~ \\
    &~~\wedge~ \fun{ubalance}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo}) \in \Coin \\
    &~~      \wedge~ \fun{ubalance}~(\fun{txinputs_{vf}}~{txb} \restrictdom \var{utxo}) \geq \txfee{txb} ~ \\
    &~~      \wedge~ \minfee~n~{pp}~{tx} \leq \txfee{txb} \\
    &~~      \where \\
    & ~~~~~~~ \var{txb}~=~\txbody{tx}
    \nextdef
    & \fun{getOut} \in \TxOut \to \TxOutND \uniondistinct \TxOutP \\
    & \fun{getOut} ~{txout}~= \begin{cases}
         \var{txout}  & \text{if~} \var{txout} \in \TxOutND \\
              (\fun{getAddr}~\var{txout}, \fun{getValue}~\var{txout},
              \fun{getDataHash}~\var{txout}) & \text{otherwise}
            \end{cases}
    \nextdef
    & \fun{txins} \in \TxBody \to \powerset{\TxId \times \Ix} \\
    & \fun{txins} ~\var{txb} = \{(txid,ix) \mid ((txid,ix),\wcard)\in\fun{txinputs} ~txb\}
  \end{align*}
  \caption{Functions on Tx Inputs and Outputs.}
  \label{fig:functions:insouts}
\end{figure}


Figure~\ref{fig:functions:utxo} defines the functions that are needed for the UTxO transition system.
The changes that are needed for Plutus integration are:

\begin{itemize}

  \item The $\fun{getCoin}$ function sums all the Ada in a given output and returns it as a
  $\Coin$ value.

  \item The function $\fun{outs}$ discards the $\HasDV$ tag from a
  transaction output and adds the slot number of the block in which the transaction is
  included.

  \item $\fun{txscrfee}$ calculates the fee that a transaction must pay for script
  execution based on the amount of $\ExUnits$ it has budgeted, and the prices in the current protocol parameters
  for each component of $\ExUnits$.

  \item The minimum fee calculation, $\fun{minfee}$, includes the script
  fees that the transaction is obligated to pay in order to run its scripts.

  \item The $\fun{produced}$ calculation requires the current slot number as an argument -- this is
  needed to construct the correct UTxO outputs.
\end{itemize}

Since the $\Tx$ type combines both $\ShelleyTx$ and $\GoguenTx$, and
there was already a way of computing an ID from a Shelley transaction, there
is potential for confusion how the ID of a transaction is
computed. Here, $\TxId$ is always computed from values of type $\Tx$,
\emph{and never from the underlying $\ShelleyTx$ or $\GoguenTx$}.  That is, there is a \emph{canonical} ID for each Goguen transaction,
and this is not necessarily the same as the corresponding ID in the underlying Shelley or Goguen transaction type.

\begin{figure}[htb]
  \emph{Helper Functions}
  \begin{align*}
    & \fun{getCoin} \in \UTxOOut \to \Coin \\
    & \fun{getCoin}~{\var{out}} ~=~\sum_{\mathsf{adaID} \mapsto tkns \in \fun{getValue}~out}
       (\sum_{q \in \range~{tkns}} \fun{co}~q)
  \end{align*}
  %
  \emph{Main Calculations}
  \begin{align*}
    & \fun{outs} \in \Slot \to \TxBody \to \UTxO \\
    & \fun{outs} ~ \var{slot}~\var{txb} =
        \left\{
          (\fun{txid} ~ \var{txb}, \var{ix}) \mapsto (\fun{getOut}~\var{txout},\var{slot}) ~
          \middle|~
          \var{ix} \mapsto \var{txout} \in \txouts{txb}
        \right\}
    \nextdef
    & \fun{txscrfee} \in \N \to \Prices \to \ExUnits \to \Coin \\
    & \fun{txscrfee}~n~ (\var{pr_{init}, pr_{mem}, pr_{steps}})~ (\var{mem, steps})
    = \var{pr_{init}}*n + \var{pr_{mem}}*\var{mem} + \var{pr_{steps}}*\var{steps}
    \nextdef
    &\fun{minfee} \in \N \to \PParams \to \GoguenTx \to \Coin \\
    &\fun{minfee}  ~n~\var{pp}~\var{tx} = \\
    &~~(\fun{a}~\var{pp}) \cdot \fun{txSize}~\var{tx} + (\fun{b}~\var{pp}) +
    \fun{txscrfee}~n~(\fun{prices}~{pp})~(\fun{txexunits}~(\fun{txbody}~{tx}))
    \nextdef
    & \fun{produced} \in \Slot \to \PParams \to \StakePools \to \TxBody \to \Value \\
    & \fun{produced}~\var{slot}~\var{pp}~\var{stpools}~\var{txb} = \\
    &~~\ubalance{(\outs{slot}~{txb})} + \fun{coinToValue}(\txfee{txb} \\
    &~~+ \deposits{pp}{stpools}~{(\txcerts{txb})})
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\subsection{Combining Scripts with Their Inputs}
\label{sec:scripts-inputs}

In Figure \ref{fig:functions:script1} we give the helper functions needed to
retrieve all the data relevant to validation of Plutus scripts.
This includes,

\begin{itemize}
  \item $\fun{indexof}$ finds the index of a given certificate, value, input, or
  withdrawal in the list, finite map, or set of things of the corresponding type.
  This function assumes there is some ordering on each of these structures.
  This function is abstract because it assumes there is some ordering rather
  than giving it explicitly.
  \begin{note}
    $\fun{indexof}$ might need an actual implementation. Also, some
    restructuring in related functions might make it easier.
  \end{note}
  \item $\fun{indexedScripts}$ and $\fun{indexedDats}$ create finite maps wherein, respectively, all the scripts
  and datums that a transaction carries as sets, are indexed by their hashes.
  \item $\fun{findRdmr}$ finds the redeemer carried by a Goguen transaction
   which corresponds to a given current item in the indexed redeemer structure, if it exists.
\end{itemize}


\begin{figure}[htb]
  %
  \emph{Abstract functions}
  \begin{align*}
    &\fun{indexof} \in \DCert \to \seqof{\DCert} \to \Ix\\
    &\fun{indexof} \in \AddrRWD \to \Wdrl \to \Ix\\
    &\fun{indexof} \in \UTxOIn \to \powerset{\TxIn} \to \Ix\\
    &\fun{indexof} \in \PolicyID \to \Value \to \Ix\\
    & \text{get the index of an item in the an ordered representation}
  \end{align*}
  %
  \emph{Helper functions}
  \begin{align*}
    &\fun{indexedScripts} \in \GoguenTx \to (\ScriptHash \mapsto \Script) \\
    &\fun{indexedScripts}~{tx} ~=~ \{ h \mapsto s ~\vert~ \fun{hashScript}~{s}~=~h,
     s\in~\fun{txscripts}~(\fun{txwits}~{tx})\}
    \nextdef
    &\fun{indexedDats} \in \GoguenTx \to (\DataHash \mapsto \Data)\\
    &\fun{indexedDats}~{tx} ~=~ \{ h \mapsto d ~\vert~ \fun{hashData}~{d}~=~h,
     d\in~\fun{txdats}~(\fun{txwits}~{tx})\}
    \nextdef
    &\fun{toRdmrPtr} \in \GoguenTx \to \CurItem \to \RdmrPtr \\
    &\fun{toRdmrPtr}~{tx}~{it} ~=~
      \begin{cases}
        (\mathsf{certTag},\fun{indexof}~\var{it}~(\fun{txcerts}~{txb}))   & \var{it}~\in~\DCert \\
        (\mathsf{wdrlTag},\fun{indexof}~\var{it}~(\fun{txwdrls}~{txb}))   & \var{it}~\in~\AddrRWD \\
        (\mathsf{forgeTag},\fun{indexof}~\var{it}~(\fun{forge}~{txb}))    & \var{it}~\in~\PolicyID \\
        (\mathsf{inputTag},\fun{indexof}~\var{it}~(\fun{txinputs}~{txb})) & \var{it}~\in~\UTxOIn
      \end{cases} \\
    & ~~\where \\
    & ~~~~~~~ \var{txb}~=~\txbody{tx}
    \nextdef
    &\fun{findRdmr} \in \GoguenTx \to (\CurItem \mapsto \Data)\\
    & \fun{findRdmr}~{tx} ~=~ \{ \var{it} \mapsto \var{d} ~|~
      \var{it} \in \CurItem,~ \fun{toRdmrPtr}~{tx}~{it} \mapsto \var{d} \in \fun{txrdmrs}~(\fun{txwits}~{tx}) \}
  \end{align*}
  \caption{Combining Script Validators and their Inputs}
  \label{fig:functions:script1}
\end{figure}

\textbf{Plutus Script Validation}
In Figure \ref{fig:defs:functions-valid}, abstract functions for script validation
are presented.

\begin{itemize}
  \item $\fun{valContext}$ constructs the validation context value passed
    to the script interpreter, which includes all the necessary transaction and chain state data.
    It has a $\UTxO$ as its argument to recover the full information of the inputs of the transaction,
    but only the inputs of the transaction are provided to scripts.
  \item $\fun{hashScript},~ \fun{hashData}$ are abstract hashing functions.
  \item $\fun{runMSigScript}$ (replacing $\fun{evaluateScript}$ in Shelley the ledger spec) performs
  validation for multi-sig scripts.
  This validation works exactly as before.
  \item $\fun{runPLCScript}$ performs validation for Plutus scripts. It takes the following
  arguments:
  \begin{itemize}
  \item A cost model, used for calculating the $\ExUnits$ used by the script execution.
  \item A list of terms of type $\Data$ the script is given access to.
  \item The execution units budget.
  \end{itemize}
  The script validation function outputs the pair of the validation result
  and the remaining execution units (after the ones used by script execution
  have been subtracted). Note that script execution stops if the full execution
  units budget has been spent before the validation is complete.
\end{itemize}

\begin{note}
  \textbf{Know your contract arguments}
A Plutus validator script may receive either a list of three terms of type $\Data$,
such as for output locking scripts, or two terms (redeemer and context, with
no datum), such as in the rest of the Plutus scripts use cases.
Contract authors must keep this in mind when writing contracts, as there is
only one function (per Plutus version) to interface with the Plutus interpreter,
that runs every kind of Plutus script - with no knowledge of what $\Data$ arguments
are passed to it via this list.
\end{note}

\begin{figure*}[htb]
  \emph{Abstract Script Validation Functions}
  %
  \begin{align*}
     &\fun{hashScript} \in  ~\Script\to \ScriptHash \\
     &\text{compute script hash} \\~\\
     &\fun{hashData} \in  ~\Data \to \DataHash \\
     &\text{compute hash of data} \\~\\
     &\fun{valContext} \in  \UTxO \to \GoguenTx \to \CurItem \to \Data \\
     &\text{build Validation Data} \\~\\
     &\fun{runMSigScript} \in\ScriptMSig\to \GoguenTx \to \IsValidating  \\
     &\text{validation of a multi-sig script} \\~\\
     &\fun{runPLCScript} \in \CostMod \to\ScriptPlutus \to
    \seqof{\Data} \to \ExUnits \to (\IsValidating \times \ExUnits) \\
     &\text{resource-restricted validation of a Plutus script}
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{cm},\var{exunits}}~\var{d}
    &=& \fun{runPLCScript} ~{cm}~\var{script_v}~\var{d}~\var{exunits}
  \end{align*}
  \caption{Script Validation, cont.}
  \label{fig:defs:functions-valid}
\end{figure*}

Note that there are no "checks" done inside the functions matching
scripts with their inputs. If there are
missing validators or inputs, or incorrect hashes, wrong type of script,
this is caught during the application of the UTXOW
rule (before these functions are ever applied).

There are several pieces of data from different sources involved in building
the inputs for script validation:

\begin{itemize}
\item The hash of the validator script,

\item the hash of the required datum, if any,

\item the corresponding
full validator and datum object, which are looked up by their hash value in the finite map
constructed by $\fun{indexedScripts}$ and $\fun{indexedDats}$ respectively,

\item the redeemer, which is contained in in the indexed redeemer structure carried by the transaction
and which are looked up by current item using the $\fun{findRdmr}$ function, and

\item the validation data, built using the UTxO, the transaction itself,
and the current item being validated.
\end{itemize}


\begin{figure}[htb]
  \begin{align*}
    & \fun{getCurVals} \in \GoguenTx \to \UTxO \to \powerset{(\CurItem \times \ScriptHash \times \seqof{\Data})} \\
    & \fun{getCurVals}~{tx}~{utxo}~=~ \\
    & ~~\{ (\var{cert}, \fun{regCred}~\var{cert}, \epsilon) ~|~
      \var{cert} \in \DCertDeRegKey\cap\fun{txcerts}~(\txbody{tx}) \}~\cup \\
    & ~~\{ (\var{a}, \var{a}, \epsilon) ~|~ a \mapsto \_ \in\fun{txwdrls}~(\txbody{tx}) \}~\cup \\
    & ~~\{ (\var{pid}, \var{pid}, \epsilon) ~|~ \var{pid}\mapsto ~ \_ \in \fun{forge}~(\txbody{tx}) \}~\cup \\
    & ~~\{ ((\var{txid}, \var{ix}), \fun{validatorHash}~{a}, [\var{d}]) ~|~ (txid,ix, \_) \in \fun{txinputs}~(\txbody{tx}), \\
    & ~~~~~~(\var{txid}, \var{ix}) \mapsto ((a,\_),h_d, \_) \in \var{utxo}, \\
    & ~~~~~~\var{h_d}\mapsto \var{d} \in \fun{indexedDats}~{tx} \}
    \nextdef
    & \fun{mkPLCLst} \in \PParams \to \GoguenTx \to \UTxO \to \seqof{(\ScriptPlutus \times \seqof{\Data} \times \CostMod)} \\
    & \fun{mkPLCLst} ~\var{pp}~\var{tx}~ \var{utxo} ~=~
      \fun{toList} \{ (\var{script}, (r; \fun{valContext}~\var{utxo}~\var{tx}~\var{cur}; d), \var{cm}) ~|~ \\
    & ~~(\var{cur}, \var{scriptHash}, \var{d}) \in \fun{getCurVals}~{tx}~{utxo}, \\
    & ~~\var{cur} \mapsto \var{r} \in \fun{findRdmr}~{tx}, \\
    & ~~\var{scriptHash}\mapsto \var{script}\in \fun{indexedScripts}~{tx}, \\
    & ~~\fun{language}~{script} \mapsto \var{cm} \in \fun{costmdls}~{pp} \}
  \end{align*}
  \caption{Scripts and their Arguments}
  \label{fig:functions:script2}
\end{figure}

\subsection{Two Phase Validation}
\label{sec:two-phase}

\begin{note}
  Make it more obvious somewhere where native vs non-native scripts are processed.
\end{note}

To ensure users pay for the computational resources script validation uses, even
if transactions are invalid, they are validated in two phases. This applies only to non-native
scripts, as native script execution costs are expected to be much smaller
and can be assesed and limited by the ledger rules directly. The first phase consists of
every aspect of transaction validation except executing non-native scripts, and
the second phase is executing those scripts.

We use four transition systems
for this validation approach, each with different responsibilities. We
give the details of each below, but to summarize, when a transction is processed,
it is done by rules in the transition systems in the following order
(each transition calls on the one below it in its rules):

\begin{itemize}
  \item[(UTXOW)] : Verifies all the necessary witnessing information is present, including
  VK witnesses, scripts, and all the script input data. It also performs
  key witness checks and runs multisig scripts. It then applies state changes
  computed by the UTXO transition.
  \item[(UTXO)] : Verifies a transaction satisfies all the accounting requirements
  (including the general accounting property, correct fee payment, etc.),
  applies state changes computed by the UTXOS transition.
  \item[(UTXOS)] : Performs the appropriate UTxO state changes, deciding based on the
  value of the $\IsValidating$ tag, which it checks using the SVAL transition.
  \item[(SVAL)] : Runs the scripts, verifying that the $\IsValidating$ tag
  is applied correctly.
\end{itemize}

There is no way to check that this budget is enough,
except running the scripts. To avoid over-spending, we run them sequentially,
stopping whenever one does not validate, and charging the transaction the
fees. From the point of view of the ledger, there is no difference
between a script runnig out of $\ExUnits$ during validation, or not validating.
If a transaction contains an invalid script, the only change to the ledger
as a result of applying this transaction is the fees.

Two phase validation requires a new transition system
(see Figure \ref{fig:ts-types:utxos}) to sequentially run
scripts and keep track of the execution units being spent as part of its state
($\var{remExU}$). The signal here is a sequence of pairs of a validator
script and the corresponding input data.

Note that there is one state variable in the SVAL transition system. The reason
for this is that in the second, script-running validation phase, we separate
the UTxO state update from sequentially running scripts. This transition
system is strictly for running the scripts, and a transition of this type
will be used by another rule to perform the correct UTxO update.

Running scripts sequentially
to verify that they all validate in the allotted $\ExUnits$ budget only requires
the amount of remaining $\ExUnits$ to be included in the state, and nothing else.
In the environment, we need the protocol parameters and the
transaction being validated. All other data needed
to run the scripts comes from the signal.

\begin{figure}[htb]
  \emph{Validation environment}
  \begin{equation*}
    \ValEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{tx} & \GoguenTx & \text{transaction being processed} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Validation state}
  \begin{equation*}
    \ValState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{remExU} & \ExUnits & \text{exunits remaining to spend on validation} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Script transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{sval}{\_} \var{\_}
    \subseteq \powerset (\ValEnv \times \ValState \times \seqof{(\ScriptPlutus\times\seqof{\Data}\times\CostMod)} \times \ValState)
  \end{equation*}
  %
  \caption{UTxO script validation types}
  \label{fig:ts-types:utxos}
\end{figure}

The rules for the second-phase script validation SVAL are given in
Figure~\ref{fig:rules:utxo-scrval}. Again, there is no UTxO state update
done in this rule. Its function is essentially verifying that the
validation tag ($\fun{txvaltag}$) is applied correctly by the creater of
the block by running all the scripts.

Note that following the Shelley ledger spec approach, every function
we define and use in the preconditions or calculations in the rules is
necessarily total.
This way, all errors (validation failures) we encounter always come from
rule applications, i.e. a precondition of a rule is not met.
We mention this here because the SVAL rule looks as if it could be
simply a function. However, we want the incorrect application of the
validation tag to be an error, so it must be an error that comes form
an unmet precondition of a rule.

There are three transition rules.
The first rule, $\mathsf{Scripts\mbox{-}Val}$, applies when

\begin{itemize}
\item there
are no scripts left to validate in the signal list (i.e. this is the base case of
induction when all the scripts have validated), there could be $\ExUnits$ left over
\item the validation tag is applied correctly (it is $\True$)
\end{itemize}

The $\mathsf{Scripts\mbox{-}Stop}$ rule applies when

\begin{itemize}
  \item The currenct script-input pair being validated does not validate
  (because the transaction ran out of $\ExUnits$ or any other reasons)
  \item The validation tag is correct ($\False$ in this case)
\end{itemize}

These first two rules require no state change.
The $\mathsf{Scripts\mbox{-}Ind}$ rule applies when

\begin{itemize}
  \item the current script being validated has validated
  \item there is a non-negative fee which remains to pay for validating
  the rest of the scripts in the list
  \item transition rules apply for rest of the list (without the currenct script)
\end{itemize}

The only state change in this rule is of the variable $\var{remExU}$.
It is decreased by subtracting the cost of the execution of the
current script from its current value.
This is the variable we use to keep track of the remaining funds for
script execution. If the transaction is overpaying ($\fun{txscrfee}~{tx}$
is too big), the whole fee is still taken.

It is always in the interest of the slot leader to have the new block validate,
containing only valid transactions. This motivates the
slot leader to:

\begin{itemize}
  \item correctly apply of the $\IsValidating$ tag,
  \item include transactions that validate in every way
  \textit{except possibly 2nd step script validation failure}
  \item exclude any transactions that are invalid
in some way \textit{other than 2nd step script validation failure}
\end{itemize}

We want to
throw away all the blocks which have transactions with these tags
applied incorrectly.
One of the reasons for having the correct validation tag added by the slot leader
to a transaction is that re-applying blocks would not require repeat
execution of scripts in the transactions inside a block. In fact, when replaying
blocks, all the witnessing info can be thrown away.
We also rely on correct use of tags in other rules (at this time, only in
the rules in Figure \ref{fig:rules:ledger}).


\textbf{Non-integral calculations inside the Plutus interpreter.} If there
will be some in the future (from the Actus contracts implemented using
the Marlowe interpreter, for e.g.), they should
be done the same way they are done in the Shelley ledger. This is a matter of
deterministic script validation outcomes. Inconsistent rounding could
result in different validation outcomes running the same script on the same
arguments. For how this is done in the ledger calculations, see
~\cite{non_int}.


\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Val]
    {
    \fun{txvaltag}~\var{tx} = \True  &
    \var{remExU}~\geq~0
    }
    {
    \begin{array}{l}
      \var{pp}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      \right)
      \trans{sval}{\epsilon}
      \left(
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Stop]
    { \\~\\
    (\var{isVal},\var{remExU'})~:=~ \llbracket sc \rrbracket_
    {cm,\var{remExU}} dt \\
    (sc, dt, cm) := s
    \\
    ~
    \\
    \fun{txvaltag}~\var{tx} = \False &
    (\var{remExU'}~<~0 ~ \lor ~ \var{isVal} = \False)
    }
    {
    \begin{array}{l}
      \var{pp}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      \right)
      \trans{sval}{\Gamma;s}
      \left(
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      \right)
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-Ind]
    {
    {
    \begin{array}{l}
      \var{pp}\\
      \var{tx}\\
    \end{array}
    }
      \vdash
      \left(
      {
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      }
      \right)
      \trans{sval}{\Gamma}
      \left(
      {
      \begin{array}{r}
        \var{remExU'}\\
      \end{array}
      }
      \right) \\
    (\var{isVal},\var{remExU''})~:=~ \llbracket sc \rrbracket
    _{cm,\var{remExU'}} dt \\
    (sc, dt, cm) := s & \var{remExU''}~\geq~0
    }
    {
    \begin{array}{l}
      \var{pp}\\
      \var{tx}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{remExU}\\
      \end{array}
      \right)
      \trans{sval}{\Gamma;s}
      \left(
      \begin{array}{r}
        \varUpdate{remExU''}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Script validation rules}
  \label{fig:rules:utxo-scrval}
\end{figure}


\subsection{Updating the UTxO State}
\label{sec:utxo-state-trans}

We have defined a separate transition system, UTXOS, to represent the two distinct
UTxO state changes, one resulting from all scripts in a transaction validating,
the other - from at least one failing to validate. Its transition types
are all the same as for the for the UTXO transition, see Figure
\ref{fig:ts-types:utxo-scripts}.

\begin{figure}[htb]
  \emph{State transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxo, utxos}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \GoguenTx \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO and UTxO script state update types}
  \label{fig:ts-types:utxo-scripts}
\end{figure}

There are two rules corresponding to the two possible state changes of the
UTxO state in the UTXOS transition system, see Figure~\ref{fig:rules:utxo-state-upd}.

In both cases, the SVAL transition is called upon to verify that the $\IsValidating$
tag has been applied correctly. The function $\fun{mkPLCLst}$ is used to build
the signal list $\var{sLst}$ for the SVAL transition.

The first rule
applies when the validation tag is $\True$.
In this case, the states of the UTxO, fee
  and deposit pots, and updates are updated exactly as in the current Shelley
  ledger spec.

  The second rule
  applies when the validation tag is $\False$.
  In this case, the UTxO state changes as follows:

  \begin{itemize}
    \item All the
    UTxO entries corresponding to the transaction inputs selected for covering
    script fees are removed

    \item The sum total of the value of the marked UTxO entries
    is added to the fee pot
  \end{itemize}


\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Yes]
    {
    \var{txb}\leteq\txbody{tx} &
    \fun{txvaltag}~\var{tx} = \True
    \\
    ~
    \\
    \var{sLst} := \fun{mkPLCLst}~\var{pp}~\var{tx}~\var{utxo}
    \\~\\
    {
      \left(
        \begin{array}{r}
          \var{pp} \\
          \var{tx} \\
        \end{array}
      \right)
    }
      \vdash
        \var{\fun{txexunits}~{tx}}
      \trans{sval}{sLst}\var{remExU}
      \\~\\
    {
      \left(
        \begin{array}{r}
          \var{slot} \\
          \var{pp} \\
          \var{genDelegs} \\
        \end{array}
      \right)
    }
    \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
    \\~\\
    \var{refunded} \leteq \keyRefunds{pp}{stkCreds}~{txb}
    \\
    \var{depositChange} \leteq
      (\deposits{pp}~{stpools}~{(\txcerts{txb})}) - \var{refunded}
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
      \end{array}
      \right)
      \trans{utxos}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{(\txins{txb} \subtractdom \var{utxo}) \cup \outs{slot}~{txb}}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees} + \txfee{txb}} \\
        \varUpdate{\var{ups'}} \\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-No]
    {
    \var{txb}\leteq\txbody{tx} &
    \fun{txvaltag}~\var{tx} = \False
    \\
    ~
    \\
    \var{sLst} := \fun{mkPLCLst}~\var{pp}~\var{tx}~\var{utxo}
    \\~\\
    {
      \left(
        \begin{array}{r}
          \var{pp} \\
          \var{tx} \\
        \end{array}
      \right)
    }
      \vdash
        \var{\fun{txexunits}~{tx}}
      \trans{sval}{sLst}\var{remExU}
    }
    {
    \begin{array}{l}
      \var{slot}\\
      \var{pp}\\
      \var{stkCreds}\\
      \var{stpools}\\
      \var{genDelegs}\\
    \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups} \\
      \end{array}
      \right)
      \trans{utxos}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{\fun{txinputs_{vf}}~{txb} \subtractdom \var{utxo}}}  \\
        \var{deposits} \\
        \varUpdate{\var{fees} + \fun{ubalance}~(\fun{txinputs_{vf}}~{txb}\restrictdom \var{utxo})} \\
        \var{ups} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{State update rules}
  \label{fig:rules:utxo-state-upd}
\end{figure}

In Figure \ref{fig:rules:utxo-shelley}, we present the $\type{UTxO-inductive}$
transition rule for the UTXO transition type. Note that the
signal for this transition is now specifically of type $\GoguenTx$, it does not
work with Shelley transactions (see explanation about transforming one type into
the other below). This rule
It has the following preconditions (the relevant ones remain
from the original Shelley spec):

\begin{itemize}
  \item The transaction is being processed within its validity interval

  \item The transaction has at least one input

  \item All inputs in a transaction correspond to UTxO entries

  \item The general accounting property holds

  \item The transaction is paying fees correctly

  \item The transaction is not forging any Ada

  \item All outputs of the transaction contain only non-negative quantities

  \item The transaction size does not exceed maximum

  \item The execution units budget a transaction gives does not exceed the max
  allowed units

  \item The UTXOS state transition is valid
\end{itemize}

The resulting state transition is defined entirely by the application of the
UTXOS rule.

\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    {
      \var{txb}\leteq\txbody{tx} &
      \var{txw}\leteq\fun{txwits}~{tx} \\
      \fun{txfst}~txb \leq \var{slot}
      & \fun{txttl}~txb \geq \var{slot}
      \\
      \txins{txb} \neq \emptyset
      & \txins{txb} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stkCreds}{rewards}~{txb} = \produced{slot}~{pp}~{stpools}~{txb}
      \\~\\
      \fun{feesOK}~(\vert~ \fun{txscripts}~{tx} \cap \ScriptPlutus ~\vert) ~pp~tx~utxo \\
      \\
      ~
      \\
      \mathsf{adaID}~\notin \dom~{\fun{forge}~tx} \\
      \forall txout \in \txouts{txb}, ~ \fun{getValue}~txout  ~\geq ~ 0 \\~
      \forall txout \in \txouts{txb}, ~ \fun{getCoin}~txout ~\geq \\
      \fun{valueSize}~(\fun{getValue}~txout) * \fun{minUTxOValue}~pp \\~
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp} \\
      \fun{txexunits}~{txb} \leq \fun{maxTxExUnits}~{pp}
      \\
      ~
      \\
      {
        \begin{array}{c}
          \var{slot}\\
          \var{pp}\\
          \var{stkCreds}\\
          \var{stpools}\\
          \var{genDelegs}\\
        \end{array}
      }
      \vdash
      {
        \left(
          \begin{array}{r}
            \var{utxo} \\
            \var{deposits} \\
            \var{fees} \\
            \var{ups}\\
          \end{array}
        \right)
      }
      \trans{utxos}{\var{tx}}
      {
        \left(
          \begin{array}{r}
            \var{utxo'} \\
            \var{deposits'} \\
            \var{fees'} \\
            \var{ups'}\\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stkCreds}\\
        \var{stpools}\\
        \var{genDelegs}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{utxo'}}  \\
        \varUpdate{\var{deposits'}} \\
        \varUpdate{\var{fees'}} \\
        \varUpdate{\var{ups'}}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}

\subsection{Witnessing}
\label{sec:wits}

Plutus script validation is not part of witnessing because of the introduction
of two-phase validation.
Native script validation
still is, and we need to pick only the native scripts to validate as
part of witnessing. We have changed the definition of the function
$\fun{scriptsNeeded}$, see Figure~\ref{fig:functions-witnesses}.
It now includes both MSig and Plutus scripts, and scripts used for every
validation purpose (forging, outputs, certificates, withdrawals), see Figure
\ref{fig:functions-witnesses}.


\begin{figure}[htb]
  \begin{align*}
      & \hspace{-1cm}\fun{scriptsNeeded} \in \UTxO \to \GoguenTx \to \ScriptHash\\
      & \hspace{-1cm}\text{items that need script validation and corresponding script hashes} \\
      &  \hspace{-1cm}\fun{scriptsNeeded}~\var{utxo}~\var{tx} = \\
      & ~~\{ \fun{validatorHash}~(\fun{getAddr}~{txout}) \mid i \mapsto \var{txout} \in \var{utxo},\\
      & ~~~~~i\in\fun{txinsScript}~{(\fun{txinputs}~\var{txb})}~{utxo}\} \\
      \cup & ~~\{ \var{a} \mid a \mapsto c \in \fun{txwdrls}~\var{txb}),
         a\in \AddrRWDScr \} \\
        \cup & ~~\PolicyID \cap \fun{certWitsNeeded}~{txb} \\
        \cup & ~~\{ cid \mid cid \mapsto \var{tkns}~\in~\fun{forge}~{txb} \} \\
      & \where \\
      & ~~~~~~~ \var{txb}~=~\txbody{tx}
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}

Recall here that in the Goguen era, we must be able to validate both Shelley type
and Goguen type transactions. To do this, we transform the transaction being processed
into a Goguen transaction (if it's already a Goguen one, it stays the same).
Goguen transactions have more data, so it we use defaul values to fill it in.
The only time we need the original Shelley transaction is to check the signatures
on the hash of the the orignal transaction body, see
Figure~\ref{fig:rules:utxow-goguen}. In addition to the Shelley UTXOW preconditions
that still apply, we have made the following changes and additions to the
preconditions:

\begin{itemize}

    \item All the multisig scripts the transaction is carrying validate

    \item The transaction has exactly the scripts required for witnessing and no
    additional ones (this includes all languages of scripts, for all purposes)

    \item The transaction is carrying a redeemer for every item that needs
    validation by a Plutus script

    \item The only certificates that are allowed to have scripts as witnesses
    are delegation deregistration certificates

    \item The transaction has a datum for every Plutus script output it is spending

    \item The transaction has a datum for every Plutus script output that is
    marked with the $\True$ tag for $\HasDV$

    \item
    The hash of the subset of protocol parameters in the transaction body is equal to
    the hash of the same subset of protocol parameters currently on the ledger

    \item The hash of the indexed redeemer structure attached to the transaction is
    the same as the $\fun{rdmrsHash}~{tx}$ (the hash value contained in the signed body of
    the transaction)

\end{itemize}

If these conditions are all satisfied, the resulting UTxO state change is fully determined
by the UTXO transition (the application of which is also part of the conditions).

\begin{figure}[htb]
  \emph{State transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxow}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO with witnesses state update types}
  \label{fig:ts-types:utxo-witness}
\end{figure}

\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive-goguen}
    \inference[UTxO-witG]
    {
      \var{tx}~\leteq~\fun{toGoguenTx}~{tx}_o \\~\\
      \var{txb}\leteq\txbody{tx} &
      \var{txw}\leteq\fun{txwits}~{tx} &
      \var{tx}~\in~\GoguenTx \\
      (utxo, \wcard, \wcard, \wcard) \leteq \var{utxoSt} \\
      \var{witsKeyHashes} \leteq \{\fun{hashKey}~\var{vk} \vert \var{vk} \in
      \dom (\txwitsVKey{txw}) \}\\~\\
      \forall \var{validator} \in \fun{txscripts}~{txw} \cap \ScriptMSig,\\
      \fun{runMSigScript}~\var{validator}~\var{tx}\\~\\
      \fun{scriptsNeeded}~\var{utxo}~\var{tx} ~=~ \dom (\fun{indexedScripts}~{tx}) \\
      \forall h \in ~\fun{scriptsNeeded}~\var{utxo}~\var{tx}, ~h\mapsto s~\in~\fun{indexedScripts}~{tx},\\
       s \in \ScriptPlutus~\Leftrightarrow ~\fun{findRdmr}~{tx}~{c}\neq \emptyset
      \\~\\
      \forall \var{cert}~\in~\fun{txcerts}~{txb}, \fun{regCred}~{cert}\in \PolicyID \Leftrightarrow
      \var{cert} \in~ \DCertDeRegKey \\~\\
      \forall~\var{txin}\in\fun{txinputs}~{txb},
      \var{txin} \mapsto \var{(\wcard,\wcard,h_d)} \in \var{utxo},
      \var{h_d} ~\in \fun{dom}(\fun{indexedDats}~{tx})
      \\
      ~
      \\
      \forall~ix \mapsto (a,v,d_h,\True) ~\in~\fun{txouts}~{txb}, \\
       \var{d_h}\in \fun{dom}~ (\fun{indexedDats}~{tx})
      \\
      ~
      \\
      \fun{ppHash}~{txb}~=~\fun{hashLanguagePP}~\var{pp}~(\fun{cmlangs}~(\fun{txscripts}~\var{txw})) \\~\\
      \fun{txrdmrs}~\var{txw} ~=~ \emptyset \Leftrightarrow \fun{rdmrsHash}~{txb}~=~\Nothing \\
      \fun{txrdmrs}~\var{txw} ~\neq~ \emptyset \Leftrightarrow
      \fun{hash}~(\fun{txrdmrs}~\var{txw})~ =~  \fun{rdmrsHash}~{txb} \\
      \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{txw},
      \mathcal{V}_{\var{vk}}{\serialised{tx_{o}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx}~{genDelegs} \subseteq \var{witsKeyHashes}
      \\~\\
      genSig \leteq
      \left\{
        \fun{hashKey}~gkey \vert gkey \in\dom{genDelegs}
      \right\}
      \cap
      \var{witsKeyHashes}
      \\
      \left\{
        c\in\txcerts{txb}~\cap\DCertMir
      \right\} \neq\emptyset \implies \vert genSig\vert \geq \Quorum \wedge
      \fun{d}~\var{pp} > 0
      \\~\\
      \var{mdh}\leteq\fun{txMDhash}~\var{txb}
      &
      \var{md}\leteq\fun{txMD}~\var{tx}
      \\
      (\var{mdh}=\Nothing \land \var{md}=\Nothing)
      \lor
      (\var{mdh}=\fun{hashMD}~\var{md})
      \\~\\
      {
        \begin{array}{r}
          \var{slot}\\
          \var{pp}\\
          \var{stkCreds}\\
          \var{stpools}\\
          \var{genDelegs}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{tx}
      \var{utxoSt'}\\
    }
    {
      \begin{array}{r}
        \var{slot}\\
        \var{pp}\\
        \var{stkCreds}\\
        \var{stpools}\\
        \var{genDelegs}\\
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{{tx}_o} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules for GoguenTx}
  \label{fig:rules:utxow-goguen}
\end{figure}
